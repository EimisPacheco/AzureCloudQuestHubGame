{"ast":null,"code":"import { Constants, createDocumentCollectionUri, getIdFromLink, getPathFromLink, HTTPMethod, isResourceValid, ResourceType, StatusCodes, SubStatusCodes } from \"../../common\";\nimport { convertToInternalPartitionKey } from \"../../documents\";\nimport { ResourceResponse } from \"../../request\";\nimport { ErrorResponse } from \"../../request/ErrorResponse\";\nimport { Conflict, Conflicts } from \"../Conflict\";\nimport { Item, Items } from \"../Item\";\nimport { Scripts } from \"../Script/Scripts\";\nimport { ContainerResponse } from \"./ContainerResponse\";\nimport { Offer } from \"../Offer\";\nimport { OfferResponse } from \"../Offer/OfferResponse\";\nimport { FeedRangeInternal } from \"../ChangeFeed\";\nimport { getEmptyCosmosDiagnostics, withDiagnostics, withMetadataDiagnostics } from \"../../utils/diagnostics\";\nimport { MetadataLookUpType } from \"../../CosmosDiagnostics\";\nimport { EncryptionProcessor } from \"../../encryption\";\n/**\n * Operations for reading, replacing, or deleting a specific, existing container by id.\n *\n * @see {@link Containers} for creating new containers, and reading/querying all containers; use `.containers`.\n *\n * Note: all these operations make calls against a fixed budget.\n * You should design your system such that these calls scale sublinearly with your application.\n * For instance, do not call `container(id).read()` before every single `item.read()` call, to ensure the container exists;\n * do this once on application start up.\n */\nexport class Container {\n  /**\n   * Operations for creating new items, and reading/querying all items\n   *\n   * For reading, replacing, or deleting an existing item, use `.item(id)`.\n   *\n   * @example Create a new item\n   * ```typescript\n   * const {body: createdItem} = await container.items.create({id: \"<item id>\", properties: {}});\n   * ```\n   */\n  get items() {\n    if (!this.$items) {\n      this.$items = new Items(this, this.clientContext);\n    }\n    return this.$items;\n  }\n  /**\n   * All operations for Stored Procedures, Triggers, and User Defined Functions\n   */\n  get scripts() {\n    if (!this.$scripts) {\n      this.$scripts = new Scripts(this, this.clientContext);\n    }\n    return this.$scripts;\n  }\n  /**\n   * Operations for reading and querying conflicts for the given container.\n   *\n   * For reading or deleting a specific conflict, use `.conflict(id)`.\n   */\n  get conflicts() {\n    if (!this.$conflicts) {\n      this.$conflicts = new Conflicts(this, this.clientContext);\n    }\n    return this.$conflicts;\n  }\n  /**\n   * Returns a reference URL to the resource. Used for linking in Permissions.\n   */\n  get url() {\n    return createDocumentCollectionUri(this.database.id, this.id);\n  }\n  /**\n   * Returns a container instance. Note: You should get this from `database.container(id)`, rather than creating your own object.\n   * @param database - The parent {@link Database}.\n   * @param id - The id of the given container.\n   * @hidden\n   */\n  constructor(database, id, clientContext, encryptionManager, _rid) {\n    this.database = database;\n    this.id = id;\n    this.clientContext = clientContext;\n    this.encryptionManager = encryptionManager;\n    this.isEncryptionInitialized = false;\n    this._rid = _rid;\n    if (this.clientContext.enableEncryption) {\n      this.encryptionProcessor = new EncryptionProcessor(this.id, this._rid, this.database, this.clientContext, this.encryptionManager);\n    }\n  }\n  /**\n   * Used to read, replace, or delete a specific, existing {@link Item} by id.\n   *\n   * Use `.items` for creating new items, or querying/reading all items.\n   *\n   * @param id - The id of the {@link Item}.\n   * @param partitionKeyValue - The value of the {@link Item} partition key\n   * @example Replace an item\n   * `const {body: replacedItem} = await container.item(\"<item id>\", \"<partition key value>\").replace({id: \"<item id>\", title: \"Updated post\", authorID: 5});`\n   */\n  item(id, partitionKeyValue) {\n    return new Item(this, id, this.clientContext, partitionKeyValue);\n  }\n  /**\n   * Used to read, replace, or delete a specific, existing {@link Conflict} by id.\n   *\n   * Use `.conflicts` for creating new conflicts, or querying/reading all conflicts.\n   * @param id - The id of the {@link Conflict}.\n   */\n  conflict(id, partitionKey) {\n    return new Conflict(this, id, this.clientContext, partitionKey);\n  }\n  /** Read the container's definition */\n  async read(options) {\n    return withDiagnostics(async diagnosticNode => {\n      return this.readInternal(diagnosticNode, options);\n    }, this.clientContext);\n  }\n  /**\n   * @hidden\n   */\n  async readInternal(diagnosticNode, options) {\n    const path = getPathFromLink(this.url);\n    const id = getIdFromLink(this.url);\n    const response = await this.clientContext.read({\n      path,\n      resourceType: ResourceType.container,\n      resourceId: id,\n      options,\n      diagnosticNode\n    });\n    this.clientContext.partitionKeyDefinitionCache[this.url] = response.result.partitionKey;\n    return new ContainerResponse(response.result, response.headers, response.code, this, getEmptyCosmosDiagnostics());\n  }\n  /** Replace the container's definition */\n  async replace(body, options) {\n    return withDiagnostics(async diagnosticNode => {\n      const err = {};\n      if (!isResourceValid(body, err)) {\n        throw err;\n      }\n      const path = getPathFromLink(this.url);\n      const id = getIdFromLink(this.url);\n      const response = await this.clientContext.replace({\n        body,\n        path,\n        resourceType: ResourceType.container,\n        resourceId: id,\n        options,\n        diagnosticNode\n      });\n      return new ContainerResponse(response.result, response.headers, response.code, this, getEmptyCosmosDiagnostics());\n    }, this.clientContext);\n  }\n  /** Delete the container */\n  async delete(options) {\n    return withDiagnostics(async diagnosticNode => {\n      const path = getPathFromLink(this.url);\n      const id = getIdFromLink(this.url);\n      const response = await this.clientContext.delete({\n        path,\n        resourceType: ResourceType.container,\n        resourceId: id,\n        options,\n        diagnosticNode\n      });\n      return new ContainerResponse(response.result, response.headers, response.code, this, getEmptyCosmosDiagnostics());\n    }, this.clientContext);\n  }\n  /**\n   * Gets the partition key definition first by looking into the cache otherwise by reading the collection.\n   * @deprecated This method has been renamed to readPartitionKeyDefinition.\n   */\n  async getPartitionKeyDefinition() {\n    return withDiagnostics(async diagnosticNode => {\n      return this.readPartitionKeyDefinition(diagnosticNode);\n    }, this.clientContext);\n  }\n  /**\n   * Gets the partition key definition first by looking into the cache otherwise by reading the collection.\n   * @hidden\n   */\n  async readPartitionKeyDefinition(diagnosticNode) {\n    // $ISSUE-felixfan-2016-03-17: Make name based path and link based path use the same key\n    // $ISSUE-felixfan-2016-03-17: Refresh partitionKeyDefinitionCache when necessary\n    if (this.url in this.clientContext.partitionKeyDefinitionCache) {\n      diagnosticNode.addData({\n        readFromCache: true\n      });\n      return new ResourceResponse(this.clientContext.partitionKeyDefinitionCache[this.url], {}, 0, getEmptyCosmosDiagnostics());\n    }\n    const {\n      headers,\n      statusCode,\n      diagnostics\n    } = await withMetadataDiagnostics(async node => {\n      return this.readInternal(node);\n    }, diagnosticNode, MetadataLookUpType.ContainerLookUp);\n    return new ResourceResponse(this.clientContext.partitionKeyDefinitionCache[this.url], headers, statusCode, diagnostics);\n  }\n  /**\n   * Gets offer on container. If none exists, returns an OfferResponse with undefined.\n   */\n  async readOffer(options = {}) {\n    return withDiagnostics(async diagnosticNode => {\n      const {\n        resource: container\n      } = await this.read();\n      const path = \"/offers\";\n      const url = container._self;\n      const response = await this.clientContext.queryFeed({\n        path,\n        resourceId: \"\",\n        resourceType: ResourceType.offer,\n        query: `SELECT * from root where root.resource = \"${url}\"`,\n        resultFn: result => result.Offers,\n        options,\n        diagnosticNode\n      });\n      const offer = response.result[0] ? new Offer(this.database.client, response.result[0].id, this.clientContext) : undefined;\n      return new OfferResponse(response.result[0], response.headers, response.code, getEmptyCosmosDiagnostics(), offer);\n    }, this.clientContext);\n  }\n  async getQueryPlan(query) {\n    return withDiagnostics(async diagnosticNode => {\n      const path = getPathFromLink(this.url);\n      return this.clientContext.getQueryPlan(path + \"/docs\", ResourceType.item, getIdFromLink(this.url), query, {}, diagnosticNode);\n    }, this.clientContext);\n  }\n  readPartitionKeyRanges(feedOptions) {\n    feedOptions = feedOptions || {};\n    return this.clientContext.queryPartitionKeyRanges(this.url, undefined, feedOptions);\n  }\n  /**\n   *\n   * @returns all the feed ranges for which changefeed could be fetched.\n   */\n  async getFeedRanges() {\n    return withDiagnostics(async diagnosticNode => {\n      const {\n        resources\n      } = await this.readPartitionKeyRanges().fetchAllInternal(diagnosticNode);\n      const feedRanges = [];\n      for (const resource of resources) {\n        const feedRange = new FeedRangeInternal(resource.minInclusive, resource.maxExclusive);\n        Object.freeze(feedRange);\n        feedRanges.push(feedRange);\n      }\n      return feedRanges;\n    }, this.clientContext);\n  }\n  /**\n   * Delete all documents belong to the container for the provided partition key value\n   * @param partitionKey - The partition key value of the items to be deleted\n   */\n  async deleteAllItemsForPartitionKey(partitionKey, options) {\n    return withDiagnostics(async diagnosticNode => {\n      let path = getPathFromLink(this.url);\n      const id = getIdFromLink(this.url);\n      path = path + \"/operations/partitionkeydelete\";\n      if (this.clientContext.enableEncryption) {\n        await this.checkAndInitializeEncryption();\n        options = options || {};\n        options.containerRid = this._rid;\n        diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsEncryptOperation);\n        const partitionKeyInternal = convertToInternalPartitionKey(partitionKey);\n        const {\n          partitionKeyList,\n          encryptedCount\n        } = await this.encryptionProcessor.getEncryptedPartitionKeyValue(partitionKeyInternal);\n        partitionKey = partitionKeyList;\n        diagnosticNode.endEncryptionDiagnostics(Constants.Encryption.DiagnosticsEncryptOperation, encryptedCount);\n      }\n      let response;\n      try {\n        response = await this.clientContext.delete({\n          path,\n          resourceType: ResourceType.container,\n          resourceId: id,\n          options,\n          partitionKey: partitionKey,\n          method: HTTPMethod.post,\n          diagnosticNode\n        });\n      } catch (error) {\n        if (this.clientContext.enableEncryption) {\n          await this.throwIfRequestNeedsARetryPostPolicyRefresh(error);\n        }\n        throw error;\n      }\n      return new ContainerResponse(response.result, response.headers, response.code, this, getEmptyCosmosDiagnostics());\n    }, this.clientContext);\n  }\n  /**\n   * Warms up encryption related caches for the container.\n   */\n  async initializeEncryption() {\n    if (!this.clientContext.enableEncryption) {\n      throw new ErrorResponse(\"Encryption is not enabled for the client.\");\n    } else {\n      await withDiagnostics(async diagnosticNode => {\n        const readResponse = await this.readInternal(diagnosticNode);\n        if (!readResponse || !readResponse.resource) {\n          throw new ErrorResponse(\"Failed to initialize encryption: The container's resource definition could not be retrieved.\");\n        }\n        this._rid = readResponse.resource._rid;\n        this.encryptionProcessor.containerRid = this._rid;\n        const clientEncryptionPolicy = readResponse.resource.clientEncryptionPolicy;\n        if (!clientEncryptionPolicy) return;\n        const partitionKeyPaths = readResponse.resource.partitionKey.paths;\n        const databaseResponse = await this.database.readInternal(diagnosticNode);\n        if (!databaseResponse || !databaseResponse.resource) {\n          throw new ErrorResponse(\"Failed to initialize encryption: The database's resource definition could not be retrieved.\");\n        }\n        this.database._rid = databaseResponse.resource._rid;\n        const encryptionSettingKey = this.database._rid + \"/\" + this._rid;\n        await this.encryptionManager.encryptionSettingsCache.create(encryptionSettingKey, this._rid, partitionKeyPaths, clientEncryptionPolicy);\n        const clientEncryptionKeyIds = [...new Set(clientEncryptionPolicy.includedPaths.map(item => item.clientEncryptionKeyId))];\n        // fetch and set clientEncryptionKeys in the cache\n        for (const clientEncryptionKeyId of clientEncryptionKeyIds) {\n          const res = await this.database.readClientEncryptionKey(clientEncryptionKeyId);\n          if (!res || !res.clientEncryptionKeyProperties) {\n            throw new ErrorResponse(`Failed to initialize encryption: The client encryption key ${clientEncryptionKeyId} could not be retrieved.`);\n          }\n          const encryptionKeyProperties = res.clientEncryptionKeyProperties;\n          const key = this.database._rid + \"/\" + clientEncryptionKeyId;\n          this.encryptionManager.clientEncryptionKeyPropertiesCache.set(key, encryptionKeyProperties);\n        }\n        this.isEncryptionInitialized = true;\n      }, this.clientContext);\n    }\n  }\n  /**\n   * @internal\n   */\n  async checkAndInitializeEncryption() {\n    if (!this.isEncryptionInitialized) {\n      if (!this.encryptionInitializationPromise) {\n        this.encryptionInitializationPromise = this.initializeEncryption();\n      }\n      await this.encryptionInitializationPromise;\n    }\n  }\n  /**\n   * @internal\n   * This function handles the scenario where a container is deleted(say from different Client) and recreated with same Id but with different client encryption policy.\n   * The idea is to have the container Rid cached and sent out as part of RequestOptions with Container Rid set in \"x-ms-cosmos-intended-collection-rid\" header.\n   * So, when the container being referenced here gets recreated we would end up with a stale encryption settings and container Rid and this would result in BadRequest (and a substatus 1024).\n   * This would allow us to refresh the encryption settings and Container Rid, on the premise that the container recreated could possibly be configured with a new encryption policy.\n   */\n  async throwIfRequestNeedsARetryPostPolicyRefresh(errorResponse) {\n    var _a;\n    const key = this.database._rid + \"/\" + this._rid;\n    const encryptionSetting = this.encryptionManager.encryptionSettingsCache.get(key);\n    if (!(errorResponse === null || errorResponse === void 0 ? void 0 : errorResponse.code) || !((_a = errorResponse === null || errorResponse === void 0 ? void 0 : errorResponse.headers) === null || _a === void 0 ? void 0 : _a[Constants.HttpHeaders.SubStatus])) {\n      return;\n    }\n    const subStatusCode = errorResponse.headers[Constants.HttpHeaders.SubStatus];\n    const isPartitionKeyMismatch = Number(subStatusCode) === SubStatusCodes.PartitionKeyMismatch;\n    const isIncorrectContainerRidSubstatus = Number(subStatusCode) === SubStatusCodes.IncorrectContainerRidSubstatus;\n    if (errorResponse.code === StatusCodes.BadRequest && (isPartitionKeyMismatch || isIncorrectContainerRidSubstatus)) {\n      // This code verifies if the partitionKeyPaths are encrypted.\n      // If the paths are not encrypted, it indicates that the application passed an incorrect partition key in the request.\n      // This ensures the issue is not caused by a mismatched encrypted value due to a policy error,\n      // avoiding unnecessary force-refreshing of encryption settings.\n      if (isPartitionKeyMismatch && encryptionSetting.partitionKeyPaths.length) {\n        let encryptionSettingsForProperty = null;\n        for (const path of encryptionSetting.partitionKeyPaths) {\n          const partitionKeyPath = path.split(\"/\")[1];\n          encryptionSettingsForProperty = encryptionSetting.getEncryptionSettingForProperty(partitionKeyPath);\n          if (encryptionSettingsForProperty) {\n            break;\n          }\n        }\n        // wrong partition key passed as partition key is not encrypted.\n        if (encryptionSettingsForProperty == null) {\n          return;\n        }\n      }\n      const currentContainerRid = encryptionSetting.containerRid;\n      const forceRefresh = true;\n      // fetch rid of newly created container\n      const updatedContainerRid = (await this.encryptionProcessor.getEncryptionSetting(forceRefresh)).containerRid;\n      // if the container was not recreated, so policy has not changed, just return the original response\n      if (currentContainerRid === updatedContainerRid) {\n        return;\n      }\n      await this.initializeEncryption();\n      throw new ErrorResponse(\"Operation has failed due to a possible mismatch in Client Encryption Policy configured on the container. Retrying may fix the issue. Please refer to https://aka.ms/CosmosClientEncryption for more details.\" + errorResponse.message);\n    }\n  }\n}","map":{"version":3,"names":["Constants","createDocumentCollectionUri","getIdFromLink","getPathFromLink","HTTPMethod","isResourceValid","ResourceType","StatusCodes","SubStatusCodes","convertToInternalPartitionKey","ResourceResponse","ErrorResponse","Conflict","Conflicts","Item","Items","Scripts","ContainerResponse","Offer","OfferResponse","FeedRangeInternal","getEmptyCosmosDiagnostics","withDiagnostics","withMetadataDiagnostics","MetadataLookUpType","EncryptionProcessor","Container","items","$items","clientContext","scripts","$scripts","conflicts","$conflicts","url","database","id","constructor","encryptionManager","_rid","isEncryptionInitialized","enableEncryption","encryptionProcessor","item","partitionKeyValue","conflict","partitionKey","read","options","diagnosticNode","readInternal","path","response","resourceType","container","resourceId","partitionKeyDefinitionCache","result","headers","code","replace","body","err","delete","getPartitionKeyDefinition","readPartitionKeyDefinition","addData","readFromCache","statusCode","diagnostics","node","ContainerLookUp","readOffer","resource","_self","queryFeed","offer","query","resultFn","Offers","client","undefined","getQueryPlan","readPartitionKeyRanges","feedOptions","queryPartitionKeyRanges","getFeedRanges","resources","fetchAllInternal","feedRanges","feedRange","minInclusive","maxExclusive","Object","freeze","push","deleteAllItemsForPartitionKey","checkAndInitializeEncryption","containerRid","beginEncryptionDiagnostics","Encryption","DiagnosticsEncryptOperation","partitionKeyInternal","partitionKeyList","encryptedCount","getEncryptedPartitionKeyValue","endEncryptionDiagnostics","method","post","error","throwIfRequestNeedsARetryPostPolicyRefresh","initializeEncryption","readResponse","clientEncryptionPolicy","partitionKeyPaths","paths","databaseResponse","encryptionSettingKey","encryptionSettingsCache","create","clientEncryptionKeyIds","Set","includedPaths","map","clientEncryptionKeyId","res","readClientEncryptionKey","clientEncryptionKeyProperties","encryptionKeyProperties","key","clientEncryptionKeyPropertiesCache","set","encryptionInitializationPromise","errorResponse","encryptionSetting","get","_a","HttpHeaders","SubStatus","subStatusCode","isPartitionKeyMismatch","Number","PartitionKeyMismatch","isIncorrectContainerRidSubstatus","IncorrectContainerRidSubstatus","BadRequest","length","encryptionSettingsForProperty","partitionKeyPath","split","getEncryptionSettingForProperty","currentContainerRid","forceRefresh","updatedContainerRid","getEncryptionSetting","message"],"sources":["/Users/eimis/test-server/Azure Hackthons/azure-cloud-architecture-game /node_modules/@azure/cosmos/src/client/Container/Container.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { ClientContext } from \"../../ClientContext\";\nimport {\n  Constants,\n  createDocumentCollectionUri,\n  getIdFromLink,\n  getPathFromLink,\n  HTTPMethod,\n  isResourceValid,\n  ResourceType,\n  StatusCodes,\n  SubStatusCodes,\n} from \"../../common\";\nimport type { PartitionKey, PartitionKeyDefinition } from \"../../documents\";\nimport { convertToInternalPartitionKey } from \"../../documents\";\nimport type { SqlQuerySpec } from \"../../queryExecutionContext\";\nimport type { QueryIterator } from \"../../queryIterator\";\nimport type { FeedOptions, RequestOptions, Response } from \"../../request\";\nimport { ResourceResponse } from \"../../request\";\nimport type { PartitionedQueryExecutionInfo } from \"../../request/ErrorResponse\";\nimport { ErrorResponse } from \"../../request/ErrorResponse\";\nimport { Conflict, Conflicts } from \"../Conflict\";\nimport type { Database } from \"../Database\";\nimport { Item, Items } from \"../Item\";\nimport { Scripts } from \"../Script/Scripts\";\nimport type { ContainerDefinition } from \"./ContainerDefinition\";\nimport { ContainerResponse } from \"./ContainerResponse\";\nimport type { PartitionKeyRange } from \"./PartitionKeyRange\";\nimport type { OfferDefinition } from \"../Offer\";\nimport { Offer } from \"../Offer\";\nimport { OfferResponse } from \"../Offer/OfferResponse\";\nimport type { Resource } from \"../Resource\";\nimport type { FeedRange } from \"../ChangeFeed\";\nimport { FeedRangeInternal } from \"../ChangeFeed\";\nimport type { DiagnosticNodeInternal } from \"../../diagnostics/DiagnosticNodeInternal\";\nimport {\n  getEmptyCosmosDiagnostics,\n  withDiagnostics,\n  withMetadataDiagnostics,\n} from \"../../utils/diagnostics\";\nimport { MetadataLookUpType } from \"../../CosmosDiagnostics\";\nimport type { EncryptionSettingForProperty } from \"../../encryption\";\nimport { EncryptionProcessor } from \"../../encryption\";\nimport type { EncryptionManager } from \"../../encryption/EncryptionManager\";\n\n/**\n * Operations for reading, replacing, or deleting a specific, existing container by id.\n *\n * @see {@link Containers} for creating new containers, and reading/querying all containers; use `.containers`.\n *\n * Note: all these operations make calls against a fixed budget.\n * You should design your system such that these calls scale sublinearly with your application.\n * For instance, do not call `container(id).read()` before every single `item.read()` call, to ensure the container exists;\n * do this once on application start up.\n */\nexport class Container {\n  private $items: Items;\n  /**\n   * Operations for creating new items, and reading/querying all items\n   *\n   * For reading, replacing, or deleting an existing item, use `.item(id)`.\n   *\n   * @example Create a new item\n   * ```typescript\n   * const {body: createdItem} = await container.items.create({id: \"<item id>\", properties: {}});\n   * ```\n   */\n  public get items(): Items {\n    if (!this.$items) {\n      this.$items = new Items(this, this.clientContext);\n    }\n    return this.$items;\n  }\n\n  private $scripts: Scripts;\n  /**\n   * All operations for Stored Procedures, Triggers, and User Defined Functions\n   */\n  public get scripts(): Scripts {\n    if (!this.$scripts) {\n      this.$scripts = new Scripts(this, this.clientContext);\n    }\n    return this.$scripts;\n  }\n\n  private $conflicts: Conflicts;\n  /**\n   * Operations for reading and querying conflicts for the given container.\n   *\n   * For reading or deleting a specific conflict, use `.conflict(id)`.\n   */\n  public get conflicts(): Conflicts {\n    if (!this.$conflicts) {\n      this.$conflicts = new Conflicts(this, this.clientContext);\n    }\n    return this.$conflicts;\n  }\n\n  /**\n   * Returns a reference URL to the resource. Used for linking in Permissions.\n   */\n  public get url(): string {\n    return createDocumentCollectionUri(this.database.id, this.id);\n  }\n  /**\n   * @internal\n   */\n  public encryptionProcessor: EncryptionProcessor;\n\n  /**\n   * @internal\n   */\n  public _rid: string;\n\n  private isEncryptionInitialized: boolean = false;\n  private encryptionInitializationPromise: Promise<void>;\n\n  /**\n   * Returns a container instance. Note: You should get this from `database.container(id)`, rather than creating your own object.\n   * @param database - The parent {@link Database}.\n   * @param id - The id of the given container.\n   * @hidden\n   */\n  constructor(\n    public readonly database: Database,\n    public readonly id: string,\n    private readonly clientContext: ClientContext,\n    private encryptionManager?: EncryptionManager,\n    _rid?: string,\n  ) {\n    this._rid = _rid;\n    if (this.clientContext.enableEncryption) {\n      this.encryptionProcessor = new EncryptionProcessor(\n        this.id,\n        this._rid,\n        this.database,\n        this.clientContext,\n        this.encryptionManager,\n      );\n    }\n  }\n\n  /**\n   * Used to read, replace, or delete a specific, existing {@link Item} by id.\n   *\n   * Use `.items` for creating new items, or querying/reading all items.\n   *\n   * @param id - The id of the {@link Item}.\n   * @param partitionKeyValue - The value of the {@link Item} partition key\n   * @example Replace an item\n   * `const {body: replacedItem} = await container.item(\"<item id>\", \"<partition key value>\").replace({id: \"<item id>\", title: \"Updated post\", authorID: 5});`\n   */\n  public item(id: string, partitionKeyValue?: PartitionKey): Item {\n    return new Item(this, id, this.clientContext, partitionKeyValue);\n  }\n\n  /**\n   * Used to read, replace, or delete a specific, existing {@link Conflict} by id.\n   *\n   * Use `.conflicts` for creating new conflicts, or querying/reading all conflicts.\n   * @param id - The id of the {@link Conflict}.\n   */\n  public conflict(id: string, partitionKey?: PartitionKey): Conflict {\n    return new Conflict(this, id, this.clientContext, partitionKey);\n  }\n\n  /** Read the container's definition */\n  public async read(options?: RequestOptions): Promise<ContainerResponse> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      return this.readInternal(diagnosticNode, options);\n    }, this.clientContext);\n  }\n\n  /**\n   * @hidden\n   */\n  public async readInternal(\n    diagnosticNode: DiagnosticNodeInternal,\n    options?: RequestOptions,\n  ): Promise<ContainerResponse> {\n    const path = getPathFromLink(this.url);\n    const id = getIdFromLink(this.url);\n    const response = await this.clientContext.read<ContainerDefinition>({\n      path,\n      resourceType: ResourceType.container,\n      resourceId: id,\n      options,\n      diagnosticNode,\n    });\n    this.clientContext.partitionKeyDefinitionCache[this.url] = response.result.partitionKey;\n    return new ContainerResponse(\n      response.result,\n      response.headers,\n      response.code,\n      this,\n      getEmptyCosmosDiagnostics(),\n    );\n  }\n\n  /** Replace the container's definition */\n  public async replace(\n    body: ContainerDefinition,\n    options?: RequestOptions,\n  ): Promise<ContainerResponse> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      const err = {};\n      if (!isResourceValid(body, err)) {\n        throw err;\n      }\n      const path = getPathFromLink(this.url);\n      const id = getIdFromLink(this.url);\n\n      const response = await this.clientContext.replace<ContainerDefinition>({\n        body,\n        path,\n        resourceType: ResourceType.container,\n        resourceId: id,\n        options,\n        diagnosticNode,\n      });\n      return new ContainerResponse(\n        response.result,\n        response.headers,\n        response.code,\n        this,\n        getEmptyCosmosDiagnostics(),\n      );\n    }, this.clientContext);\n  }\n\n  /** Delete the container */\n  public async delete(options?: RequestOptions): Promise<ContainerResponse> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      const path = getPathFromLink(this.url);\n      const id = getIdFromLink(this.url);\n\n      const response = await this.clientContext.delete<ContainerDefinition>({\n        path,\n        resourceType: ResourceType.container,\n        resourceId: id,\n        options,\n        diagnosticNode,\n      });\n      return new ContainerResponse(\n        response.result,\n        response.headers,\n        response.code,\n        this,\n        getEmptyCosmosDiagnostics(),\n      );\n    }, this.clientContext);\n  }\n\n  /**\n   * Gets the partition key definition first by looking into the cache otherwise by reading the collection.\n   * @deprecated This method has been renamed to readPartitionKeyDefinition.\n   */\n  public async getPartitionKeyDefinition(): Promise<ResourceResponse<PartitionKeyDefinition>> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      return this.readPartitionKeyDefinition(diagnosticNode);\n    }, this.clientContext);\n  }\n\n  /**\n   * Gets the partition key definition first by looking into the cache otherwise by reading the collection.\n   * @hidden\n   */\n  public async readPartitionKeyDefinition(\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<ResourceResponse<PartitionKeyDefinition>> {\n    // $ISSUE-felixfan-2016-03-17: Make name based path and link based path use the same key\n    // $ISSUE-felixfan-2016-03-17: Refresh partitionKeyDefinitionCache when necessary\n    if (this.url in this.clientContext.partitionKeyDefinitionCache) {\n      diagnosticNode.addData({ readFromCache: true });\n      return new ResourceResponse<PartitionKeyDefinition>(\n        this.clientContext.partitionKeyDefinitionCache[this.url],\n        {},\n        0,\n        getEmptyCosmosDiagnostics(),\n      );\n    }\n\n    const { headers, statusCode, diagnostics } = await withMetadataDiagnostics(\n      async (node: DiagnosticNodeInternal) => {\n        return this.readInternal(node);\n      },\n      diagnosticNode,\n      MetadataLookUpType.ContainerLookUp,\n    );\n\n    return new ResourceResponse<PartitionKeyDefinition>(\n      this.clientContext.partitionKeyDefinitionCache[this.url],\n      headers,\n      statusCode,\n      diagnostics,\n    );\n  }\n\n  /**\n   * Gets offer on container. If none exists, returns an OfferResponse with undefined.\n   */\n  public async readOffer(options: RequestOptions = {}): Promise<OfferResponse> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      const { resource: container } = await this.read();\n      const path = \"/offers\";\n      const url = container._self;\n\n      const response = await this.clientContext.queryFeed<OfferDefinition & Resource[]>({\n        path,\n        resourceId: \"\",\n        resourceType: ResourceType.offer,\n        query: `SELECT * from root where root.resource = \"${url}\"`,\n        resultFn: (result) => result.Offers,\n        options,\n        diagnosticNode,\n      });\n      const offer = response.result[0]\n        ? new Offer(this.database.client, response.result[0].id, this.clientContext)\n        : undefined;\n      return new OfferResponse(\n        response.result[0],\n        response.headers,\n        response.code,\n        getEmptyCosmosDiagnostics(),\n        offer,\n      );\n    }, this.clientContext);\n  }\n\n  public async getQueryPlan(\n    query: string | SqlQuerySpec,\n  ): Promise<Response<PartitionedQueryExecutionInfo>> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      const path = getPathFromLink(this.url);\n\n      return this.clientContext.getQueryPlan(\n        path + \"/docs\",\n        ResourceType.item,\n        getIdFromLink(this.url),\n        query,\n        {},\n        diagnosticNode,\n      );\n    }, this.clientContext);\n  }\n\n  public readPartitionKeyRanges(feedOptions?: FeedOptions): QueryIterator<PartitionKeyRange> {\n    feedOptions = feedOptions || {};\n    return this.clientContext.queryPartitionKeyRanges(this.url, undefined, feedOptions);\n  }\n  /**\n   *\n   * @returns all the feed ranges for which changefeed could be fetched.\n   */\n  public async getFeedRanges(): Promise<ReadonlyArray<FeedRange>> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      const { resources } = await this.readPartitionKeyRanges().fetchAllInternal(diagnosticNode);\n\n      const feedRanges: FeedRange[] = [];\n      for (const resource of resources) {\n        const feedRange = new FeedRangeInternal(resource.minInclusive, resource.maxExclusive);\n        Object.freeze(feedRange);\n        feedRanges.push(feedRange);\n      }\n      return feedRanges;\n    }, this.clientContext);\n  }\n\n  /**\n   * Delete all documents belong to the container for the provided partition key value\n   * @param partitionKey - The partition key value of the items to be deleted\n   */\n  public async deleteAllItemsForPartitionKey(\n    partitionKey: PartitionKey,\n    options?: RequestOptions,\n  ): Promise<ContainerResponse> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      let path = getPathFromLink(this.url);\n      const id = getIdFromLink(this.url);\n      path = path + \"/operations/partitionkeydelete\";\n      if (this.clientContext.enableEncryption) {\n        await this.checkAndInitializeEncryption();\n        options = options || {};\n        options.containerRid = this._rid;\n        diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsEncryptOperation);\n        const partitionKeyInternal = convertToInternalPartitionKey(partitionKey);\n        const { partitionKeyList, encryptedCount } =\n          await this.encryptionProcessor.getEncryptedPartitionKeyValue(partitionKeyInternal);\n        partitionKey = partitionKeyList;\n        diagnosticNode.endEncryptionDiagnostics(\n          Constants.Encryption.DiagnosticsEncryptOperation,\n          encryptedCount,\n        );\n      }\n      let response: Response<any>;\n      try {\n        response = await this.clientContext.delete<ContainerDefinition>({\n          path,\n          resourceType: ResourceType.container,\n          resourceId: id,\n          options,\n          partitionKey: partitionKey,\n          method: HTTPMethod.post,\n          diagnosticNode,\n        });\n      } catch (error) {\n        if (this.clientContext.enableEncryption) {\n          await this.throwIfRequestNeedsARetryPostPolicyRefresh(error);\n        }\n        throw error;\n      }\n\n      return new ContainerResponse(\n        response.result,\n        response.headers,\n        response.code,\n        this,\n        getEmptyCosmosDiagnostics(),\n      );\n    }, this.clientContext);\n  }\n  /**\n   * Warms up encryption related caches for the container.\n   */\n  public async initializeEncryption(): Promise<void> {\n    if (!this.clientContext.enableEncryption) {\n      throw new ErrorResponse(\"Encryption is not enabled for the client.\");\n    } else {\n      await withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n        const readResponse = await this.readInternal(diagnosticNode);\n        if (!readResponse || !readResponse.resource) {\n          throw new ErrorResponse(\n            \"Failed to initialize encryption: The container's resource definition could not be retrieved.\",\n          );\n        }\n        this._rid = readResponse.resource._rid;\n        this.encryptionProcessor.containerRid = this._rid;\n        const clientEncryptionPolicy = readResponse.resource.clientEncryptionPolicy;\n        if (!clientEncryptionPolicy) return;\n        const partitionKeyPaths = readResponse.resource.partitionKey.paths;\n        const databaseResponse = await this.database.readInternal(diagnosticNode);\n        if (!databaseResponse || !databaseResponse.resource) {\n          throw new ErrorResponse(\n            \"Failed to initialize encryption: The database's resource definition could not be retrieved.\",\n          );\n        }\n        this.database._rid = databaseResponse.resource._rid;\n        const encryptionSettingKey = this.database._rid + \"/\" + this._rid;\n\n        await this.encryptionManager.encryptionSettingsCache.create(\n          encryptionSettingKey,\n          this._rid,\n          partitionKeyPaths,\n          clientEncryptionPolicy,\n        );\n        const clientEncryptionKeyIds = [\n          ...new Set(\n            clientEncryptionPolicy.includedPaths.map((item) => item.clientEncryptionKeyId),\n          ),\n        ];\n        // fetch and set clientEncryptionKeys in the cache\n        for (const clientEncryptionKeyId of clientEncryptionKeyIds) {\n          const res = await this.database.readClientEncryptionKey(clientEncryptionKeyId);\n          if (!res || !res.clientEncryptionKeyProperties) {\n            throw new ErrorResponse(\n              `Failed to initialize encryption: The client encryption key ${clientEncryptionKeyId} could not be retrieved.`,\n            );\n          }\n          const encryptionKeyProperties = res.clientEncryptionKeyProperties;\n          const key = this.database._rid + \"/\" + clientEncryptionKeyId;\n\n          this.encryptionManager.clientEncryptionKeyPropertiesCache.set(\n            key,\n            encryptionKeyProperties,\n          );\n        }\n        this.isEncryptionInitialized = true;\n      }, this.clientContext);\n    }\n  }\n\n  /**\n   * @internal\n   */\n  async checkAndInitializeEncryption(): Promise<void> {\n    if (!this.isEncryptionInitialized) {\n      if (!this.encryptionInitializationPromise) {\n        this.encryptionInitializationPromise = this.initializeEncryption();\n      }\n      await this.encryptionInitializationPromise;\n    }\n  }\n\n  /**\n   * @internal\n   * This function handles the scenario where a container is deleted(say from different Client) and recreated with same Id but with different client encryption policy.\n   * The idea is to have the container Rid cached and sent out as part of RequestOptions with Container Rid set in \"x-ms-cosmos-intended-collection-rid\" header.\n   * So, when the container being referenced here gets recreated we would end up with a stale encryption settings and container Rid and this would result in BadRequest (and a substatus 1024).\n   * This would allow us to refresh the encryption settings and Container Rid, on the premise that the container recreated could possibly be configured with a new encryption policy.\n   */\n  async throwIfRequestNeedsARetryPostPolicyRefresh(errorResponse: ErrorResponse): Promise<void> {\n    const key = this.database._rid + \"/\" + this._rid;\n    const encryptionSetting = this.encryptionManager.encryptionSettingsCache.get(key);\n    if (!errorResponse?.code || !errorResponse?.headers?.[Constants.HttpHeaders.SubStatus]) {\n      return;\n    }\n    const subStatusCode = errorResponse.headers[Constants.HttpHeaders.SubStatus];\n    const isPartitionKeyMismatch = Number(subStatusCode) === SubStatusCodes.PartitionKeyMismatch;\n    const isIncorrectContainerRidSubstatus =\n      Number(subStatusCode) === SubStatusCodes.IncorrectContainerRidSubstatus;\n    if (\n      errorResponse.code === StatusCodes.BadRequest &&\n      (isPartitionKeyMismatch || isIncorrectContainerRidSubstatus)\n    ) {\n      // This code verifies if the partitionKeyPaths are encrypted.\n      // If the paths are not encrypted, it indicates that the application passed an incorrect partition key in the request.\n      // This ensures the issue is not caused by a mismatched encrypted value due to a policy error,\n      // avoiding unnecessary force-refreshing of encryption settings.\n      if (isPartitionKeyMismatch && encryptionSetting.partitionKeyPaths.length) {\n        let encryptionSettingsForProperty: EncryptionSettingForProperty = null;\n        for (const path of encryptionSetting.partitionKeyPaths) {\n          const partitionKeyPath = path.split(\"/\")[1];\n          encryptionSettingsForProperty =\n            encryptionSetting.getEncryptionSettingForProperty(partitionKeyPath);\n          if (encryptionSettingsForProperty) {\n            break;\n          }\n        }\n        // wrong partition key passed as partition key is not encrypted.\n        if (encryptionSettingsForProperty == null) {\n          return;\n        }\n      }\n\n      const currentContainerRid = encryptionSetting.containerRid;\n      const forceRefresh = true;\n      // fetch rid of newly created container\n      const updatedContainerRid = (\n        await this.encryptionProcessor.getEncryptionSetting(forceRefresh)\n      ).containerRid;\n      // if the container was not recreated, so policy has not changed, just return the original response\n      if (currentContainerRid === updatedContainerRid) {\n        return;\n      }\n      await this.initializeEncryption();\n      throw new ErrorResponse(\n        \"Operation has failed due to a possible mismatch in Client Encryption Policy configured on the container. Retrying may fix the issue. Please refer to https://aka.ms/CosmosClientEncryption for more details.\" +\n          errorResponse.message,\n      );\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}