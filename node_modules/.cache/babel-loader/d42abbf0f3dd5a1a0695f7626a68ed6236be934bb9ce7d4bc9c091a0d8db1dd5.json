{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { Constants } from \"../common\";\n/**\n * Class to store encryption keys in unwrapped form and provide an interface for wrapping and unwrapping the keys.\n */\nexport class EncryptionKeyStoreProvider {\n  constructor(keyEncryptionKeyResolver, cacheTimeToLive) {\n    this.keyEncryptionKeyResolver = keyEncryptionKeyResolver;\n    this.cacheTimeToLive = cacheTimeToLive;\n    this.RsaOaepEncryptionAlgorithm = \"RSA-OAEP\";\n    this.keyEncryptionKeyResolver = keyEncryptionKeyResolver;\n    this.providerName = keyEncryptionKeyResolver.encryptionKeyResolverName;\n    this.unwrappedEncryptionKeyCache = {};\n    this.cacheTimeToLive = cacheTimeToLive;\n    this.clearCacheOnTtlExpiry();\n  }\n  async wrapKey(encryptionKeyId, algorithm, key) {\n    const uInt8ArrayKey = new Uint8Array(key);\n    const wrappedEncryptionKey = await this.keyEncryptionKeyResolver.wrapKey(encryptionKeyId, algorithm, uInt8ArrayKey);\n    return Buffer.from(wrappedEncryptionKey);\n  }\n  async unwrapKey(encryptionKeyId, algorithm, wrappedKey) {\n    if (this.cacheTimeToLive === 0) {\n      const res = await this.keyEncryptionKeyResolver.unwrapKey(encryptionKeyId, algorithm, wrappedKey);\n      return Buffer.from(res);\n    }\n    if (!this.unwrappedEncryptionKeyCache[encryptionKeyId]) {\n      const wrappedKeyUint8Array = new Uint8Array(wrappedKey);\n      const plainEncryptionKey = await this.keyEncryptionKeyResolver.unwrapKey(encryptionKeyId, algorithm, wrappedKeyUint8Array);\n      const plainEncryptionKeyBuffer = Buffer.from(plainEncryptionKey);\n      this.unwrappedEncryptionKeyCache[encryptionKeyId] = [new Date(), plainEncryptionKeyBuffer];\n    }\n    return this.unwrappedEncryptionKeyCache[encryptionKeyId][1];\n  }\n  async clearCacheOnTtlExpiry() {\n    this.cacheRefresher = setInterval(() => {\n      const now = new Date();\n      for (const key in this.unwrappedEncryptionKeyCache) {\n        if (now.getTime() - this.unwrappedEncryptionKeyCache[key][0].getTime() > this.cacheTimeToLive) {\n          delete this.unwrappedEncryptionKeyCache[key];\n        }\n      }\n    }, Constants.EncryptionCacheRefreshIntervalInMs);\n  }\n}","map":{"version":3,"names":["Constants","EncryptionKeyStoreProvider","constructor","keyEncryptionKeyResolver","cacheTimeToLive","RsaOaepEncryptionAlgorithm","providerName","encryptionKeyResolverName","unwrappedEncryptionKeyCache","clearCacheOnTtlExpiry","wrapKey","encryptionKeyId","algorithm","key","uInt8ArrayKey","Uint8Array","wrappedEncryptionKey","Buffer","from","unwrapKey","wrappedKey","res","wrappedKeyUint8Array","plainEncryptionKey","plainEncryptionKeyBuffer","Date","cacheRefresher","setInterval","now","getTime","EncryptionCacheRefreshIntervalInMs"],"sources":["/Users/eimis/test-server/Azure Hackthons/azure-cloud-architecture-game /node_modules/@azure/cosmos/src/encryption/EncryptionKeyStoreProvider.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { Constants } from \"../common\";\nimport type { EncryptionKeyResolver } from \"./EncryptionKeyResolver\";\nimport type { KeyEncryptionAlgorithm } from \"./enums\";\n/**\n * Class to store encryption keys in unwrapped form and provide an interface for wrapping and unwrapping the keys.\n */\nexport class EncryptionKeyStoreProvider {\n  public RsaOaepEncryptionAlgorithm: string = \"RSA-OAEP\";\n  // interval for clear cache to run\n  cacheRefresher: NodeJS.Timeout;\n\n  // cache to store the unwrapped encryption key. Key is the path of the encryption key\n  public unwrappedEncryptionKeyCache: { [key: string]: [Date, Buffer] };\n  public providerName: string;\n  constructor(\n    private keyEncryptionKeyResolver: EncryptionKeyResolver,\n    private cacheTimeToLive: number,\n  ) {\n    this.keyEncryptionKeyResolver = keyEncryptionKeyResolver;\n    this.providerName = keyEncryptionKeyResolver.encryptionKeyResolverName;\n    this.unwrappedEncryptionKeyCache = {};\n    this.cacheTimeToLive = cacheTimeToLive;\n    this.clearCacheOnTtlExpiry();\n  }\n\n  public async wrapKey(\n    encryptionKeyId: string,\n    algorithm: KeyEncryptionAlgorithm,\n    key: Buffer,\n  ): Promise<Buffer> {\n    const uInt8ArrayKey = new Uint8Array(key);\n    const wrappedEncryptionKey = await this.keyEncryptionKeyResolver.wrapKey(\n      encryptionKeyId,\n      algorithm,\n      uInt8ArrayKey,\n    );\n    return Buffer.from(wrappedEncryptionKey);\n  }\n\n  public async unwrapKey(\n    encryptionKeyId: string,\n    algorithm: KeyEncryptionAlgorithm,\n    wrappedKey: Buffer,\n  ): Promise<Buffer> {\n    if (this.cacheTimeToLive === 0) {\n      const res = await this.keyEncryptionKeyResolver.unwrapKey(\n        encryptionKeyId,\n        algorithm,\n        wrappedKey,\n      );\n      return Buffer.from(res);\n    }\n    if (!this.unwrappedEncryptionKeyCache[encryptionKeyId]) {\n      const wrappedKeyUint8Array = new Uint8Array(wrappedKey);\n      const plainEncryptionKey = await this.keyEncryptionKeyResolver.unwrapKey(\n        encryptionKeyId,\n        algorithm,\n        wrappedKeyUint8Array,\n      );\n      const plainEncryptionKeyBuffer = Buffer.from(plainEncryptionKey);\n      this.unwrappedEncryptionKeyCache[encryptionKeyId] = [new Date(), plainEncryptionKeyBuffer];\n    }\n    return this.unwrappedEncryptionKeyCache[encryptionKeyId][1];\n  }\n\n  private async clearCacheOnTtlExpiry(): Promise<void> {\n    this.cacheRefresher = setInterval(() => {\n      const now = new Date();\n      for (const key in this.unwrappedEncryptionKeyCache) {\n        if (\n          now.getTime() - this.unwrappedEncryptionKeyCache[key][0].getTime() >\n          this.cacheTimeToLive\n        ) {\n          delete this.unwrappedEncryptionKeyCache[key];\n        }\n      }\n    }, Constants.EncryptionCacheRefreshIntervalInMs);\n  }\n}\n"],"mappings":"AAAA;AACA;AAEA,SAASA,SAAS,QAAQ,WAAW;AAGrC;;;AAGA,OAAM,MAAOC,0BAA0B;EAQrCC,YACUC,wBAA+C,EAC/CC,eAAuB;IADvB,KAAAD,wBAAwB,GAAxBA,wBAAwB;IACxB,KAAAC,eAAe,GAAfA,eAAe;IATlB,KAAAC,0BAA0B,GAAW,UAAU;IAWpD,IAAI,CAACF,wBAAwB,GAAGA,wBAAwB;IACxD,IAAI,CAACG,YAAY,GAAGH,wBAAwB,CAACI,yBAAyB;IACtE,IAAI,CAACC,2BAA2B,GAAG,EAAE;IACrC,IAAI,CAACJ,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACK,qBAAqB,EAAE;EAC9B;EAEO,MAAMC,OAAOA,CAClBC,eAAuB,EACvBC,SAAiC,EACjCC,GAAW;IAEX,MAAMC,aAAa,GAAG,IAAIC,UAAU,CAACF,GAAG,CAAC;IACzC,MAAMG,oBAAoB,GAAG,MAAM,IAAI,CAACb,wBAAwB,CAACO,OAAO,CACtEC,eAAe,EACfC,SAAS,EACTE,aAAa,CACd;IACD,OAAOG,MAAM,CAACC,IAAI,CAACF,oBAAoB,CAAC;EAC1C;EAEO,MAAMG,SAASA,CACpBR,eAAuB,EACvBC,SAAiC,EACjCQ,UAAkB;IAElB,IAAI,IAAI,CAAChB,eAAe,KAAK,CAAC,EAAE;MAC9B,MAAMiB,GAAG,GAAG,MAAM,IAAI,CAAClB,wBAAwB,CAACgB,SAAS,CACvDR,eAAe,EACfC,SAAS,EACTQ,UAAU,CACX;MACD,OAAOH,MAAM,CAACC,IAAI,CAACG,GAAG,CAAC;IACzB;IACA,IAAI,CAAC,IAAI,CAACb,2BAA2B,CAACG,eAAe,CAAC,EAAE;MACtD,MAAMW,oBAAoB,GAAG,IAAIP,UAAU,CAACK,UAAU,CAAC;MACvD,MAAMG,kBAAkB,GAAG,MAAM,IAAI,CAACpB,wBAAwB,CAACgB,SAAS,CACtER,eAAe,EACfC,SAAS,EACTU,oBAAoB,CACrB;MACD,MAAME,wBAAwB,GAAGP,MAAM,CAACC,IAAI,CAACK,kBAAkB,CAAC;MAChE,IAAI,CAACf,2BAA2B,CAACG,eAAe,CAAC,GAAG,CAAC,IAAIc,IAAI,EAAE,EAAED,wBAAwB,CAAC;IAC5F;IACA,OAAO,IAAI,CAAChB,2BAA2B,CAACG,eAAe,CAAC,CAAC,CAAC,CAAC;EAC7D;EAEQ,MAAMF,qBAAqBA,CAAA;IACjC,IAAI,CAACiB,cAAc,GAAGC,WAAW,CAAC,MAAK;MACrC,MAAMC,GAAG,GAAG,IAAIH,IAAI,EAAE;MACtB,KAAK,MAAMZ,GAAG,IAAI,IAAI,CAACL,2BAA2B,EAAE;QAClD,IACEoB,GAAG,CAACC,OAAO,EAAE,GAAG,IAAI,CAACrB,2BAA2B,CAACK,GAAG,CAAC,CAAC,CAAC,CAAC,CAACgB,OAAO,EAAE,GAClE,IAAI,CAACzB,eAAe,EACpB;UACA,OAAO,IAAI,CAACI,2BAA2B,CAACK,GAAG,CAAC;QAC9C;MACF;IACF,CAAC,EAAEb,SAAS,CAAC8B,kCAAkC,CAAC;EAClD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}