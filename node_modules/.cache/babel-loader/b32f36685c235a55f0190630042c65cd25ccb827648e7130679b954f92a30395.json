{"ast":null,"code":"import { NumberSerializer, FloatSerializer, StringSerializer, BooleanSerializer } from \"../encryption/Serializers\";\nimport { EncryptionType } from \"../encryption/enums/EncryptionType\";\nimport { TypeMarker } from \"../encryption/enums/TypeMarker\";\nimport { ErrorResponse } from \"../request/ErrorResponse\";\nimport { OperationType } from \"./constants\";\nconst trimLeftSlashes = new RegExp(\"^[/]+\");\nconst trimRightSlashes = new RegExp(\"[/]+$\");\nconst illegalResourceIdCharacters = new RegExp(\"[/\\\\\\\\?#]\");\nconst illegalItemResourceIdCharacters = new RegExp(\"[/\\\\\\\\#]\");\n/** @hidden */\nexport function jsonStringifyAndEscapeNonASCII(arg) {\n  // TODO: better way for this? Not sure.\n  // escapes non-ASCII characters as \\uXXXX\n  return JSON.stringify(arg).replace(/[\\u007F-\\uFFFF]/g, m => {\n    return \"\\\\u\" + (\"0000\" + m.charCodeAt(0).toString(16)).slice(-4);\n  });\n}\n/**\n * @hidden\n */\nexport function parseLink(resourcePath) {\n  if (resourcePath.length === 0) {\n    /* for DatabaseAccount case, both type and objectBody will be undefined. */\n    return {\n      type: undefined,\n      objectBody: undefined\n    };\n  }\n  if (resourcePath[resourcePath.length - 1] !== \"/\") {\n    resourcePath = resourcePath + \"/\";\n  }\n  if (resourcePath[0] !== \"/\") {\n    resourcePath = \"/\" + resourcePath;\n  }\n  /*\n         The path will be in the form of /[resourceType]/[resourceId]/ ....\n         /[resourceType]//[resourceType]/[resourceId]/ .... /[resourceType]/[resourceId]/\n         or /[resourceType]/[resourceId]/ .... /[resourceType]/[resourceId]/[resourceType]/[resourceId]/ ....\n          /[resourceType]/[resourceId]/\n         The result of split will be in the form of\n         [[[resourceType], [resourceId] ... ,[resourceType], [resourceId], \"\"]\n         In the first case, to extract the resourceId it will the element before last ( at length -2 )\n         and the type will be before it ( at length -3 )\n         In the second case, to extract the resource type it will the element before last ( at length -2 )\n        */\n  const pathParts = resourcePath.split(\"/\");\n  let id;\n  let type;\n  if (pathParts.length % 2 === 0) {\n    // request in form /[resourceType]/[resourceId]/ .... /[resourceType]/[resourceId].\n    id = pathParts[pathParts.length - 2];\n    type = pathParts[pathParts.length - 3];\n  } else {\n    // request in form /[resourceType]/[resourceId]/ .... /[resourceType]/.\n    id = pathParts[pathParts.length - 3];\n    type = pathParts[pathParts.length - 2];\n  }\n  const result = {\n    type,\n    objectBody: {\n      id,\n      self: resourcePath\n    }\n  };\n  return result;\n}\n/**\n * @hidden\n */\nexport function isReadRequest(operationType) {\n  return operationType === OperationType.Read || operationType === OperationType.Query;\n}\n/**\n * @hidden\n */\nexport function sleep(time) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve();\n    }, time);\n  });\n}\n/**\n * @hidden\n */\nexport function getContainerLink(link) {\n  return link.split(\"/\").slice(0, 4).join(\"/\");\n}\n/**\n * @hidden\n */\nexport function prepareURL(endpoint, path) {\n  return trimSlashes(endpoint) + path;\n}\n/**\n * @hidden\n */\nexport function trimSlashes(source) {\n  return source.replace(trimLeftSlashes, \"\").replace(trimRightSlashes, \"\");\n}\n/**\n * @hidden\n */\nexport function getHexaDigit() {\n  return Math.floor(Math.random() * 16).toString(16);\n}\n/**\n * @hidden\n */\nexport function parsePath(path) {\n  const pathParts = [];\n  let currentIndex = 0;\n  const throwError = () => {\n    throw new Error(\"Path \" + path + \" is invalid at index \" + currentIndex);\n  };\n  const getEscapedToken = () => {\n    const quote = path[currentIndex];\n    let newIndex = ++currentIndex;\n    for (;;) {\n      newIndex = path.indexOf(quote, newIndex);\n      if (newIndex === -1) {\n        throwError();\n      }\n      if (path[newIndex - 1] !== \"\\\\\") {\n        break;\n      }\n      ++newIndex;\n    }\n    const token = path.substr(currentIndex, newIndex - currentIndex);\n    currentIndex = newIndex + 1;\n    return token;\n  };\n  const getToken = () => {\n    const newIndex = path.indexOf(\"/\", currentIndex);\n    let token = null;\n    if (newIndex === -1) {\n      token = path.substr(currentIndex);\n      currentIndex = path.length;\n    } else {\n      token = path.substr(currentIndex, newIndex - currentIndex);\n      currentIndex = newIndex;\n    }\n    token = token.trim();\n    return token;\n  };\n  while (currentIndex < path.length) {\n    if (path[currentIndex] !== \"/\") {\n      throwError();\n    }\n    if (++currentIndex === path.length) {\n      break;\n    }\n    if (path[currentIndex] === '\"' || path[currentIndex] === \"'\") {\n      pathParts.push(getEscapedToken());\n    } else {\n      pathParts.push(getToken());\n    }\n  }\n  return pathParts;\n}\n/**\n * @hidden\n */\nexport function isResourceValid(resource, err) {\n  // TODO: fix strictness issues so that caller contexts respects the types of the functions\n  if (resource.id) {\n    if (typeof resource.id !== \"string\") {\n      err.message = \"Id must be a string.\";\n      return false;\n    }\n    if (resource.id.indexOf(\"/\") !== -1 || resource.id.indexOf(\"\\\\\") !== -1 || resource.id.indexOf(\"?\") !== -1 || resource.id.indexOf(\"#\") !== -1) {\n      err.message = \"Id contains illegal chars.\";\n      return false;\n    }\n    if (resource.id[resource.id.length - 1] === \" \") {\n      err.message = \"Id ends with a space.\";\n      return false;\n    }\n  }\n  return true;\n}\n/**\n * @hidden\n */\nexport function isItemResourceValid(resource, err) {\n  // TODO: fix strictness issues so that caller contexts respects the types of the functions\n  if (resource.id) {\n    if (typeof resource.id !== \"string\") {\n      err.message = \"Id must be a string.\";\n      return false;\n    }\n    if (resource.id.indexOf(\"/\") !== -1 || resource.id.indexOf(\"\\\\\") !== -1 || resource.id.indexOf(\"#\") !== -1) {\n      err.message = \"Id contains illegal chars.\";\n      return false;\n    }\n  }\n  return true;\n}\n/** @hidden */\nexport function getIdFromLink(resourceLink) {\n  resourceLink = trimSlashes(resourceLink);\n  return resourceLink;\n}\n/** @hidden */\nexport function getPathFromLink(resourceLink, resourceType) {\n  resourceLink = trimSlashes(resourceLink);\n  if (resourceType) {\n    return \"/\" + encodeURI(resourceLink) + \"/\" + resourceType;\n  } else {\n    return \"/\" + encodeURI(resourceLink);\n  }\n}\n/**\n * @hidden\n */\nexport function isStringNullOrEmpty(inputString) {\n  // checks whether string is null, undefined, empty or only contains space\n  return !inputString || /^\\s*$/.test(inputString);\n}\n/**\n * @hidden\n */\nexport function trimSlashFromLeftAndRight(inputString) {\n  if (typeof inputString !== \"string\") {\n    throw new Error(\"invalid input: input is not string\");\n  }\n  return inputString.replace(trimLeftSlashes, \"\").replace(trimRightSlashes, \"\");\n}\n/**\n * @hidden\n */\nexport function validateResourceId(resourceId) {\n  // if resourceId is not a string or is empty throw an error\n  if (typeof resourceId !== \"string\" || isStringNullOrEmpty(resourceId)) {\n    throw new Error(\"Resource ID must be a string and cannot be undefined, null or empty\");\n  }\n  // if resource id contains illegal characters throw an error\n  if (illegalResourceIdCharacters.test(resourceId)) {\n    throw new Error(\"Illegal characters ['/', '\\\\', '#', '?'] cannot be used in Resource ID\");\n  }\n  return true;\n}\n/**\n * @hidden\n */\nexport function validateItemResourceId(resourceId) {\n  // if resourceId is not a string or is empty throw an error\n  if (typeof resourceId !== \"string\" || isStringNullOrEmpty(resourceId)) {\n    throw new Error(\"Resource ID must be a string and cannot be undefined, null or empty\");\n  }\n  // if resource id contains illegal characters throw an error\n  if (illegalItemResourceIdCharacters.test(resourceId)) {\n    throw new Error(\"Illegal characters ['/', '\\\\', '#'] cannot be used in Resource ID\");\n  }\n  return true;\n}\n/**\n * @hidden\n */\nexport function getResourceIdFromPath(resourcePath) {\n  if (!resourcePath || typeof resourcePath !== \"string\") {\n    return null;\n  }\n  const trimmedPath = trimSlashFromLeftAndRight(resourcePath);\n  const pathSegments = trimmedPath.split(\"/\");\n  // number of segments of a path must always be even\n  if (pathSegments.length % 2 !== 0) {\n    return null;\n  }\n  return pathSegments[pathSegments.length - 1];\n}\n/**\n * @hidden\n */\nexport function parseConnectionString(connectionString) {\n  const keyValueStrings = connectionString.split(\";\");\n  const {\n    AccountEndpoint,\n    AccountKey\n  } = keyValueStrings.reduce((connectionObject, keyValueString) => {\n    const [key, ...value] = keyValueString.split(\"=\");\n    connectionObject[key] = value.join(\"=\");\n    return connectionObject;\n  }, {});\n  if (!AccountEndpoint || !AccountKey) {\n    throw new Error(\"Could not parse the provided connection string\");\n  }\n  return {\n    endpoint: AccountEndpoint,\n    key: AccountKey\n  };\n}\n/**\n * utility function to return copy of object to avoid encryption of original object passed\n * in the CRUD methods.\n * @hidden\n */\n/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-shadow, no-prototype-builtins */\nexport function copyObject(obj) {\n  return JSON.parse(JSON.stringify(obj, (_, value) => {\n    if (typeof value === \"bigint\") {\n      throw new Error(`BigInt type is not supported`);\n    }\n    return value;\n  }));\n}\n/**\n * @hidden\n */\nexport function createDeserializer(typeMarker) {\n  switch (typeMarker) {\n    case TypeMarker.Long:\n      {\n        // return instance\n        return new NumberSerializer();\n      }\n    case TypeMarker.Double:\n      return new FloatSerializer();\n    case TypeMarker.String:\n      return new StringSerializer();\n    case TypeMarker.Boolean:\n      return new BooleanSerializer();\n    default:\n      throw new Error(\"Invalid or Unsupported data type passed.\");\n  }\n}\n/**\n * @hidden\n * extracts the top-level path\n */\nexport function extractPath(path) {\n  const secondSlashIndex = path.indexOf(\"/\", path.indexOf(\"/\") + 1);\n  return secondSlashIndex === -1 ? path : path.substring(0, secondSlashIndex);\n}\nexport function createSerializer(propertyValue, type) {\n  if (type) {\n    if (type === TypeMarker.Long) {\n      return [TypeMarker.Long, new NumberSerializer()];\n    } else if (type === TypeMarker.Double) {\n      return [TypeMarker.Double, new FloatSerializer()];\n    } else if (type === TypeMarker.String) {\n      return [TypeMarker.String, new StringSerializer()];\n    } else if (type === TypeMarker.Boolean) {\n      return [TypeMarker.Boolean, new BooleanSerializer()];\n    } else {\n      throw new Error(\"Invalid or Unsupported data type passed.\");\n    }\n  } else {\n    switch (typeof propertyValue) {\n      case \"boolean\":\n        return [TypeMarker.Boolean, new BooleanSerializer()];\n      case \"string\":\n        return [TypeMarker.String, new StringSerializer()];\n      case \"object\":\n        if (propertyValue.constructor === Date) {\n          return [TypeMarker.String, new StringSerializer()];\n        }\n        throw new Error(\"Invalid or Unsupported data type passed.\");\n      case \"number\":\n        if (!Number.isInteger(propertyValue)) {\n          return [TypeMarker.Double, new FloatSerializer()];\n        } else {\n          return [TypeMarker.Long, new NumberSerializer()];\n        }\n      default:\n        throw new Error(\"Invalid or Unsupported data type passed.\");\n    }\n  }\n}\n/**\n * @hidden\n * verifies policy format version, included paths and ensures that id and partition key paths specified in the client encryption policy\n * for encryption are encrypted using Deterministic encryption algorithm.\n */\nexport function validateClientEncryptionPolicy(clientEncryptionPolicy, partitionKey) {\n  const policyFormatVersion = clientEncryptionPolicy.policyFormatVersion;\n  if (policyFormatVersion < 1 || policyFormatVersion > 2) {\n    throw new ErrorResponse(\"Supported versions of client encryption policy are 1 and 2.\");\n  }\n  const paths = new Set();\n  // checks for duplicate paths and validates the path format and clientEncryptionKeyId\n  for (const includedPath of clientEncryptionPolicy.includedPaths) {\n    if (paths.has(includedPath.path)) {\n      throw new ErrorResponse(`Duplicate path found: ${includedPath.path} in client encryption policy.`);\n    }\n    if (includedPath.path === undefined || includedPath.path === null || includedPath.path === \"\" || includedPath.path === \"/\") {\n      throw new ErrorResponse(\"Path needs to be defined in ClientEncryptionIncludedPath.\");\n    }\n    if (includedPath.clientEncryptionKeyId === undefined || includedPath.clientEncryptionKeyId === null || includedPath.clientEncryptionKeyId === \"\" || typeof includedPath.clientEncryptionKeyId !== \"string\") {\n      throw new ErrorResponse(\"ClientEncryptionKeyId needs to be defined as string type in ClientEncryptionIncludedPath.\");\n    }\n    if (includedPath.path[0] !== \"/\") {\n      throw new ErrorResponse(\"Path in ClientEncryptionIncludedPath must start with '/'.\");\n    }\n    const pathSegments = includedPath.path.split(\"/\").filter(segment => segment.length > 0);\n    if (pathSegments.length > 1) {\n      throw new ErrorResponse(\"Only top-level paths are currently supported for encryption\");\n    }\n    paths.add(includedPath.path);\n  }\n  // checks if id and partition key paths are encrypted using Deterministic encryption algorithm.\n  const encryptedPaths = clientEncryptionPolicy.includedPaths;\n  const partitionKeyPaths = partitionKey.paths.map(extractPath);\n  let isPartitionKeyEncrypted = false;\n  let isIdEncrypted = false;\n  for (const encryptedPath of encryptedPaths) {\n    if (encryptedPath.path === \"/id\") {\n      isIdEncrypted = true;\n      if (encryptedPath.encryptionType !== EncryptionType.DETERMINISTIC) {\n        throw new ErrorResponse(\"The '/id' property must be encrypted using Deterministic encryption.\");\n      }\n    }\n    if (partitionKeyPaths.includes(encryptedPath.path)) {\n      isPartitionKeyEncrypted = true;\n      if (encryptedPath.encryptionType !== EncryptionType.DETERMINISTIC) {\n        throw new ErrorResponse(`Path: ${encryptedPath.path} which is part of the partition key has to be encrypted with Deterministic type Encryption.`);\n      }\n    }\n  }\n  // Ensures that the policy format version is 2 if id or partition key paths are encrypted.\n  if ((isPartitionKeyEncrypted || isIdEncrypted) && clientEncryptionPolicy.policyFormatVersion === 1) {\n    throw new ErrorResponse(\"Encryption of partition key or id is only supported with policy format version 2.\");\n  }\n}","map":{"version":3,"names":["NumberSerializer","FloatSerializer","StringSerializer","BooleanSerializer","EncryptionType","TypeMarker","ErrorResponse","OperationType","trimLeftSlashes","RegExp","trimRightSlashes","illegalResourceIdCharacters","illegalItemResourceIdCharacters","jsonStringifyAndEscapeNonASCII","arg","JSON","stringify","replace","m","charCodeAt","toString","slice","parseLink","resourcePath","length","type","undefined","objectBody","pathParts","split","id","result","self","isReadRequest","operationType","Read","Query","sleep","time","Promise","resolve","setTimeout","getContainerLink","link","join","prepareURL","endpoint","path","trimSlashes","source","getHexaDigit","Math","floor","random","parsePath","currentIndex","throwError","Error","getEscapedToken","quote","newIndex","indexOf","token","substr","getToken","trim","push","isResourceValid","resource","err","message","isItemResourceValid","getIdFromLink","resourceLink","getPathFromLink","resourceType","encodeURI","isStringNullOrEmpty","inputString","test","trimSlashFromLeftAndRight","validateResourceId","resourceId","validateItemResourceId","getResourceIdFromPath","trimmedPath","pathSegments","parseConnectionString","connectionString","keyValueStrings","AccountEndpoint","AccountKey","reduce","connectionObject","keyValueString","key","value","copyObject","obj","parse","_","createDeserializer","typeMarker","Long","Double","String","Boolean","extractPath","secondSlashIndex","substring","createSerializer","propertyValue","constructor","Date","Number","isInteger","validateClientEncryptionPolicy","clientEncryptionPolicy","partitionKey","policyFormatVersion","paths","Set","includedPath","includedPaths","has","clientEncryptionKeyId","filter","segment","add","encryptedPaths","partitionKeyPaths","map","isPartitionKeyEncrypted","isIdEncrypted","encryptedPath","encryptionType","DETERMINISTIC","includes"],"sources":["/Users/eimis/test-server/Azure Hackthons/azure-cloud-architecture-game /node_modules/@azure/cosmos/src/common/helper.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { CosmosClientOptions } from \"../CosmosClientOptions\";\nimport { PartitionKeyDefinition } from \"../documents\";\nimport { ClientEncryptionPolicy } from \"../encryption/ClientEncryptionPolicy\";\nimport {\n  Serializer,\n  NumberSerializer,\n  FloatSerializer,\n  StringSerializer,\n  BooleanSerializer,\n} from \"../encryption/Serializers\";\nimport { EncryptionType } from \"../encryption/enums/EncryptionType\";\nimport { TypeMarker } from \"../encryption/enums/TypeMarker\";\nimport { ErrorResponse } from \"../request/ErrorResponse\";\nimport { OperationType, ResourceType } from \"./constants\";\n\nconst trimLeftSlashes = new RegExp(\"^[/]+\");\nconst trimRightSlashes = new RegExp(\"[/]+$\");\nconst illegalResourceIdCharacters = new RegExp(\"[/\\\\\\\\?#]\");\nconst illegalItemResourceIdCharacters = new RegExp(\"[/\\\\\\\\#]\");\n\n/** @hidden */\nexport function jsonStringifyAndEscapeNonASCII(arg: unknown): string {\n  // TODO: better way for this? Not sure.\n  // escapes non-ASCII characters as \\uXXXX\n  return JSON.stringify(arg).replace(/[\\u007F-\\uFFFF]/g, (m) => {\n    return \"\\\\u\" + (\"0000\" + m.charCodeAt(0).toString(16)).slice(-4);\n  });\n}\n\n/**\n * @hidden\n */\nexport function parseLink(resourcePath: string): {\n  type: ResourceType;\n  objectBody: {\n    id: string;\n    self: string;\n  };\n} {\n  if (resourcePath.length === 0) {\n    /* for DatabaseAccount case, both type and objectBody will be undefined. */\n    return {\n      type: undefined,\n      objectBody: undefined,\n    };\n  }\n\n  if (resourcePath[resourcePath.length - 1] !== \"/\") {\n    resourcePath = resourcePath + \"/\";\n  }\n\n  if (resourcePath[0] !== \"/\") {\n    resourcePath = \"/\" + resourcePath;\n  }\n\n  /*\n         The path will be in the form of /[resourceType]/[resourceId]/ ....\n         /[resourceType]//[resourceType]/[resourceId]/ .... /[resourceType]/[resourceId]/\n         or /[resourceType]/[resourceId]/ .... /[resourceType]/[resourceId]/[resourceType]/[resourceId]/ ....\n          /[resourceType]/[resourceId]/\n         The result of split will be in the form of\n         [[[resourceType], [resourceId] ... ,[resourceType], [resourceId], \"\"]\n         In the first case, to extract the resourceId it will the element before last ( at length -2 )\n         and the type will be before it ( at length -3 )\n         In the second case, to extract the resource type it will the element before last ( at length -2 )\n        */\n  const pathParts = resourcePath.split(\"/\");\n  let id;\n  let type: ResourceType;\n  if (pathParts.length % 2 === 0) {\n    // request in form /[resourceType]/[resourceId]/ .... /[resourceType]/[resourceId].\n    id = pathParts[pathParts.length - 2];\n    type = pathParts[pathParts.length - 3] as ResourceType;\n  } else {\n    // request in form /[resourceType]/[resourceId]/ .... /[resourceType]/.\n    id = pathParts[pathParts.length - 3];\n    type = pathParts[pathParts.length - 2] as ResourceType;\n  }\n\n  const result = {\n    type,\n    objectBody: {\n      id,\n      self: resourcePath,\n    },\n  };\n\n  return result;\n}\n\n/**\n * @hidden\n */\nexport function isReadRequest(operationType: OperationType): boolean {\n  return operationType === OperationType.Read || operationType === OperationType.Query;\n}\n\n/**\n * @hidden\n */\nexport function sleep(time: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve();\n    }, time);\n  });\n}\n\n/**\n * @hidden\n */\nexport function getContainerLink(link: string): string {\n  return link.split(\"/\").slice(0, 4).join(\"/\");\n}\n\n/**\n * @hidden\n */\nexport function prepareURL(endpoint: string, path: string): string {\n  return trimSlashes(endpoint) + path;\n}\n\n/**\n * @hidden\n */\nexport function trimSlashes(source: string): string {\n  return source.replace(trimLeftSlashes, \"\").replace(trimRightSlashes, \"\");\n}\n\n/**\n * @hidden\n */\nexport function getHexaDigit(): string {\n  return Math.floor(Math.random() * 16).toString(16);\n}\n\n/**\n * @hidden\n */\nexport function parsePath(path: string): string[] {\n  const pathParts = [];\n  let currentIndex = 0;\n\n  const throwError = (): never => {\n    throw new Error(\"Path \" + path + \" is invalid at index \" + currentIndex);\n  };\n\n  const getEscapedToken = (): string => {\n    const quote = path[currentIndex];\n    let newIndex = ++currentIndex;\n\n    for (;;) {\n      newIndex = path.indexOf(quote, newIndex);\n      if (newIndex === -1) {\n        throwError();\n      }\n\n      if (path[newIndex - 1] !== \"\\\\\") {\n        break;\n      }\n\n      ++newIndex;\n    }\n\n    const token = path.substr(currentIndex, newIndex - currentIndex);\n    currentIndex = newIndex + 1;\n    return token;\n  };\n\n  const getToken = (): string => {\n    const newIndex = path.indexOf(\"/\", currentIndex);\n    let token = null;\n    if (newIndex === -1) {\n      token = path.substr(currentIndex);\n      currentIndex = path.length;\n    } else {\n      token = path.substr(currentIndex, newIndex - currentIndex);\n      currentIndex = newIndex;\n    }\n\n    token = token.trim();\n    return token;\n  };\n\n  while (currentIndex < path.length) {\n    if (path[currentIndex] !== \"/\") {\n      throwError();\n    }\n\n    if (++currentIndex === path.length) {\n      break;\n    }\n\n    if (path[currentIndex] === '\"' || path[currentIndex] === \"'\") {\n      pathParts.push(getEscapedToken());\n    } else {\n      pathParts.push(getToken());\n    }\n  }\n\n  return pathParts;\n}\n\n/**\n * @hidden\n */\nexport function isResourceValid(resource: { id?: string }, err: { message?: string }): boolean {\n  // TODO: fix strictness issues so that caller contexts respects the types of the functions\n  if (resource.id) {\n    if (typeof resource.id !== \"string\") {\n      err.message = \"Id must be a string.\";\n      return false;\n    }\n\n    if (\n      resource.id.indexOf(\"/\") !== -1 ||\n      resource.id.indexOf(\"\\\\\") !== -1 ||\n      resource.id.indexOf(\"?\") !== -1 ||\n      resource.id.indexOf(\"#\") !== -1\n    ) {\n      err.message = \"Id contains illegal chars.\";\n      return false;\n    }\n\n    if (resource.id[resource.id.length - 1] === \" \") {\n      err.message = \"Id ends with a space.\";\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * @hidden\n */\nexport function isItemResourceValid(resource: { id?: string }, err: { message?: string }): boolean {\n  // TODO: fix strictness issues so that caller contexts respects the types of the functions\n  if (resource.id) {\n    if (typeof resource.id !== \"string\") {\n      err.message = \"Id must be a string.\";\n      return false;\n    }\n\n    if (\n      resource.id.indexOf(\"/\") !== -1 ||\n      resource.id.indexOf(\"\\\\\") !== -1 ||\n      resource.id.indexOf(\"#\") !== -1\n    ) {\n      err.message = \"Id contains illegal chars.\";\n      return false;\n    }\n  }\n  return true;\n}\n\n/** @hidden */\nexport function getIdFromLink(resourceLink: string): string {\n  resourceLink = trimSlashes(resourceLink);\n  return resourceLink;\n}\n\n/** @hidden */\nexport function getPathFromLink(resourceLink: string, resourceType?: string): string {\n  resourceLink = trimSlashes(resourceLink);\n  if (resourceType) {\n    return \"/\" + encodeURI(resourceLink) + \"/\" + resourceType;\n  } else {\n    return \"/\" + encodeURI(resourceLink);\n  }\n}\n\n/**\n * @hidden\n */\nexport function isStringNullOrEmpty(inputString: string): boolean {\n  // checks whether string is null, undefined, empty or only contains space\n  return !inputString || /^\\s*$/.test(inputString);\n}\n\n/**\n * @hidden\n */\nexport function trimSlashFromLeftAndRight(inputString: string): string {\n  if (typeof inputString !== \"string\") {\n    throw new Error(\"invalid input: input is not string\");\n  }\n\n  return inputString.replace(trimLeftSlashes, \"\").replace(trimRightSlashes, \"\");\n}\n\n/**\n * @hidden\n */\nexport function validateResourceId(resourceId: string): boolean {\n  // if resourceId is not a string or is empty throw an error\n  if (typeof resourceId !== \"string\" || isStringNullOrEmpty(resourceId)) {\n    throw new Error(\"Resource ID must be a string and cannot be undefined, null or empty\");\n  }\n\n  // if resource id contains illegal characters throw an error\n  if (illegalResourceIdCharacters.test(resourceId)) {\n    throw new Error(\"Illegal characters ['/', '\\\\', '#', '?'] cannot be used in Resource ID\");\n  }\n\n  return true;\n}\n\n/**\n * @hidden\n */\nexport function validateItemResourceId(resourceId: string): boolean {\n  // if resourceId is not a string or is empty throw an error\n  if (typeof resourceId !== \"string\" || isStringNullOrEmpty(resourceId)) {\n    throw new Error(\"Resource ID must be a string and cannot be undefined, null or empty\");\n  }\n\n  // if resource id contains illegal characters throw an error\n  if (illegalItemResourceIdCharacters.test(resourceId)) {\n    throw new Error(\"Illegal characters ['/', '\\\\', '#'] cannot be used in Resource ID\");\n  }\n\n  return true;\n}\n\n/**\n * @hidden\n */\nexport function getResourceIdFromPath(resourcePath: string): string {\n  if (!resourcePath || typeof resourcePath !== \"string\") {\n    return null;\n  }\n\n  const trimmedPath = trimSlashFromLeftAndRight(resourcePath);\n  const pathSegments = trimmedPath.split(\"/\");\n\n  // number of segments of a path must always be even\n  if (pathSegments.length % 2 !== 0) {\n    return null;\n  }\n\n  return pathSegments[pathSegments.length - 1];\n}\n\n/**\n * @hidden\n */\ninterface ConnectionObject {\n  AccountEndpoint: string;\n  AccountKey: string;\n}\n\n/**\n * @hidden\n */\nexport function parseConnectionString(connectionString: string): CosmosClientOptions {\n  const keyValueStrings = connectionString.split(\";\");\n  const { AccountEndpoint, AccountKey } = keyValueStrings.reduce(\n    (connectionObject, keyValueString: string) => {\n      const [key, ...value] = keyValueString.split(\"=\");\n      (connectionObject as any)[key] = value.join(\"=\");\n      return connectionObject;\n    },\n    {} as ConnectionObject,\n  );\n  if (!AccountEndpoint || !AccountKey) {\n    throw new Error(\"Could not parse the provided connection string\");\n  }\n  return {\n    endpoint: AccountEndpoint,\n    key: AccountKey,\n  };\n}\n\n/**\n * utility function to return copy of object to avoid encryption of original object passed\n * in the CRUD methods.\n * @hidden\n */\n/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-shadow, no-prototype-builtins */\nexport function copyObject(obj: any): any {\n  return JSON.parse(\n    JSON.stringify(obj, (_, value) => {\n      if (typeof value === \"bigint\") {\n        throw new Error(`BigInt type is not supported`);\n      }\n      return value;\n    }),\n  );\n}\n\n/**\n * @hidden\n */\nexport function createDeserializer(typeMarker: TypeMarker): Serializer {\n  switch (typeMarker) {\n    case TypeMarker.Long: {\n      // return instance\n      return new NumberSerializer();\n    }\n    case TypeMarker.Double:\n      return new FloatSerializer();\n    case TypeMarker.String:\n      return new StringSerializer();\n    case TypeMarker.Boolean:\n      return new BooleanSerializer();\n    default:\n      throw new Error(\"Invalid or Unsupported data type passed.\");\n  }\n}\n\n/**\n * @hidden\n * extracts the top-level path\n */\nexport function extractPath(path: string): string {\n  const secondSlashIndex = path.indexOf(\"/\", path.indexOf(\"/\") + 1);\n  return secondSlashIndex === -1 ? path : path.substring(0, secondSlashIndex);\n}\n\nexport function createSerializer(\n  propertyValue: boolean | string | number | Date,\n  type?: TypeMarker,\n): [TypeMarker, Serializer] {\n  if (type) {\n    if (type === TypeMarker.Long) {\n      return [TypeMarker.Long, new NumberSerializer()];\n    } else if (type === TypeMarker.Double) {\n      return [TypeMarker.Double, new FloatSerializer()];\n    } else if (type === TypeMarker.String) {\n      return [TypeMarker.String, new StringSerializer()];\n    } else if (type === TypeMarker.Boolean) {\n      return [TypeMarker.Boolean, new BooleanSerializer()];\n    } else {\n      throw new Error(\"Invalid or Unsupported data type passed.\");\n    }\n  } else {\n    switch (typeof propertyValue) {\n      case \"boolean\":\n        return [TypeMarker.Boolean, new BooleanSerializer()];\n      case \"string\":\n        return [TypeMarker.String, new StringSerializer()];\n      case \"object\":\n        if (propertyValue.constructor === Date) {\n          return [TypeMarker.String, new StringSerializer()];\n        }\n        throw new Error(\"Invalid or Unsupported data type passed.\");\n      case \"number\":\n        if (!Number.isInteger(propertyValue)) {\n          return [TypeMarker.Double, new FloatSerializer()];\n        } else {\n          return [TypeMarker.Long, new NumberSerializer()];\n        }\n      default:\n        throw new Error(\"Invalid or Unsupported data type passed.\");\n    }\n  }\n}\n/**\n * @hidden\n * verifies policy format version, included paths and ensures that id and partition key paths specified in the client encryption policy\n * for encryption are encrypted using Deterministic encryption algorithm.\n */\nexport function validateClientEncryptionPolicy(\n  clientEncryptionPolicy: ClientEncryptionPolicy,\n  partitionKey: PartitionKeyDefinition,\n) {\n  const policyFormatVersion = clientEncryptionPolicy.policyFormatVersion;\n  if (policyFormatVersion < 1 || policyFormatVersion > 2) {\n    throw new ErrorResponse(\"Supported versions of client encryption policy are 1 and 2.\");\n  }\n  const paths = new Set<string>();\n  // checks for duplicate paths and validates the path format and clientEncryptionKeyId\n  for (const includedPath of clientEncryptionPolicy.includedPaths) {\n    if (paths.has(includedPath.path)) {\n      throw new ErrorResponse(\n        `Duplicate path found: ${includedPath.path} in client encryption policy.`,\n      );\n    }\n    if (\n      includedPath.path === undefined ||\n      includedPath.path === null ||\n      includedPath.path === \"\" ||\n      includedPath.path === \"/\"\n    ) {\n      throw new ErrorResponse(\"Path needs to be defined in ClientEncryptionIncludedPath.\");\n    }\n    if (\n      includedPath.clientEncryptionKeyId === undefined ||\n      includedPath.clientEncryptionKeyId === null ||\n      includedPath.clientEncryptionKeyId === \"\" ||\n      typeof includedPath.clientEncryptionKeyId !== \"string\"\n    ) {\n      throw new ErrorResponse(\n        \"ClientEncryptionKeyId needs to be defined as string type in ClientEncryptionIncludedPath.\",\n      );\n    }\n    if (includedPath.path[0] !== \"/\") {\n      throw new ErrorResponse(\"Path in ClientEncryptionIncludedPath must start with '/'.\");\n    }\n    const pathSegments = includedPath.path.split(\"/\").filter((segment) => segment.length > 0);\n    if (pathSegments.length > 1) {\n      throw new ErrorResponse(\"Only top-level paths are currently supported for encryption\");\n    }\n    paths.add(includedPath.path);\n  }\n\n  // checks if id and partition key paths are encrypted using Deterministic encryption algorithm.\n  const encryptedPaths = clientEncryptionPolicy.includedPaths;\n  const partitionKeyPaths = partitionKey.paths.map(extractPath);\n  let isPartitionKeyEncrypted = false;\n  let isIdEncrypted = false;\n  for (const encryptedPath of encryptedPaths) {\n    if (encryptedPath.path === \"/id\") {\n      isIdEncrypted = true;\n      if (encryptedPath.encryptionType !== EncryptionType.DETERMINISTIC) {\n        throw new ErrorResponse(\n          \"The '/id' property must be encrypted using Deterministic encryption.\",\n        );\n      }\n    }\n    if (partitionKeyPaths.includes(encryptedPath.path)) {\n      isPartitionKeyEncrypted = true;\n      if (encryptedPath.encryptionType !== EncryptionType.DETERMINISTIC) {\n        throw new ErrorResponse(\n          `Path: ${encryptedPath.path} which is part of the partition key has to be encrypted with Deterministic type Encryption.`,\n        );\n      }\n    }\n  }\n  // Ensures that the policy format version is 2 if id or partition key paths are encrypted.\n  if (\n    (isPartitionKeyEncrypted || isIdEncrypted) &&\n    clientEncryptionPolicy.policyFormatVersion === 1\n  ) {\n    throw new ErrorResponse(\n      \"Encryption of partition key or id is only supported with policy format version 2.\",\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}