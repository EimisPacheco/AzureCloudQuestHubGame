{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { bearerTokenAuthenticationPolicy, createEmptyPipeline } from \"@azure/core-rest-pipeline\";\nimport { Constants, HTTPMethod, OperationType, ResourceType } from \"./common/constants\";\nimport { getIdFromLink, getPathFromLink, parseLink } from \"./common/helper\";\nimport { StatusCodes, SubStatusCodes } from \"./common/statusCodes\";\nimport { ConsistencyLevel, DatabaseAccount, convertToInternalPartitionKey } from \"./documents\";\nimport { PluginOn, executePlugins } from \"./plugins/Plugin\";\nimport { QueryIterator } from \"./queryIterator\";\nimport { getHeaders } from \"./request/request\";\nimport { RequestHandler } from \"./request/RequestHandler\";\nimport { SessionContainer } from \"./session/sessionContainer\";\nimport { sanitizeEndpoint } from \"./utils/checkURL\";\nimport { supportedQueryFeaturesBuilder } from \"./utils/supportedQueryFeaturesBuilder\";\nimport { createClientLogger } from \"@azure/logger\";\nimport { LogDiagnosticWriter, NoOpDiagnosticWriter } from \"./diagnostics/DiagnosticWriter\";\nimport { DefaultDiagnosticFormatter } from \"./diagnostics/DiagnosticFormatter\";\nimport { CosmosDbDiagnosticLevel } from \"./diagnostics/CosmosDbDiagnosticLevel\";\nimport { randomUUID } from \"@azure/core-util\";\nimport { getUserAgent } from \"./common/platform\";\nconst logger = createClientLogger(\"ClientContext\");\nconst QueryJsonContentType = \"application/query+json\";\nconst HttpHeaders = Constants.HttpHeaders;\n/**\n * @hidden\n * @hidden\n */\nexport class ClientContext {\n  constructor(cosmosClientOptions, globalEndpointManager, clientConfig, diagnosticLevel) {\n    this.cosmosClientOptions = cosmosClientOptions;\n    this.globalEndpointManager = globalEndpointManager;\n    this.clientConfig = clientConfig;\n    this.diagnosticLevel = diagnosticLevel;\n    /** boolean flag to support operations with client-side encryption */\n    this.enableEncryption = false;\n    if (cosmosClientOptions.clientEncryptionOptions) {\n      this.enableEncryption = true;\n    }\n    this.connectionPolicy = cosmosClientOptions.connectionPolicy;\n    this.sessionContainer = new SessionContainer();\n    this.partitionKeyDefinitionCache = {};\n    this.pipeline = null;\n    if (cosmosClientOptions.aadCredentials) {\n      this.pipeline = createEmptyPipeline();\n      const hrefEndpoint = sanitizeEndpoint(cosmosClientOptions.endpoint);\n      const scope = `${hrefEndpoint}/.default`;\n      this.pipeline.addPolicy(bearerTokenAuthenticationPolicy({\n        credential: cosmosClientOptions.aadCredentials,\n        scopes: scope,\n        challengeCallbacks: {\n          async authorizeRequest({\n            request,\n            getAccessToken\n          }) {\n            const tokenResponse = await getAccessToken([scope], {});\n            const AUTH_PREFIX = `type=aad&ver=1.0&sig=`;\n            const authorizationToken = `${AUTH_PREFIX}${tokenResponse.token}`;\n            request.headers.set(\"Authorization\", authorizationToken);\n          }\n        }\n      }));\n    }\n    this.initializeDiagnosticSettings(diagnosticLevel);\n  }\n  /** @hidden */\n  async read({\n    path,\n    resourceType,\n    resourceId,\n    options = {},\n    partitionKey,\n    diagnosticNode\n  }) {\n    try {\n      const request = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), {\n        method: HTTPMethod.get,\n        path,\n        operationType: OperationType.Read,\n        resourceId,\n        options,\n        resourceType,\n        partitionKey\n      });\n      diagnosticNode.addData({\n        operationType: OperationType.Read,\n        resourceType\n      });\n      request.headers = await this.buildHeaders(request);\n      if (resourceType === ResourceType.clientencryptionkey) {\n        request.headers[HttpHeaders.AllowCachedReadsHeader] = true;\n        if (options.databaseRid) {\n          request.headers[HttpHeaders.DatabaseRidHeader] = options.databaseRid;\n        }\n      }\n      this.applySessionToken(request);\n      // read will use ReadEndpoint since it uses GET operation\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(diagnosticNode, request.resourceType, request.operationType);\n      const response = await executePlugins(diagnosticNode, request, RequestHandler.request, PluginOn.operation);\n      this.captureSessionToken(undefined, path, OperationType.Read, response.headers);\n      return response;\n    } catch (err) {\n      this.captureSessionToken(err, path, OperationType.Upsert, err.headers);\n      throw err;\n    }\n  }\n  async queryFeed({\n    path,\n    resourceType,\n    resourceId,\n    resultFn,\n    query,\n    options,\n    diagnosticNode,\n    partitionKeyRangeId,\n    partitionKey,\n    startEpk,\n    endEpk,\n    correlatedActivityId\n  }) {\n    // Query operations will use ReadEndpoint even though it uses\n    // GET(for queryFeed) and POST(for regular query operations)\n    const request = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), {\n      method: HTTPMethod.get,\n      path,\n      operationType: OperationType.Query,\n      partitionKeyRangeId,\n      resourceId,\n      resourceType,\n      options,\n      body: query,\n      partitionKey\n    });\n    diagnosticNode.addData({\n      operationType: OperationType.Query,\n      resourceType\n    });\n    const requestId = randomUUID();\n    if (query !== undefined) {\n      request.method = HTTPMethod.post;\n    }\n    request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(diagnosticNode, request.resourceType, request.operationType);\n    request.headers = await this.buildHeaders(request);\n    if (startEpk !== undefined && endEpk !== undefined) {\n      request.headers[HttpHeaders.StartEpk] = startEpk;\n      request.headers[HttpHeaders.EndEpk] = endEpk;\n      request.headers[HttpHeaders.ReadFeedKeyType] = \"EffectivePartitionKeyRange\";\n    }\n    if (query !== undefined) {\n      if (correlatedActivityId !== undefined) {\n        request.headers[HttpHeaders.CorrelatedActivityId] = correlatedActivityId;\n      }\n      request.headers[HttpHeaders.IsQuery] = \"true\";\n      request.headers[HttpHeaders.ContentType] = QueryJsonContentType;\n      if (typeof query === \"string\") {\n        request.body = {\n          query\n        }; // Converts query text to query object.\n      }\n    }\n    this.applySessionToken(request);\n    logger.info(\"query \" + requestId + \" started\" + (request.partitionKeyRangeId ? \" pkrid: \" + request.partitionKeyRangeId : \"\"));\n    logger.verbose(request);\n    const start = Date.now();\n    const response = await RequestHandler.request(request, diagnosticNode);\n    logger.info(\"query \" + requestId + \" finished - \" + (Date.now() - start) + \"ms\");\n    this.captureSessionToken(undefined, path, OperationType.Query, response.headers);\n    return this.processQueryFeedResponse(response, !!query, resultFn);\n  }\n  async getQueryPlan(path, resourceType, resourceId, query, options = {}, diagnosticNode, correlatedActivityId) {\n    const request = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), {\n      method: HTTPMethod.post,\n      path,\n      operationType: OperationType.Read,\n      resourceId,\n      resourceType,\n      options,\n      body: query\n    });\n    diagnosticNode.addData({\n      operationType: OperationType.Read,\n      resourceType\n    });\n    request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(diagnosticNode, request.resourceType, request.operationType);\n    request.headers = await this.buildHeaders(request);\n    if (correlatedActivityId !== undefined) {\n      request.headers[HttpHeaders.CorrelatedActivityId] = correlatedActivityId;\n    }\n    request.headers[HttpHeaders.IsQueryPlan] = \"True\";\n    request.headers[HttpHeaders.QueryVersion] = \"1.4\";\n    request.headers[HttpHeaders.ContentType] = QueryJsonContentType;\n    request.headers[HttpHeaders.SupportedQueryFeatures] = supportedQueryFeaturesBuilder(options.disableNonStreamingOrderByQuery);\n    if (typeof query === \"string\") {\n      request.body = {\n        query\n      }; // Converts query text to query object.\n    }\n    this.applySessionToken(request);\n    const response = await RequestHandler.request(request, diagnosticNode);\n    this.captureSessionToken(undefined, path, OperationType.Query, response.headers);\n    return response;\n  }\n  queryPartitionKeyRanges(collectionLink, query, options) {\n    const path = getPathFromLink(collectionLink, ResourceType.pkranges);\n    const id = getIdFromLink(collectionLink);\n    const cb = async (diagNode, innerOptions) => {\n      const response = await this.queryFeed({\n        path,\n        resourceType: ResourceType.pkranges,\n        resourceId: id,\n        resultFn: result => result.PartitionKeyRanges,\n        query,\n        options: innerOptions,\n        diagnosticNode: diagNode\n      });\n      return response;\n    };\n    return new QueryIterator(this, query, options, cb);\n  }\n  async delete({\n    path,\n    resourceType,\n    resourceId,\n    options = {},\n    partitionKey,\n    method = HTTPMethod.delete,\n    diagnosticNode\n  }) {\n    try {\n      const request = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), {\n        method: method,\n        operationType: OperationType.Delete,\n        path,\n        resourceType,\n        options,\n        resourceId,\n        partitionKey\n      });\n      diagnosticNode.addData({\n        operationType: OperationType.Delete,\n        resourceType\n      });\n      request.headers = await this.buildHeaders(request);\n      this.applySessionToken(request);\n      // deleteResource will use WriteEndpoint since it uses DELETE operation\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(diagnosticNode, request.resourceType, request.operationType);\n      const response = await executePlugins(diagnosticNode, request, RequestHandler.request, PluginOn.operation);\n      if (parseLink(path).type !== \"colls\") {\n        this.captureSessionToken(undefined, path, OperationType.Delete, response.headers);\n      } else {\n        this.clearSessionToken(path);\n      }\n      return response;\n    } catch (err) {\n      this.captureSessionToken(err, path, OperationType.Upsert, err.headers);\n      throw err;\n    }\n  }\n  async patch({\n    body,\n    path,\n    resourceType,\n    resourceId,\n    options = {},\n    partitionKey,\n    diagnosticNode\n  }) {\n    try {\n      const request = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), {\n        method: HTTPMethod.patch,\n        operationType: OperationType.Patch,\n        path,\n        resourceType,\n        body,\n        resourceId,\n        options,\n        partitionKey\n      });\n      diagnosticNode.addData({\n        operationType: OperationType.Patch,\n        resourceType\n      });\n      request.headers = await this.buildHeaders(request);\n      this.applySessionToken(request);\n      // patch will use WriteEndpoint\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(diagnosticNode, request.resourceType, request.operationType);\n      const response = await executePlugins(diagnosticNode, request, RequestHandler.request, PluginOn.operation);\n      this.captureSessionToken(undefined, path, OperationType.Patch, response.headers);\n      return response;\n    } catch (err) {\n      this.captureSessionToken(err, path, OperationType.Upsert, err.headers);\n      throw err;\n    }\n  }\n  async create({\n    body,\n    path,\n    resourceType,\n    resourceId,\n    diagnosticNode,\n    options = {},\n    partitionKey\n  }) {\n    try {\n      const request = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), {\n        method: HTTPMethod.post,\n        operationType: OperationType.Create,\n        path,\n        resourceType,\n        resourceId,\n        body,\n        options,\n        partitionKey\n      });\n      diagnosticNode.addData({\n        operationType: OperationType.Create,\n        resourceType\n      });\n      request.headers = await this.buildHeaders(request);\n      // create will use WriteEndpoint since it uses POST operation\n      this.applySessionToken(request);\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(diagnosticNode, request.resourceType, request.operationType);\n      const response = await executePlugins(diagnosticNode, request, RequestHandler.request, PluginOn.operation);\n      this.captureSessionToken(undefined, path, OperationType.Create, response.headers);\n      return response;\n    } catch (err) {\n      this.captureSessionToken(err, path, OperationType.Upsert, err.headers);\n      throw err;\n    }\n  }\n  processQueryFeedResponse(res, isQuery, resultFn) {\n    if (isQuery) {\n      return {\n        result: resultFn(res.result),\n        headers: res.headers,\n        code: res.code\n      };\n    } else {\n      const newResult = resultFn(res.result).map(body => body);\n      return {\n        result: newResult,\n        headers: res.headers,\n        code: res.code\n      };\n    }\n  }\n  applySessionToken(requestContext) {\n    const request = this.getSessionParams(requestContext.path);\n    if (requestContext.headers && requestContext.headers[HttpHeaders.SessionToken]) {\n      return;\n    }\n    const sessionConsistency = requestContext.headers[HttpHeaders.ConsistencyLevel];\n    if (!sessionConsistency) {\n      return;\n    }\n    if (sessionConsistency !== ConsistencyLevel.Session) {\n      return;\n    }\n    if (request.resourceAddress) {\n      const sessionToken = this.sessionContainer.get(request);\n      if (sessionToken) {\n        requestContext.headers[HttpHeaders.SessionToken] = sessionToken;\n      }\n    }\n  }\n  async replace({\n    body,\n    path,\n    resourceType,\n    resourceId,\n    options = {},\n    partitionKey,\n    diagnosticNode\n  }) {\n    try {\n      const request = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), {\n        method: HTTPMethod.put,\n        operationType: OperationType.Replace,\n        path,\n        resourceType,\n        body,\n        resourceId,\n        options,\n        partitionKey\n      });\n      diagnosticNode.addData({\n        operationType: OperationType.Replace,\n        resourceType\n      });\n      request.headers = await this.buildHeaders(request);\n      this.applySessionToken(request);\n      // replace will use WriteEndpoint since it uses PUT operation\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(diagnosticNode, request.resourceType, request.operationType);\n      const response = await executePlugins(diagnosticNode, request, RequestHandler.request, PluginOn.operation);\n      this.captureSessionToken(undefined, path, OperationType.Replace, response.headers);\n      return response;\n    } catch (err) {\n      this.captureSessionToken(err, path, OperationType.Upsert, err.headers);\n      throw err;\n    }\n  }\n  async upsert({\n    body,\n    path,\n    resourceType,\n    resourceId,\n    options = {},\n    partitionKey,\n    diagnosticNode\n  }) {\n    try {\n      const request = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), {\n        method: HTTPMethod.post,\n        operationType: OperationType.Upsert,\n        path,\n        resourceType,\n        body,\n        resourceId,\n        options,\n        partitionKey\n      });\n      diagnosticNode.addData({\n        operationType: OperationType.Upsert,\n        resourceType\n      });\n      request.headers = await this.buildHeaders(request);\n      request.headers[HttpHeaders.IsUpsert] = true;\n      this.applySessionToken(request);\n      // upsert will use WriteEndpoint since it uses POST operation\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(diagnosticNode, request.resourceType, request.operationType);\n      const response = await executePlugins(diagnosticNode, request, RequestHandler.request, PluginOn.operation);\n      this.captureSessionToken(undefined, path, OperationType.Upsert, response.headers);\n      return response;\n    } catch (err) {\n      this.captureSessionToken(err, path, OperationType.Upsert, err.headers);\n      throw err;\n    }\n  }\n  async execute({\n    sprocLink,\n    params,\n    options = {},\n    partitionKey,\n    diagnosticNode\n  }) {\n    // Accept a single parameter or an array of parameters.\n    // Didn't add type annotation for this because we should legacy this behavior\n    if (params !== null && params !== undefined && !Array.isArray(params)) {\n      params = [params];\n    }\n    const path = getPathFromLink(sprocLink);\n    const id = getIdFromLink(sprocLink);\n    const request = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), {\n      method: HTTPMethod.post,\n      operationType: OperationType.Execute,\n      path,\n      resourceType: ResourceType.sproc,\n      options,\n      resourceId: id,\n      body: params,\n      partitionKey\n    });\n    diagnosticNode.addData({\n      operationType: OperationType.Execute,\n      resourceType: ResourceType.sproc\n    });\n    request.headers = await this.buildHeaders(request);\n    // executeStoredProcedure will use WriteEndpoint since it uses POST operation\n    request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(diagnosticNode, request.resourceType, request.operationType);\n    const response = await executePlugins(diagnosticNode, request, RequestHandler.request, PluginOn.operation);\n    return response;\n  }\n  /**\n   * Gets the Database account information.\n   * @param options - `urlConnection` in the options is the endpoint url whose database account needs to be retrieved.\n   * If not present, current client's url will be used.\n   */\n  async getDatabaseAccount(diagnosticNode, options = {}) {\n    const endpoint = options.urlConnection || this.cosmosClientOptions.endpoint;\n    const request = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), {\n      endpoint,\n      method: HTTPMethod.get,\n      operationType: OperationType.Read,\n      path: \"\",\n      resourceType: ResourceType.none,\n      options\n    });\n    diagnosticNode.addData({\n      operationType: OperationType.Read,\n      resourceType: ResourceType.none\n    });\n    request.headers = await this.buildHeaders(request);\n    // await options.beforeOperation({ endpoint, request, headers: requestHeaders });\n    const {\n      result,\n      headers,\n      code,\n      substatus,\n      diagnostics\n    } = await executePlugins(diagnosticNode, request, RequestHandler.request, PluginOn.operation);\n    const databaseAccount = new DatabaseAccount(result, headers);\n    return {\n      result: databaseAccount,\n      headers,\n      diagnostics,\n      code: code,\n      substatus: substatus\n    };\n  }\n  getWriteEndpoint(diagnosticNode) {\n    return this.globalEndpointManager.getWriteEndpoint(diagnosticNode);\n  }\n  getReadEndpoint(diagnosticNode) {\n    return this.globalEndpointManager.getReadEndpoint(diagnosticNode);\n  }\n  getWriteEndpoints() {\n    return this.globalEndpointManager.getWriteEndpoints();\n  }\n  getReadEndpoints() {\n    return this.globalEndpointManager.getReadEndpoints();\n  }\n  async batch({\n    body,\n    path,\n    partitionKey,\n    resourceId,\n    options = {},\n    diagnosticNode\n  }) {\n    try {\n      const request = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), {\n        method: HTTPMethod.post,\n        operationType: OperationType.Batch,\n        path,\n        body,\n        resourceType: ResourceType.item,\n        resourceId,\n        options,\n        partitionKey\n      });\n      diagnosticNode.addData({\n        operationType: OperationType.Batch,\n        resourceType: ResourceType.item\n      });\n      request.headers = await this.buildHeaders(request);\n      request.headers[HttpHeaders.IsBatchRequest] = true;\n      request.headers[HttpHeaders.IsBatchAtomic] = true;\n      this.applySessionToken(request);\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(diagnosticNode, request.resourceType, request.operationType);\n      const response = await executePlugins(diagnosticNode, request, RequestHandler.request, PluginOn.operation);\n      this.captureSessionToken(undefined, path, OperationType.Batch, response.headers);\n      response.diagnostics = diagnosticNode.toDiagnostic(this.getClientConfig());\n      return response;\n    } catch (err) {\n      this.captureSessionToken(err, path, OperationType.Upsert, err.headers);\n      throw err;\n    }\n  }\n  async bulk({\n    body,\n    path,\n    partitionKeyRangeId,\n    resourceId,\n    bulkOptions = {},\n    options = {},\n    diagnosticNode\n  }) {\n    var _a;\n    try {\n      const request = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), {\n        method: HTTPMethod.post,\n        operationType: OperationType.Batch,\n        path,\n        body,\n        resourceType: ResourceType.item,\n        resourceId,\n        options\n      });\n      diagnosticNode.addData({\n        operationType: OperationType.Batch,\n        resourceType: ResourceType.item\n      });\n      request.headers = await this.buildHeaders(request);\n      request.headers[HttpHeaders.IsBatchRequest] = true;\n      request.headers[HttpHeaders.PartitionKeyRangeID] = partitionKeyRangeId;\n      request.headers[HttpHeaders.IsBatchAtomic] = false;\n      request.headers[HttpHeaders.BatchContinueOnError] = (_a = bulkOptions.continueOnError) !== null && _a !== void 0 ? _a : true;\n      this.applySessionToken(request);\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(diagnosticNode, request.resourceType, request.operationType);\n      const response = await executePlugins(diagnosticNode, request, RequestHandler.request, PluginOn.operation);\n      this.captureSessionToken(undefined, path, OperationType.Batch, response.headers);\n      return response;\n    } catch (err) {\n      this.captureSessionToken(err, path, OperationType.Upsert, err.headers);\n      throw err;\n    }\n  }\n  captureSessionToken(err, path, operationType, resHeaders) {\n    const request = this.getSessionParams(path);\n    request.operationType = operationType;\n    if (!err || !this.isMasterResource(request.resourceType) && (err.code === StatusCodes.PreconditionFailed || err.code === StatusCodes.Conflict || err.code === StatusCodes.NotFound && err.substatus !== SubStatusCodes.ReadSessionNotAvailable)) {\n      this.sessionContainer.set(request, resHeaders);\n    }\n  }\n  clearSessionToken(path) {\n    const request = this.getSessionParams(path);\n    this.sessionContainer.remove(request);\n  }\n  recordDiagnostics(diagnostic) {\n    const formatted = this.diagnosticFormatter.format(diagnostic);\n    this.diagnosticWriter.write(formatted);\n  }\n  initializeDiagnosticSettings(diagnosticLevel) {\n    this.diagnosticFormatter = new DefaultDiagnosticFormatter();\n    switch (diagnosticLevel) {\n      case CosmosDbDiagnosticLevel.info:\n        this.diagnosticWriter = new NoOpDiagnosticWriter();\n        break;\n      default:\n        this.diagnosticWriter = new LogDiagnosticWriter();\n    }\n  }\n  // TODO: move\n  getSessionParams(resourceLink) {\n    const resourceId = null;\n    let resourceAddress = null;\n    const parserOutput = parseLink(resourceLink);\n    resourceAddress = parserOutput.objectBody.self;\n    const resourceType = parserOutput.type;\n    return {\n      resourceId,\n      resourceAddress,\n      resourceType,\n      isNameBased: true\n    };\n  }\n  isMasterResource(resourceType) {\n    if (resourceType === Constants.Path.OffersPathSegment || resourceType === Constants.Path.DatabasesPathSegment || resourceType === Constants.Path.UsersPathSegment || resourceType === Constants.Path.PermissionsPathSegment || resourceType === Constants.Path.TopologyPathSegment || resourceType === Constants.Path.DatabaseAccountPathSegment || resourceType === Constants.Path.PartitionKeyRangesPathSegment || resourceType === Constants.Path.CollectionsPathSegment) {\n      return true;\n    }\n    return false;\n  }\n  buildHeaders(requestContext) {\n    return getHeaders({\n      clientOptions: this.cosmosClientOptions,\n      defaultHeaders: Object.assign(Object.assign({}, this.cosmosClientOptions.defaultHeaders), requestContext.options.initialHeaders),\n      verb: requestContext.method,\n      path: requestContext.path,\n      resourceId: requestContext.resourceId,\n      resourceType: requestContext.resourceType,\n      options: requestContext.options,\n      partitionKeyRangeId: requestContext.partitionKeyRangeId,\n      useMultipleWriteLocations: this.connectionPolicy.useMultipleWriteLocations,\n      partitionKey: requestContext.partitionKey !== undefined ? convertToInternalPartitionKey(requestContext.partitionKey) : undefined // TODO: Move this check from here to PartitionKey\n    });\n  }\n  /**\n   * Returns collection of properties which are derived from the context for Request Creation.\n   * These properties have client wide scope, as opposed to request specific scope.\n   * @returns\n   */\n  getContextDerivedPropsForRequestCreation() {\n    return {\n      globalEndpointManager: this.globalEndpointManager,\n      requestAgent: this.cosmosClientOptions.agent,\n      connectionPolicy: this.connectionPolicy,\n      client: this,\n      plugins: this.cosmosClientOptions.plugins,\n      pipeline: this.pipeline,\n      httpClient: this.cosmosClientOptions.httpClient\n    };\n  }\n  getClientConfig() {\n    return this.clientConfig;\n  }\n  /**\n   * @internal\n   */\n  refreshUserAgent(hostFramework) {\n    const updatedUserAgent = getUserAgent(this.cosmosClientOptions.userAgentSuffix, hostFramework);\n    this.cosmosClientOptions.defaultHeaders[Constants.HttpHeaders.UserAgent] = updatedUserAgent;\n    this.cosmosClientOptions.defaultHeaders[Constants.HttpHeaders.CustomUserAgent] = updatedUserAgent;\n  }\n}","map":{"version":3,"names":["bearerTokenAuthenticationPolicy","createEmptyPipeline","Constants","HTTPMethod","OperationType","ResourceType","getIdFromLink","getPathFromLink","parseLink","StatusCodes","SubStatusCodes","ConsistencyLevel","DatabaseAccount","convertToInternalPartitionKey","PluginOn","executePlugins","QueryIterator","getHeaders","RequestHandler","SessionContainer","sanitizeEndpoint","supportedQueryFeaturesBuilder","createClientLogger","LogDiagnosticWriter","NoOpDiagnosticWriter","DefaultDiagnosticFormatter","CosmosDbDiagnosticLevel","randomUUID","getUserAgent","logger","QueryJsonContentType","HttpHeaders","ClientContext","constructor","cosmosClientOptions","globalEndpointManager","clientConfig","diagnosticLevel","enableEncryption","clientEncryptionOptions","connectionPolicy","sessionContainer","partitionKeyDefinitionCache","pipeline","aadCredentials","hrefEndpoint","endpoint","scope","addPolicy","credential","scopes","challengeCallbacks","authorizeRequest","request","getAccessToken","tokenResponse","AUTH_PREFIX","authorizationToken","token","headers","set","initializeDiagnosticSettings","read","path","resourceType","resourceId","options","partitionKey","diagnosticNode","Object","assign","getContextDerivedPropsForRequestCreation","method","get","operationType","Read","addData","buildHeaders","clientencryptionkey","AllowCachedReadsHeader","databaseRid","DatabaseRidHeader","applySessionToken","resolveServiceEndpoint","response","operation","captureSessionToken","undefined","err","Upsert","queryFeed","resultFn","query","partitionKeyRangeId","startEpk","endEpk","correlatedActivityId","Query","body","requestId","post","StartEpk","EndEpk","ReadFeedKeyType","CorrelatedActivityId","IsQuery","ContentType","info","verbose","start","Date","now","processQueryFeedResponse","getQueryPlan","IsQueryPlan","QueryVersion","SupportedQueryFeatures","disableNonStreamingOrderByQuery","queryPartitionKeyRanges","collectionLink","pkranges","id","cb","diagNode","innerOptions","result","PartitionKeyRanges","delete","Delete","type","clearSessionToken","patch","Patch","create","Create","res","isQuery","code","newResult","map","requestContext","getSessionParams","SessionToken","sessionConsistency","Session","resourceAddress","sessionToken","replace","put","Replace","upsert","IsUpsert","execute","sprocLink","params","Array","isArray","Execute","sproc","getDatabaseAccount","urlConnection","none","substatus","diagnostics","databaseAccount","getWriteEndpoint","getReadEndpoint","getWriteEndpoints","getReadEndpoints","batch","Batch","item","IsBatchRequest","IsBatchAtomic","toDiagnostic","getClientConfig","bulk","bulkOptions","PartitionKeyRangeID","BatchContinueOnError","_a","continueOnError","resHeaders","isMasterResource","PreconditionFailed","Conflict","NotFound","ReadSessionNotAvailable","remove","recordDiagnostics","diagnostic","formatted","diagnosticFormatter","format","diagnosticWriter","write","resourceLink","parserOutput","objectBody","self","isNameBased","Path","OffersPathSegment","DatabasesPathSegment","UsersPathSegment","PermissionsPathSegment","TopologyPathSegment","DatabaseAccountPathSegment","PartitionKeyRangesPathSegment","CollectionsPathSegment","clientOptions","defaultHeaders","initialHeaders","verb","useMultipleWriteLocations","requestAgent","agent","client","plugins","httpClient","refreshUserAgent","hostFramework","updatedUserAgent","userAgentSuffix","UserAgent","CustomUserAgent"],"sources":["/Users/eimis/test-server/Azure Hackthons/azure-cloud-architecture-game /node_modules/@azure/cosmos/src/ClientContext.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { HttpClient, Pipeline } from \"@azure/core-rest-pipeline\";\nimport { bearerTokenAuthenticationPolicy, createEmptyPipeline } from \"@azure/core-rest-pipeline\";\nimport type { PartitionKeyRange } from \"./client/Container/PartitionKeyRange\";\nimport type { Resource } from \"./client/Resource\";\nimport { Constants, HTTPMethod, OperationType, ResourceType } from \"./common/constants\";\nimport { getIdFromLink, getPathFromLink, parseLink } from \"./common/helper\";\nimport { StatusCodes, SubStatusCodes } from \"./common/statusCodes\";\nimport type { Agent, CosmosClientOptions } from \"./CosmosClientOptions\";\nimport type { ConnectionPolicy, PartitionKey } from \"./documents\";\nimport { ConsistencyLevel, DatabaseAccount, convertToInternalPartitionKey } from \"./documents\";\nimport type { GlobalEndpointManager } from \"./globalEndpointManager\";\nimport type { PluginConfig } from \"./plugins/Plugin\";\nimport { PluginOn, executePlugins } from \"./plugins/Plugin\";\nimport type { FetchFunctionCallback, SqlQuerySpec } from \"./queryExecutionContext\";\nimport type { CosmosHeaders } from \"./queryExecutionContext/CosmosHeaders\";\nimport { QueryIterator } from \"./queryIterator\";\nimport type { ErrorResponse } from \"./request\";\nimport type { FeedOptions, RequestOptions, Response } from \"./request\";\nimport type { PartitionedQueryExecutionInfo } from \"./request/ErrorResponse\";\nimport { getHeaders } from \"./request/request\";\nimport type { RequestContext } from \"./request/RequestContext\";\nimport { RequestHandler } from \"./request/RequestHandler\";\nimport { SessionContainer } from \"./session/sessionContainer\";\nimport type { SessionContext } from \"./session/SessionContext\";\nimport type { BulkOptions } from \"./utils/batch\";\nimport { sanitizeEndpoint } from \"./utils/checkURL\";\nimport { supportedQueryFeaturesBuilder } from \"./utils/supportedQueryFeaturesBuilder\";\nimport type { AzureLogger } from \"@azure/logger\";\nimport { createClientLogger } from \"@azure/logger\";\nimport type { ClientConfigDiagnostic, CosmosDiagnostics } from \"./CosmosDiagnostics\";\nimport type { DiagnosticNodeInternal } from \"./diagnostics/DiagnosticNodeInternal\";\nimport type { DiagnosticWriter } from \"./diagnostics/DiagnosticWriter\";\nimport { LogDiagnosticWriter, NoOpDiagnosticWriter } from \"./diagnostics/DiagnosticWriter\";\nimport type { DiagnosticFormatter } from \"./diagnostics/DiagnosticFormatter\";\nimport { DefaultDiagnosticFormatter } from \"./diagnostics/DiagnosticFormatter\";\nimport { CosmosDbDiagnosticLevel } from \"./diagnostics/CosmosDbDiagnosticLevel\";\nimport { randomUUID } from \"@azure/core-util\";\nimport { getUserAgent } from \"./common/platform\";\nconst logger: AzureLogger = createClientLogger(\"ClientContext\");\n\nconst QueryJsonContentType = \"application/query+json\";\nconst HttpHeaders = Constants.HttpHeaders;\n/**\n * @hidden\n * @hidden\n */\nexport class ClientContext {\n  private readonly sessionContainer: SessionContainer;\n  private connectionPolicy: ConnectionPolicy;\n  private pipeline: Pipeline;\n  private diagnosticWriter: DiagnosticWriter;\n  private diagnosticFormatter: DiagnosticFormatter;\n  public partitionKeyDefinitionCache: { [containerUrl: string]: any }; // TODO: PartitionKeyDefinitionCache\n  /** boolean flag to support operations with client-side encryption */\n  public enableEncryption: boolean = false;\n\n  public constructor(\n    private cosmosClientOptions: CosmosClientOptions,\n    private globalEndpointManager: GlobalEndpointManager,\n    private clientConfig: ClientConfigDiagnostic,\n    public diagnosticLevel: CosmosDbDiagnosticLevel,\n  ) {\n    if (cosmosClientOptions.clientEncryptionOptions) {\n      this.enableEncryption = true;\n    }\n    this.connectionPolicy = cosmosClientOptions.connectionPolicy;\n    this.sessionContainer = new SessionContainer();\n    this.partitionKeyDefinitionCache = {};\n    this.pipeline = null;\n    if (cosmosClientOptions.aadCredentials) {\n      this.pipeline = createEmptyPipeline();\n      const hrefEndpoint = sanitizeEndpoint(cosmosClientOptions.endpoint);\n      const scope = `${hrefEndpoint}/.default`;\n      this.pipeline.addPolicy(\n        bearerTokenAuthenticationPolicy({\n          credential: cosmosClientOptions.aadCredentials,\n          scopes: scope,\n          challengeCallbacks: {\n            async authorizeRequest({ request, getAccessToken }) {\n              const tokenResponse = await getAccessToken([scope], {});\n              const AUTH_PREFIX = `type=aad&ver=1.0&sig=`;\n              const authorizationToken = `${AUTH_PREFIX}${tokenResponse.token}`;\n              request.headers.set(\"Authorization\", authorizationToken);\n            },\n          },\n        }),\n      );\n    }\n    this.initializeDiagnosticSettings(diagnosticLevel);\n  }\n  /** @hidden */\n  public async read<T>({\n    path,\n    resourceType,\n    resourceId,\n    options = {},\n    partitionKey,\n    diagnosticNode,\n  }: {\n    path: string;\n    resourceType: ResourceType;\n    resourceId: string;\n    options?: RequestOptions;\n    partitionKey?: PartitionKey;\n    diagnosticNode: DiagnosticNodeInternal;\n  }): Promise<Response<T & Resource>> {\n    try {\n      const request: RequestContext = {\n        ...this.getContextDerivedPropsForRequestCreation(),\n        method: HTTPMethod.get,\n        path,\n        operationType: OperationType.Read,\n        resourceId,\n        options,\n        resourceType,\n        partitionKey,\n      };\n      diagnosticNode.addData({\n        operationType: OperationType.Read,\n        resourceType,\n      });\n\n      request.headers = await this.buildHeaders(request);\n      if (resourceType === ResourceType.clientencryptionkey) {\n        request.headers[HttpHeaders.AllowCachedReadsHeader] = true;\n        if (options.databaseRid) {\n          request.headers[HttpHeaders.DatabaseRidHeader] = options.databaseRid;\n        }\n      }\n      this.applySessionToken(request);\n\n      // read will use ReadEndpoint since it uses GET operation\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(\n        diagnosticNode,\n        request.resourceType,\n        request.operationType,\n      );\n      const response = await executePlugins(\n        diagnosticNode,\n        request,\n        RequestHandler.request,\n        PluginOn.operation,\n      );\n      this.captureSessionToken(undefined, path, OperationType.Read, response.headers);\n      return response;\n    } catch (err: any) {\n      this.captureSessionToken(err, path, OperationType.Upsert, (err as ErrorResponse).headers);\n      throw err;\n    }\n  }\n\n  public async queryFeed<T>({\n    path,\n    resourceType,\n    resourceId,\n    resultFn,\n    query,\n    options,\n    diagnosticNode,\n    partitionKeyRangeId,\n    partitionKey,\n    startEpk,\n    endEpk,\n    correlatedActivityId,\n  }: {\n    path: string;\n    resourceType: ResourceType;\n    resourceId: string;\n    resultFn: (result: { [key: string]: any }) => any[];\n    query: SqlQuerySpec | string;\n    options: FeedOptions;\n    diagnosticNode: DiagnosticNodeInternal;\n    partitionKeyRangeId?: string;\n    partitionKey?: PartitionKey;\n    startEpk?: string | undefined;\n    endEpk?: string | undefined;\n    correlatedActivityId?: string;\n  }): Promise<Response<T & Resource>> {\n    // Query operations will use ReadEndpoint even though it uses\n    // GET(for queryFeed) and POST(for regular query operations)\n\n    const request: RequestContext = {\n      ...this.getContextDerivedPropsForRequestCreation(),\n      method: HTTPMethod.get,\n      path,\n      operationType: OperationType.Query,\n      partitionKeyRangeId,\n      resourceId,\n      resourceType,\n      options,\n      body: query,\n      partitionKey,\n    };\n    diagnosticNode.addData({\n      operationType: OperationType.Query,\n      resourceType,\n    });\n    const requestId = randomUUID();\n    if (query !== undefined) {\n      request.method = HTTPMethod.post;\n    }\n    request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(\n      diagnosticNode,\n      request.resourceType,\n      request.operationType,\n    );\n    request.headers = await this.buildHeaders(request);\n\n    if (startEpk !== undefined && endEpk !== undefined) {\n      request.headers[HttpHeaders.StartEpk] = startEpk;\n      request.headers[HttpHeaders.EndEpk] = endEpk;\n      request.headers[HttpHeaders.ReadFeedKeyType] = \"EffectivePartitionKeyRange\";\n    }\n\n    if (query !== undefined) {\n      if (correlatedActivityId !== undefined) {\n        request.headers[HttpHeaders.CorrelatedActivityId] = correlatedActivityId;\n      }\n      request.headers[HttpHeaders.IsQuery] = \"true\";\n      request.headers[HttpHeaders.ContentType] = QueryJsonContentType;\n      if (typeof query === \"string\") {\n        request.body = { query }; // Converts query text to query object.\n      }\n    }\n    this.applySessionToken(request);\n    logger.info(\n      \"query \" +\n        requestId +\n        \" started\" +\n        (request.partitionKeyRangeId ? \" pkrid: \" + request.partitionKeyRangeId : \"\"),\n    );\n    logger.verbose(request);\n    const start = Date.now();\n    const response = await RequestHandler.request(request, diagnosticNode);\n    logger.info(\"query \" + requestId + \" finished - \" + (Date.now() - start) + \"ms\");\n    this.captureSessionToken(undefined, path, OperationType.Query, response.headers);\n    return this.processQueryFeedResponse(response, !!query, resultFn);\n  }\n\n  public async getQueryPlan(\n    path: string,\n    resourceType: ResourceType,\n    resourceId: string,\n    query: SqlQuerySpec | string,\n    options: FeedOptions = {},\n    diagnosticNode: DiagnosticNodeInternal,\n    correlatedActivityId?: string,\n  ): Promise<Response<PartitionedQueryExecutionInfo>> {\n    const request: RequestContext = {\n      ...this.getContextDerivedPropsForRequestCreation(),\n      method: HTTPMethod.post,\n      path,\n      operationType: OperationType.Read,\n      resourceId,\n      resourceType,\n      options,\n      body: query,\n    };\n    diagnosticNode.addData({\n      operationType: OperationType.Read,\n      resourceType,\n    });\n    request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(\n      diagnosticNode,\n      request.resourceType,\n      request.operationType,\n    );\n    request.headers = await this.buildHeaders(request);\n    if (correlatedActivityId !== undefined) {\n      request.headers[HttpHeaders.CorrelatedActivityId] = correlatedActivityId;\n    }\n    request.headers[HttpHeaders.IsQueryPlan] = \"True\";\n    request.headers[HttpHeaders.QueryVersion] = \"1.4\";\n    request.headers[HttpHeaders.ContentType] = QueryJsonContentType;\n    request.headers[HttpHeaders.SupportedQueryFeatures] = supportedQueryFeaturesBuilder(\n      options.disableNonStreamingOrderByQuery,\n    );\n\n    if (typeof query === \"string\") {\n      request.body = { query }; // Converts query text to query object.\n    }\n\n    this.applySessionToken(request);\n    const response = await RequestHandler.request(request, diagnosticNode);\n    this.captureSessionToken(undefined, path, OperationType.Query, response.headers);\n    return response as any;\n  }\n\n  public queryPartitionKeyRanges(\n    collectionLink: string,\n    query?: string | SqlQuerySpec,\n    options?: FeedOptions,\n  ): QueryIterator<PartitionKeyRange> {\n    const path = getPathFromLink(collectionLink, ResourceType.pkranges);\n    const id = getIdFromLink(collectionLink);\n    const cb: FetchFunctionCallback = async (diagNode, innerOptions) => {\n      const response = await this.queryFeed({\n        path,\n        resourceType: ResourceType.pkranges,\n        resourceId: id,\n        resultFn: (result) => result.PartitionKeyRanges,\n        query,\n        options: innerOptions,\n        diagnosticNode: diagNode,\n      });\n      return response;\n    };\n    return new QueryIterator<PartitionKeyRange>(this, query, options, cb);\n  }\n\n  public async delete<T>({\n    path,\n    resourceType,\n    resourceId,\n    options = {},\n    partitionKey,\n    method = HTTPMethod.delete,\n    diagnosticNode,\n  }: {\n    path: string;\n    resourceType: ResourceType;\n    resourceId: string;\n    options?: RequestOptions;\n    partitionKey?: PartitionKey;\n    method?: HTTPMethod;\n    diagnosticNode: DiagnosticNodeInternal;\n  }): Promise<Response<T & Resource>> {\n    try {\n      const request: RequestContext = {\n        ...this.getContextDerivedPropsForRequestCreation(),\n        method: method,\n        operationType: OperationType.Delete,\n        path,\n        resourceType,\n        options,\n        resourceId,\n        partitionKey,\n      };\n      diagnosticNode.addData({\n        operationType: OperationType.Delete,\n        resourceType,\n      });\n      request.headers = await this.buildHeaders(request);\n      this.applySessionToken(request);\n      // deleteResource will use WriteEndpoint since it uses DELETE operation\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(\n        diagnosticNode,\n        request.resourceType,\n        request.operationType,\n      );\n      const response = await executePlugins(\n        diagnosticNode,\n        request,\n        RequestHandler.request,\n        PluginOn.operation,\n      );\n      if (parseLink(path).type !== \"colls\") {\n        this.captureSessionToken(undefined, path, OperationType.Delete, response.headers);\n      } else {\n        this.clearSessionToken(path);\n      }\n      return response;\n    } catch (err: any) {\n      this.captureSessionToken(err, path, OperationType.Upsert, (err as ErrorResponse).headers);\n      throw err;\n    }\n  }\n\n  public async patch<T>({\n    body,\n    path,\n    resourceType,\n    resourceId,\n    options = {},\n    partitionKey,\n    diagnosticNode,\n  }: {\n    body: any;\n    path: string;\n    resourceType: ResourceType;\n    resourceId: string;\n    options?: RequestOptions;\n    partitionKey?: PartitionKey;\n    diagnosticNode: DiagnosticNodeInternal;\n  }): Promise<Response<T & Resource>> {\n    try {\n      const request: RequestContext = {\n        ...this.getContextDerivedPropsForRequestCreation(),\n        method: HTTPMethod.patch,\n        operationType: OperationType.Patch,\n        path,\n        resourceType,\n        body,\n        resourceId,\n        options,\n        partitionKey,\n      };\n      diagnosticNode.addData({\n        operationType: OperationType.Patch,\n        resourceType,\n      });\n      request.headers = await this.buildHeaders(request);\n      this.applySessionToken(request);\n\n      // patch will use WriteEndpoint\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(\n        diagnosticNode,\n        request.resourceType,\n        request.operationType,\n      );\n      const response = await executePlugins(\n        diagnosticNode,\n        request,\n        RequestHandler.request,\n        PluginOn.operation,\n      );\n      this.captureSessionToken(undefined, path, OperationType.Patch, response.headers);\n      return response;\n    } catch (err: any) {\n      this.captureSessionToken(err, path, OperationType.Upsert, (err as ErrorResponse).headers);\n      throw err;\n    }\n  }\n\n  public async create<T, U = T>({\n    body,\n    path,\n    resourceType,\n    resourceId,\n    diagnosticNode,\n    options = {},\n    partitionKey,\n  }: {\n    body: T;\n    path: string;\n    resourceType: ResourceType;\n    resourceId: string;\n    diagnosticNode: DiagnosticNodeInternal;\n    options?: RequestOptions;\n    partitionKey?: PartitionKey;\n  }): Promise<Response<T & U & Resource>> {\n    try {\n      const request: RequestContext = {\n        ...this.getContextDerivedPropsForRequestCreation(),\n        method: HTTPMethod.post,\n        operationType: OperationType.Create,\n        path,\n        resourceType,\n        resourceId,\n        body,\n        options,\n        partitionKey,\n      };\n      diagnosticNode.addData({\n        operationType: OperationType.Create,\n        resourceType,\n      });\n      request.headers = await this.buildHeaders(request);\n      // create will use WriteEndpoint since it uses POST operation\n      this.applySessionToken(request);\n\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(\n        diagnosticNode,\n        request.resourceType,\n        request.operationType,\n      );\n      const response = await executePlugins(\n        diagnosticNode,\n        request,\n        RequestHandler.request,\n        PluginOn.operation,\n      );\n      this.captureSessionToken(undefined, path, OperationType.Create, response.headers);\n      return response;\n    } catch (err: any) {\n      this.captureSessionToken(err, path, OperationType.Upsert, (err as ErrorResponse).headers);\n      throw err;\n    }\n  }\n\n  private processQueryFeedResponse(\n    res: Response<any>,\n    isQuery: boolean,\n    resultFn: (result: { [key: string]: any }) => any[],\n  ): Response<any> {\n    if (isQuery) {\n      return {\n        result: resultFn(res.result),\n        headers: res.headers,\n        code: res.code,\n      };\n    } else {\n      const newResult = resultFn(res.result).map((body: any) => body);\n      return {\n        result: newResult,\n        headers: res.headers,\n        code: res.code,\n      };\n    }\n  }\n\n  private applySessionToken(requestContext: RequestContext): void {\n    const request = this.getSessionParams(requestContext.path);\n\n    if (requestContext.headers && requestContext.headers[HttpHeaders.SessionToken]) {\n      return;\n    }\n\n    const sessionConsistency: ConsistencyLevel = requestContext.headers[\n      HttpHeaders.ConsistencyLevel\n    ] as ConsistencyLevel;\n    if (!sessionConsistency) {\n      return;\n    }\n\n    if (sessionConsistency !== ConsistencyLevel.Session) {\n      return;\n    }\n\n    if (request.resourceAddress) {\n      const sessionToken = this.sessionContainer.get(request);\n      if (sessionToken) {\n        requestContext.headers[HttpHeaders.SessionToken] = sessionToken;\n      }\n    }\n  }\n\n  public async replace<T>({\n    body,\n    path,\n    resourceType,\n    resourceId,\n    options = {},\n    partitionKey,\n    diagnosticNode,\n  }: {\n    body: any;\n    path: string;\n    resourceType: ResourceType;\n    resourceId: string;\n    options?: RequestOptions;\n    partitionKey?: PartitionKey;\n    diagnosticNode: DiagnosticNodeInternal;\n  }): Promise<Response<T & Resource>> {\n    try {\n      const request: RequestContext = {\n        ...this.getContextDerivedPropsForRequestCreation(),\n        method: HTTPMethod.put,\n        operationType: OperationType.Replace,\n        path,\n        resourceType,\n        body,\n        resourceId,\n        options,\n        partitionKey,\n      };\n      diagnosticNode.addData({\n        operationType: OperationType.Replace,\n        resourceType,\n      });\n      request.headers = await this.buildHeaders(request);\n      this.applySessionToken(request);\n\n      // replace will use WriteEndpoint since it uses PUT operation\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(\n        diagnosticNode,\n        request.resourceType,\n        request.operationType,\n      );\n      const response = await executePlugins(\n        diagnosticNode,\n        request,\n        RequestHandler.request,\n        PluginOn.operation,\n      );\n      this.captureSessionToken(undefined, path, OperationType.Replace, response.headers);\n      return response;\n    } catch (err: any) {\n      this.captureSessionToken(err, path, OperationType.Upsert, (err as ErrorResponse).headers);\n      throw err;\n    }\n  }\n\n  public async upsert<T, U = T>({\n    body,\n    path,\n    resourceType,\n    resourceId,\n    options = {},\n    partitionKey,\n    diagnosticNode,\n  }: {\n    body: T;\n    path: string;\n    resourceType: ResourceType;\n    resourceId: string;\n    options?: RequestOptions;\n    partitionKey?: PartitionKey;\n    diagnosticNode: DiagnosticNodeInternal;\n  }): Promise<Response<T & U & Resource>> {\n    try {\n      const request: RequestContext = {\n        ...this.getContextDerivedPropsForRequestCreation(),\n        method: HTTPMethod.post,\n        operationType: OperationType.Upsert,\n        path,\n        resourceType,\n        body,\n        resourceId,\n        options,\n        partitionKey,\n      };\n      diagnosticNode.addData({\n        operationType: OperationType.Upsert,\n        resourceType,\n      });\n      request.headers = await this.buildHeaders(request);\n      request.headers[HttpHeaders.IsUpsert] = true;\n      this.applySessionToken(request);\n\n      // upsert will use WriteEndpoint since it uses POST operation\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(\n        diagnosticNode,\n        request.resourceType,\n        request.operationType,\n      );\n      const response = await executePlugins(\n        diagnosticNode,\n        request,\n        RequestHandler.request,\n        PluginOn.operation,\n      );\n      this.captureSessionToken(undefined, path, OperationType.Upsert, response.headers);\n      return response;\n    } catch (err: any) {\n      this.captureSessionToken(err, path, OperationType.Upsert, (err as ErrorResponse).headers);\n      throw err;\n    }\n  }\n\n  public async execute<T>({\n    sprocLink,\n    params,\n    options = {},\n    partitionKey,\n    diagnosticNode,\n  }: {\n    sprocLink: string;\n    params?: any[];\n    options?: RequestOptions;\n    partitionKey?: PartitionKey;\n    diagnosticNode: DiagnosticNodeInternal;\n  }): Promise<Response<T>> {\n    // Accept a single parameter or an array of parameters.\n    // Didn't add type annotation for this because we should legacy this behavior\n    if (params !== null && params !== undefined && !Array.isArray(params)) {\n      params = [params];\n    }\n    const path = getPathFromLink(sprocLink);\n    const id = getIdFromLink(sprocLink);\n\n    const request: RequestContext = {\n      ...this.getContextDerivedPropsForRequestCreation(),\n      method: HTTPMethod.post,\n      operationType: OperationType.Execute,\n      path,\n      resourceType: ResourceType.sproc,\n      options,\n      resourceId: id,\n      body: params,\n      partitionKey,\n    };\n    diagnosticNode.addData({\n      operationType: OperationType.Execute,\n      resourceType: ResourceType.sproc,\n    });\n    request.headers = await this.buildHeaders(request);\n    // executeStoredProcedure will use WriteEndpoint since it uses POST operation\n    request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(\n      diagnosticNode,\n      request.resourceType,\n      request.operationType,\n    );\n    const response = await executePlugins(\n      diagnosticNode,\n      request,\n      RequestHandler.request,\n      PluginOn.operation,\n    );\n    return response;\n  }\n\n  /**\n   * Gets the Database account information.\n   * @param options - `urlConnection` in the options is the endpoint url whose database account needs to be retrieved.\n   * If not present, current client's url will be used.\n   */\n  public async getDatabaseAccount(\n    diagnosticNode: DiagnosticNodeInternal,\n    options: RequestOptions = {},\n  ): Promise<Response<DatabaseAccount>> {\n    const endpoint = options.urlConnection || this.cosmosClientOptions.endpoint;\n    const request: RequestContext = {\n      ...this.getContextDerivedPropsForRequestCreation(),\n      endpoint,\n      method: HTTPMethod.get,\n      operationType: OperationType.Read,\n      path: \"\",\n      resourceType: ResourceType.none,\n      options,\n    };\n    diagnosticNode.addData({\n      operationType: OperationType.Read,\n      resourceType: ResourceType.none,\n    });\n    request.headers = await this.buildHeaders(request);\n    // await options.beforeOperation({ endpoint, request, headers: requestHeaders });\n    const { result, headers, code, substatus, diagnostics } = await executePlugins(\n      diagnosticNode,\n      request,\n      RequestHandler.request,\n      PluginOn.operation,\n    );\n\n    const databaseAccount = new DatabaseAccount(result, headers);\n    return {\n      result: databaseAccount,\n      headers,\n      diagnostics,\n      code: code,\n      substatus: substatus,\n    };\n  }\n\n  public getWriteEndpoint(diagnosticNode: DiagnosticNodeInternal): Promise<string> {\n    return this.globalEndpointManager.getWriteEndpoint(diagnosticNode);\n  }\n\n  public getReadEndpoint(diagnosticNode: DiagnosticNodeInternal): Promise<string> {\n    return this.globalEndpointManager.getReadEndpoint(diagnosticNode);\n  }\n\n  public getWriteEndpoints(): Promise<readonly string[]> {\n    return this.globalEndpointManager.getWriteEndpoints();\n  }\n\n  public getReadEndpoints(): Promise<readonly string[]> {\n    return this.globalEndpointManager.getReadEndpoints();\n  }\n\n  public async batch<T>({\n    body,\n    path,\n    partitionKey,\n    resourceId,\n    options = {},\n    diagnosticNode,\n  }: {\n    body: T;\n    path: string;\n    partitionKey: PartitionKey;\n    resourceId: string;\n    options?: RequestOptions;\n    diagnosticNode: DiagnosticNodeInternal;\n  }): Promise<Response<any>> {\n    try {\n      const request: RequestContext = {\n        ...this.getContextDerivedPropsForRequestCreation(),\n        method: HTTPMethod.post,\n        operationType: OperationType.Batch,\n        path,\n        body,\n        resourceType: ResourceType.item,\n        resourceId,\n        options,\n        partitionKey,\n      };\n      diagnosticNode.addData({\n        operationType: OperationType.Batch,\n        resourceType: ResourceType.item,\n      });\n      request.headers = await this.buildHeaders(request);\n      request.headers[HttpHeaders.IsBatchRequest] = true;\n      request.headers[HttpHeaders.IsBatchAtomic] = true;\n\n      this.applySessionToken(request);\n\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(\n        diagnosticNode,\n        request.resourceType,\n        request.operationType,\n      );\n      const response = await executePlugins(\n        diagnosticNode,\n        request,\n        RequestHandler.request,\n        PluginOn.operation,\n      );\n      this.captureSessionToken(undefined, path, OperationType.Batch, response.headers);\n      response.diagnostics = diagnosticNode.toDiagnostic(this.getClientConfig());\n      return response;\n    } catch (err: any) {\n      this.captureSessionToken(err, path, OperationType.Upsert, (err as ErrorResponse).headers);\n      throw err;\n    }\n  }\n\n  public async bulk<T>({\n    body,\n    path,\n    partitionKeyRangeId,\n    resourceId,\n    bulkOptions = {},\n    options = {},\n    diagnosticNode,\n  }: {\n    body: T;\n    path: string;\n    partitionKeyRangeId: string;\n    resourceId: string;\n    bulkOptions?: BulkOptions;\n    options?: RequestOptions;\n    diagnosticNode: DiagnosticNodeInternal;\n  }): Promise<Response<any>> {\n    try {\n      const request: RequestContext = {\n        ...this.getContextDerivedPropsForRequestCreation(),\n        method: HTTPMethod.post,\n        operationType: OperationType.Batch,\n        path,\n        body,\n        resourceType: ResourceType.item,\n        resourceId,\n        options,\n      };\n      diagnosticNode.addData({\n        operationType: OperationType.Batch,\n        resourceType: ResourceType.item,\n      });\n      request.headers = await this.buildHeaders(request);\n      request.headers[HttpHeaders.IsBatchRequest] = true;\n      request.headers[HttpHeaders.PartitionKeyRangeID] = partitionKeyRangeId;\n      request.headers[HttpHeaders.IsBatchAtomic] = false;\n      request.headers[HttpHeaders.BatchContinueOnError] = bulkOptions.continueOnError ?? true;\n      this.applySessionToken(request);\n\n      request.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(\n        diagnosticNode,\n        request.resourceType,\n        request.operationType,\n      );\n      const response = await executePlugins(\n        diagnosticNode,\n        request,\n        RequestHandler.request,\n        PluginOn.operation,\n      );\n      this.captureSessionToken(undefined, path, OperationType.Batch, response.headers);\n      return response;\n    } catch (err: any) {\n      this.captureSessionToken(err, path, OperationType.Upsert, (err as ErrorResponse).headers);\n      throw err;\n    }\n  }\n\n  private captureSessionToken(\n    err: ErrorResponse,\n    path: string,\n    operationType: OperationType,\n    resHeaders: CosmosHeaders,\n  ): void {\n    const request = this.getSessionParams(path);\n    request.operationType = operationType;\n    if (\n      !err ||\n      (!this.isMasterResource(request.resourceType) &&\n        (err.code === StatusCodes.PreconditionFailed ||\n          err.code === StatusCodes.Conflict ||\n          (err.code === StatusCodes.NotFound &&\n            err.substatus !== SubStatusCodes.ReadSessionNotAvailable)))\n    ) {\n      this.sessionContainer.set(request, resHeaders);\n    }\n  }\n\n  public clearSessionToken(path: string): void {\n    const request = this.getSessionParams(path);\n    this.sessionContainer.remove(request);\n  }\n\n  public recordDiagnostics(diagnostic: CosmosDiagnostics): void {\n    const formatted = this.diagnosticFormatter.format(diagnostic);\n    this.diagnosticWriter.write(formatted);\n  }\n\n  public initializeDiagnosticSettings(diagnosticLevel: CosmosDbDiagnosticLevel): void {\n    this.diagnosticFormatter = new DefaultDiagnosticFormatter();\n    switch (diagnosticLevel) {\n      case CosmosDbDiagnosticLevel.info:\n        this.diagnosticWriter = new NoOpDiagnosticWriter();\n        break;\n      default:\n        this.diagnosticWriter = new LogDiagnosticWriter();\n    }\n  }\n\n  // TODO: move\n  private getSessionParams(resourceLink: string): SessionContext {\n    const resourceId: string = null;\n    let resourceAddress: string = null;\n    const parserOutput = parseLink(resourceLink);\n\n    resourceAddress = parserOutput.objectBody.self;\n\n    const resourceType = parserOutput.type;\n    return {\n      resourceId,\n      resourceAddress,\n      resourceType,\n      isNameBased: true,\n    };\n  }\n\n  private isMasterResource(resourceType: string): boolean {\n    if (\n      resourceType === Constants.Path.OffersPathSegment ||\n      resourceType === Constants.Path.DatabasesPathSegment ||\n      resourceType === Constants.Path.UsersPathSegment ||\n      resourceType === Constants.Path.PermissionsPathSegment ||\n      resourceType === Constants.Path.TopologyPathSegment ||\n      resourceType === Constants.Path.DatabaseAccountPathSegment ||\n      resourceType === Constants.Path.PartitionKeyRangesPathSegment ||\n      resourceType === Constants.Path.CollectionsPathSegment\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private buildHeaders(requestContext: RequestContext): Promise<CosmosHeaders> {\n    return getHeaders({\n      clientOptions: this.cosmosClientOptions,\n      defaultHeaders: {\n        ...this.cosmosClientOptions.defaultHeaders,\n        ...requestContext.options.initialHeaders,\n      },\n      verb: requestContext.method,\n      path: requestContext.path,\n      resourceId: requestContext.resourceId,\n      resourceType: requestContext.resourceType,\n      options: requestContext.options,\n      partitionKeyRangeId: requestContext.partitionKeyRangeId,\n      useMultipleWriteLocations: this.connectionPolicy.useMultipleWriteLocations,\n      partitionKey:\n        requestContext.partitionKey !== undefined\n          ? convertToInternalPartitionKey(requestContext.partitionKey)\n          : undefined, // TODO: Move this check from here to PartitionKey\n    });\n  }\n\n  /**\n   * Returns collection of properties which are derived from the context for Request Creation.\n   * These properties have client wide scope, as opposed to request specific scope.\n   * @returns\n   */\n  private getContextDerivedPropsForRequestCreation(): {\n    globalEndpointManager: GlobalEndpointManager;\n    connectionPolicy: ConnectionPolicy;\n    requestAgent: Agent;\n    client?: ClientContext;\n    pipeline?: Pipeline;\n    plugins: PluginConfig[];\n    httpClient?: HttpClient;\n  } {\n    return {\n      globalEndpointManager: this.globalEndpointManager,\n      requestAgent: this.cosmosClientOptions.agent,\n      connectionPolicy: this.connectionPolicy,\n      client: this,\n      plugins: this.cosmosClientOptions.plugins,\n      pipeline: this.pipeline,\n      httpClient: this.cosmosClientOptions.httpClient,\n    };\n  }\n\n  public getClientConfig(): ClientConfigDiagnostic {\n    return this.clientConfig;\n  }\n\n  /**\n   * @internal\n   */\n  public refreshUserAgent(hostFramework: string): void {\n    const updatedUserAgent = getUserAgent(this.cosmosClientOptions.userAgentSuffix, hostFramework);\n    this.cosmosClientOptions.defaultHeaders[Constants.HttpHeaders.UserAgent] = updatedUserAgent;\n    this.cosmosClientOptions.defaultHeaders[Constants.HttpHeaders.CustomUserAgent] =\n      updatedUserAgent;\n  }\n}\n"],"mappings":"AAAA;AACA;AAGA,SAASA,+BAA+B,EAAEC,mBAAmB,QAAQ,2BAA2B;AAGhG,SAASC,SAAS,EAAEC,UAAU,EAAEC,aAAa,EAAEC,YAAY,QAAQ,oBAAoB;AACvF,SAASC,aAAa,EAAEC,eAAe,EAAEC,SAAS,QAAQ,iBAAiB;AAC3E,SAASC,WAAW,EAAEC,cAAc,QAAQ,sBAAsB;AAGlE,SAASC,gBAAgB,EAAEC,eAAe,EAAEC,6BAA6B,QAAQ,aAAa;AAG9F,SAASC,QAAQ,EAAEC,cAAc,QAAQ,kBAAkB;AAG3D,SAASC,aAAa,QAAQ,iBAAiB;AAI/C,SAASC,UAAU,QAAQ,mBAAmB;AAE9C,SAASC,cAAc,QAAQ,0BAA0B;AACzD,SAASC,gBAAgB,QAAQ,4BAA4B;AAG7D,SAASC,gBAAgB,QAAQ,kBAAkB;AACnD,SAASC,6BAA6B,QAAQ,uCAAuC;AAErF,SAASC,kBAAkB,QAAQ,eAAe;AAIlD,SAASC,mBAAmB,EAAEC,oBAAoB,QAAQ,gCAAgC;AAE1F,SAASC,0BAA0B,QAAQ,mCAAmC;AAC9E,SAASC,uBAAuB,QAAQ,uCAAuC;AAC/E,SAASC,UAAU,QAAQ,kBAAkB;AAC7C,SAASC,YAAY,QAAQ,mBAAmB;AAChD,MAAMC,MAAM,GAAgBP,kBAAkB,CAAC,eAAe,CAAC;AAE/D,MAAMQ,oBAAoB,GAAG,wBAAwB;AACrD,MAAMC,WAAW,GAAG7B,SAAS,CAAC6B,WAAW;AACzC;;;;AAIA,OAAM,MAAOC,aAAa;EAUxBC,YACUC,mBAAwC,EACxCC,qBAA4C,EAC5CC,YAAoC,EACrCC,eAAwC;IAHvC,KAAAH,mBAAmB,GAAnBA,mBAAmB;IACnB,KAAAC,qBAAqB,GAArBA,qBAAqB;IACrB,KAAAC,YAAY,GAAZA,YAAY;IACb,KAAAC,eAAe,GAAfA,eAAe;IAPxB;IACO,KAAAC,gBAAgB,GAAY,KAAK;IAQtC,IAAIJ,mBAAmB,CAACK,uBAAuB,EAAE;MAC/C,IAAI,CAACD,gBAAgB,GAAG,IAAI;IAC9B;IACA,IAAI,CAACE,gBAAgB,GAAGN,mBAAmB,CAACM,gBAAgB;IAC5D,IAAI,CAACC,gBAAgB,GAAG,IAAItB,gBAAgB,EAAE;IAC9C,IAAI,CAACuB,2BAA2B,GAAG,EAAE;IACrC,IAAI,CAACC,QAAQ,GAAG,IAAI;IACpB,IAAIT,mBAAmB,CAACU,cAAc,EAAE;MACtC,IAAI,CAACD,QAAQ,GAAG1C,mBAAmB,EAAE;MACrC,MAAM4C,YAAY,GAAGzB,gBAAgB,CAACc,mBAAmB,CAACY,QAAQ,CAAC;MACnE,MAAMC,KAAK,GAAG,GAAGF,YAAY,WAAW;MACxC,IAAI,CAACF,QAAQ,CAACK,SAAS,CACrBhD,+BAA+B,CAAC;QAC9BiD,UAAU,EAAEf,mBAAmB,CAACU,cAAc;QAC9CM,MAAM,EAAEH,KAAK;QACbI,kBAAkB,EAAE;UAClB,MAAMC,gBAAgBA,CAAC;YAAEC,OAAO;YAAEC;UAAc,CAAE;YAChD,MAAMC,aAAa,GAAG,MAAMD,cAAc,CAAC,CAACP,KAAK,CAAC,EAAE,EAAE,CAAC;YACvD,MAAMS,WAAW,GAAG,uBAAuB;YAC3C,MAAMC,kBAAkB,GAAG,GAAGD,WAAW,GAAGD,aAAa,CAACG,KAAK,EAAE;YACjEL,OAAO,CAACM,OAAO,CAACC,GAAG,CAAC,eAAe,EAAEH,kBAAkB,CAAC;UAC1D;;OAEH,CAAC,CACH;IACH;IACA,IAAI,CAACI,4BAA4B,CAACxB,eAAe,CAAC;EACpD;EACA;EACO,MAAMyB,IAAIA,CAAI;IACnBC,IAAI;IACJC,YAAY;IACZC,UAAU;IACVC,OAAO,GAAG,EAAE;IACZC,YAAY;IACZC;EAAc,CAQf;IACC,IAAI;MACF,MAAMf,OAAO,GAAAgB,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACR,IAAI,CAACC,wCAAwC,EAAE;QAClDC,MAAM,EAAErE,UAAU,CAACsE,GAAG;QACtBV,IAAI;QACJW,aAAa,EAAEtE,aAAa,CAACuE,IAAI;QACjCV,UAAU;QACVC,OAAO;QACPF,YAAY;QACZG;MAAY,EACb;MACDC,cAAc,CAACQ,OAAO,CAAC;QACrBF,aAAa,EAAEtE,aAAa,CAACuE,IAAI;QACjCX;OACD,CAAC;MAEFX,OAAO,CAACM,OAAO,GAAG,MAAM,IAAI,CAACkB,YAAY,CAACxB,OAAO,CAAC;MAClD,IAAIW,YAAY,KAAK3D,YAAY,CAACyE,mBAAmB,EAAE;QACrDzB,OAAO,CAACM,OAAO,CAAC5B,WAAW,CAACgD,sBAAsB,CAAC,GAAG,IAAI;QAC1D,IAAIb,OAAO,CAACc,WAAW,EAAE;UACvB3B,OAAO,CAACM,OAAO,CAAC5B,WAAW,CAACkD,iBAAiB,CAAC,GAAGf,OAAO,CAACc,WAAW;QACtE;MACF;MACA,IAAI,CAACE,iBAAiB,CAAC7B,OAAO,CAAC;MAE/B;MACAA,OAAO,CAACP,QAAQ,GAAG,MAAM,IAAI,CAACX,qBAAqB,CAACgD,sBAAsB,CACxEf,cAAc,EACdf,OAAO,CAACW,YAAY,EACpBX,OAAO,CAACqB,aAAa,CACtB;MACD,MAAMU,QAAQ,GAAG,MAAMrE,cAAc,CACnCqD,cAAc,EACdf,OAAO,EACPnC,cAAc,CAACmC,OAAO,EACtBvC,QAAQ,CAACuE,SAAS,CACnB;MACD,IAAI,CAACC,mBAAmB,CAACC,SAAS,EAAExB,IAAI,EAAE3D,aAAa,CAACuE,IAAI,EAAES,QAAQ,CAACzB,OAAO,CAAC;MAC/E,OAAOyB,QAAQ;IACjB,CAAC,CAAC,OAAOI,GAAQ,EAAE;MACjB,IAAI,CAACF,mBAAmB,CAACE,GAAG,EAAEzB,IAAI,EAAE3D,aAAa,CAACqF,MAAM,EAAGD,GAAqB,CAAC7B,OAAO,CAAC;MACzF,MAAM6B,GAAG;IACX;EACF;EAEO,MAAME,SAASA,CAAI;IACxB3B,IAAI;IACJC,YAAY;IACZC,UAAU;IACV0B,QAAQ;IACRC,KAAK;IACL1B,OAAO;IACPE,cAAc;IACdyB,mBAAmB;IACnB1B,YAAY;IACZ2B,QAAQ;IACRC,MAAM;IACNC;EAAoB,CAcrB;IACC;IACA;IAEA,MAAM3C,OAAO,GAAAgB,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACR,IAAI,CAACC,wCAAwC,EAAE;MAClDC,MAAM,EAAErE,UAAU,CAACsE,GAAG;MACtBV,IAAI;MACJW,aAAa,EAAEtE,aAAa,CAAC6F,KAAK;MAClCJ,mBAAmB;MACnB5B,UAAU;MACVD,YAAY;MACZE,OAAO;MACPgC,IAAI,EAAEN,KAAK;MACXzB;IAAY,EACb;IACDC,cAAc,CAACQ,OAAO,CAAC;MACrBF,aAAa,EAAEtE,aAAa,CAAC6F,KAAK;MAClCjC;KACD,CAAC;IACF,MAAMmC,SAAS,GAAGxE,UAAU,EAAE;IAC9B,IAAIiE,KAAK,KAAKL,SAAS,EAAE;MACvBlC,OAAO,CAACmB,MAAM,GAAGrE,UAAU,CAACiG,IAAI;IAClC;IACA/C,OAAO,CAACP,QAAQ,GAAG,MAAM,IAAI,CAACX,qBAAqB,CAACgD,sBAAsB,CACxEf,cAAc,EACdf,OAAO,CAACW,YAAY,EACpBX,OAAO,CAACqB,aAAa,CACtB;IACDrB,OAAO,CAACM,OAAO,GAAG,MAAM,IAAI,CAACkB,YAAY,CAACxB,OAAO,CAAC;IAElD,IAAIyC,QAAQ,KAAKP,SAAS,IAAIQ,MAAM,KAAKR,SAAS,EAAE;MAClDlC,OAAO,CAACM,OAAO,CAAC5B,WAAW,CAACsE,QAAQ,CAAC,GAAGP,QAAQ;MAChDzC,OAAO,CAACM,OAAO,CAAC5B,WAAW,CAACuE,MAAM,CAAC,GAAGP,MAAM;MAC5C1C,OAAO,CAACM,OAAO,CAAC5B,WAAW,CAACwE,eAAe,CAAC,GAAG,4BAA4B;IAC7E;IAEA,IAAIX,KAAK,KAAKL,SAAS,EAAE;MACvB,IAAIS,oBAAoB,KAAKT,SAAS,EAAE;QACtClC,OAAO,CAACM,OAAO,CAAC5B,WAAW,CAACyE,oBAAoB,CAAC,GAAGR,oBAAoB;MAC1E;MACA3C,OAAO,CAACM,OAAO,CAAC5B,WAAW,CAAC0E,OAAO,CAAC,GAAG,MAAM;MAC7CpD,OAAO,CAACM,OAAO,CAAC5B,WAAW,CAAC2E,WAAW,CAAC,GAAG5E,oBAAoB;MAC/D,IAAI,OAAO8D,KAAK,KAAK,QAAQ,EAAE;QAC7BvC,OAAO,CAAC6C,IAAI,GAAG;UAAEN;QAAK,CAAE,CAAC,CAAC;MAC5B;IACF;IACA,IAAI,CAACV,iBAAiB,CAAC7B,OAAO,CAAC;IAC/BxB,MAAM,CAAC8E,IAAI,CACT,QAAQ,GACNR,SAAS,GACT,UAAU,IACT9C,OAAO,CAACwC,mBAAmB,GAAG,UAAU,GAAGxC,OAAO,CAACwC,mBAAmB,GAAG,EAAE,CAAC,CAChF;IACDhE,MAAM,CAAC+E,OAAO,CAACvD,OAAO,CAAC;IACvB,MAAMwD,KAAK,GAAGC,IAAI,CAACC,GAAG,EAAE;IACxB,MAAM3B,QAAQ,GAAG,MAAMlE,cAAc,CAACmC,OAAO,CAACA,OAAO,EAAEe,cAAc,CAAC;IACtEvC,MAAM,CAAC8E,IAAI,CAAC,QAAQ,GAAGR,SAAS,GAAG,cAAc,IAAIW,IAAI,CAACC,GAAG,EAAE,GAAGF,KAAK,CAAC,GAAG,IAAI,CAAC;IAChF,IAAI,CAACvB,mBAAmB,CAACC,SAAS,EAAExB,IAAI,EAAE3D,aAAa,CAAC6F,KAAK,EAAEb,QAAQ,CAACzB,OAAO,CAAC;IAChF,OAAO,IAAI,CAACqD,wBAAwB,CAAC5B,QAAQ,EAAE,CAAC,CAACQ,KAAK,EAAED,QAAQ,CAAC;EACnE;EAEO,MAAMsB,YAAYA,CACvBlD,IAAY,EACZC,YAA0B,EAC1BC,UAAkB,EAClB2B,KAA4B,EAC5B1B,OAAA,GAAuB,EAAE,EACzBE,cAAsC,EACtC4B,oBAA6B;IAE7B,MAAM3C,OAAO,GAAAgB,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACR,IAAI,CAACC,wCAAwC,EAAE;MAClDC,MAAM,EAAErE,UAAU,CAACiG,IAAI;MACvBrC,IAAI;MACJW,aAAa,EAAEtE,aAAa,CAACuE,IAAI;MACjCV,UAAU;MACVD,YAAY;MACZE,OAAO;MACPgC,IAAI,EAAEN;IAAK,EACZ;IACDxB,cAAc,CAACQ,OAAO,CAAC;MACrBF,aAAa,EAAEtE,aAAa,CAACuE,IAAI;MACjCX;KACD,CAAC;IACFX,OAAO,CAACP,QAAQ,GAAG,MAAM,IAAI,CAACX,qBAAqB,CAACgD,sBAAsB,CACxEf,cAAc,EACdf,OAAO,CAACW,YAAY,EACpBX,OAAO,CAACqB,aAAa,CACtB;IACDrB,OAAO,CAACM,OAAO,GAAG,MAAM,IAAI,CAACkB,YAAY,CAACxB,OAAO,CAAC;IAClD,IAAI2C,oBAAoB,KAAKT,SAAS,EAAE;MACtClC,OAAO,CAACM,OAAO,CAAC5B,WAAW,CAACyE,oBAAoB,CAAC,GAAGR,oBAAoB;IAC1E;IACA3C,OAAO,CAACM,OAAO,CAAC5B,WAAW,CAACmF,WAAW,CAAC,GAAG,MAAM;IACjD7D,OAAO,CAACM,OAAO,CAAC5B,WAAW,CAACoF,YAAY,CAAC,GAAG,KAAK;IACjD9D,OAAO,CAACM,OAAO,CAAC5B,WAAW,CAAC2E,WAAW,CAAC,GAAG5E,oBAAoB;IAC/DuB,OAAO,CAACM,OAAO,CAAC5B,WAAW,CAACqF,sBAAsB,CAAC,GAAG/F,6BAA6B,CACjF6C,OAAO,CAACmD,+BAA+B,CACxC;IAED,IAAI,OAAOzB,KAAK,KAAK,QAAQ,EAAE;MAC7BvC,OAAO,CAAC6C,IAAI,GAAG;QAAEN;MAAK,CAAE,CAAC,CAAC;IAC5B;IAEA,IAAI,CAACV,iBAAiB,CAAC7B,OAAO,CAAC;IAC/B,MAAM+B,QAAQ,GAAG,MAAMlE,cAAc,CAACmC,OAAO,CAACA,OAAO,EAAEe,cAAc,CAAC;IACtE,IAAI,CAACkB,mBAAmB,CAACC,SAAS,EAAExB,IAAI,EAAE3D,aAAa,CAAC6F,KAAK,EAAEb,QAAQ,CAACzB,OAAO,CAAC;IAChF,OAAOyB,QAAe;EACxB;EAEOkC,uBAAuBA,CAC5BC,cAAsB,EACtB3B,KAA6B,EAC7B1B,OAAqB;IAErB,MAAMH,IAAI,GAAGxD,eAAe,CAACgH,cAAc,EAAElH,YAAY,CAACmH,QAAQ,CAAC;IACnE,MAAMC,EAAE,GAAGnH,aAAa,CAACiH,cAAc,CAAC;IACxC,MAAMG,EAAE,GAA0B,MAAAA,CAAOC,QAAQ,EAAEC,YAAY,KAAI;MACjE,MAAMxC,QAAQ,GAAG,MAAM,IAAI,CAACM,SAAS,CAAC;QACpC3B,IAAI;QACJC,YAAY,EAAE3D,YAAY,CAACmH,QAAQ;QACnCvD,UAAU,EAAEwD,EAAE;QACd9B,QAAQ,EAAGkC,MAAM,IAAKA,MAAM,CAACC,kBAAkB;QAC/ClC,KAAK;QACL1B,OAAO,EAAE0D,YAAY;QACrBxD,cAAc,EAAEuD;OACjB,CAAC;MACF,OAAOvC,QAAQ;IACjB,CAAC;IACD,OAAO,IAAIpE,aAAa,CAAoB,IAAI,EAAE4E,KAAK,EAAE1B,OAAO,EAAEwD,EAAE,CAAC;EACvE;EAEO,MAAMK,MAAMA,CAAI;IACrBhE,IAAI;IACJC,YAAY;IACZC,UAAU;IACVC,OAAO,GAAG,EAAE;IACZC,YAAY;IACZK,MAAM,GAAGrE,UAAU,CAAC4H,MAAM;IAC1B3D;EAAc,CASf;IACC,IAAI;MACF,MAAMf,OAAO,GAAAgB,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACR,IAAI,CAACC,wCAAwC,EAAE;QAClDC,MAAM,EAAEA,MAAM;QACdE,aAAa,EAAEtE,aAAa,CAAC4H,MAAM;QACnCjE,IAAI;QACJC,YAAY;QACZE,OAAO;QACPD,UAAU;QACVE;MAAY,EACb;MACDC,cAAc,CAACQ,OAAO,CAAC;QACrBF,aAAa,EAAEtE,aAAa,CAAC4H,MAAM;QACnChE;OACD,CAAC;MACFX,OAAO,CAACM,OAAO,GAAG,MAAM,IAAI,CAACkB,YAAY,CAACxB,OAAO,CAAC;MAClD,IAAI,CAAC6B,iBAAiB,CAAC7B,OAAO,CAAC;MAC/B;MACAA,OAAO,CAACP,QAAQ,GAAG,MAAM,IAAI,CAACX,qBAAqB,CAACgD,sBAAsB,CACxEf,cAAc,EACdf,OAAO,CAACW,YAAY,EACpBX,OAAO,CAACqB,aAAa,CACtB;MACD,MAAMU,QAAQ,GAAG,MAAMrE,cAAc,CACnCqD,cAAc,EACdf,OAAO,EACPnC,cAAc,CAACmC,OAAO,EACtBvC,QAAQ,CAACuE,SAAS,CACnB;MACD,IAAI7E,SAAS,CAACuD,IAAI,CAAC,CAACkE,IAAI,KAAK,OAAO,EAAE;QACpC,IAAI,CAAC3C,mBAAmB,CAACC,SAAS,EAAExB,IAAI,EAAE3D,aAAa,CAAC4H,MAAM,EAAE5C,QAAQ,CAACzB,OAAO,CAAC;MACnF,CAAC,MAAM;QACL,IAAI,CAACuE,iBAAiB,CAACnE,IAAI,CAAC;MAC9B;MACA,OAAOqB,QAAQ;IACjB,CAAC,CAAC,OAAOI,GAAQ,EAAE;MACjB,IAAI,CAACF,mBAAmB,CAACE,GAAG,EAAEzB,IAAI,EAAE3D,aAAa,CAACqF,MAAM,EAAGD,GAAqB,CAAC7B,OAAO,CAAC;MACzF,MAAM6B,GAAG;IACX;EACF;EAEO,MAAM2C,KAAKA,CAAI;IACpBjC,IAAI;IACJnC,IAAI;IACJC,YAAY;IACZC,UAAU;IACVC,OAAO,GAAG,EAAE;IACZC,YAAY;IACZC;EAAc,CASf;IACC,IAAI;MACF,MAAMf,OAAO,GAAAgB,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACR,IAAI,CAACC,wCAAwC,EAAE;QAClDC,MAAM,EAAErE,UAAU,CAACgI,KAAK;QACxBzD,aAAa,EAAEtE,aAAa,CAACgI,KAAK;QAClCrE,IAAI;QACJC,YAAY;QACZkC,IAAI;QACJjC,UAAU;QACVC,OAAO;QACPC;MAAY,EACb;MACDC,cAAc,CAACQ,OAAO,CAAC;QACrBF,aAAa,EAAEtE,aAAa,CAACgI,KAAK;QAClCpE;OACD,CAAC;MACFX,OAAO,CAACM,OAAO,GAAG,MAAM,IAAI,CAACkB,YAAY,CAACxB,OAAO,CAAC;MAClD,IAAI,CAAC6B,iBAAiB,CAAC7B,OAAO,CAAC;MAE/B;MACAA,OAAO,CAACP,QAAQ,GAAG,MAAM,IAAI,CAACX,qBAAqB,CAACgD,sBAAsB,CACxEf,cAAc,EACdf,OAAO,CAACW,YAAY,EACpBX,OAAO,CAACqB,aAAa,CACtB;MACD,MAAMU,QAAQ,GAAG,MAAMrE,cAAc,CACnCqD,cAAc,EACdf,OAAO,EACPnC,cAAc,CAACmC,OAAO,EACtBvC,QAAQ,CAACuE,SAAS,CACnB;MACD,IAAI,CAACC,mBAAmB,CAACC,SAAS,EAAExB,IAAI,EAAE3D,aAAa,CAACgI,KAAK,EAAEhD,QAAQ,CAACzB,OAAO,CAAC;MAChF,OAAOyB,QAAQ;IACjB,CAAC,CAAC,OAAOI,GAAQ,EAAE;MACjB,IAAI,CAACF,mBAAmB,CAACE,GAAG,EAAEzB,IAAI,EAAE3D,aAAa,CAACqF,MAAM,EAAGD,GAAqB,CAAC7B,OAAO,CAAC;MACzF,MAAM6B,GAAG;IACX;EACF;EAEO,MAAM6C,MAAMA,CAAW;IAC5BnC,IAAI;IACJnC,IAAI;IACJC,YAAY;IACZC,UAAU;IACVG,cAAc;IACdF,OAAO,GAAG,EAAE;IACZC;EAAY,CASb;IACC,IAAI;MACF,MAAMd,OAAO,GAAAgB,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACR,IAAI,CAACC,wCAAwC,EAAE;QAClDC,MAAM,EAAErE,UAAU,CAACiG,IAAI;QACvB1B,aAAa,EAAEtE,aAAa,CAACkI,MAAM;QACnCvE,IAAI;QACJC,YAAY;QACZC,UAAU;QACViC,IAAI;QACJhC,OAAO;QACPC;MAAY,EACb;MACDC,cAAc,CAACQ,OAAO,CAAC;QACrBF,aAAa,EAAEtE,aAAa,CAACkI,MAAM;QACnCtE;OACD,CAAC;MACFX,OAAO,CAACM,OAAO,GAAG,MAAM,IAAI,CAACkB,YAAY,CAACxB,OAAO,CAAC;MAClD;MACA,IAAI,CAAC6B,iBAAiB,CAAC7B,OAAO,CAAC;MAE/BA,OAAO,CAACP,QAAQ,GAAG,MAAM,IAAI,CAACX,qBAAqB,CAACgD,sBAAsB,CACxEf,cAAc,EACdf,OAAO,CAACW,YAAY,EACpBX,OAAO,CAACqB,aAAa,CACtB;MACD,MAAMU,QAAQ,GAAG,MAAMrE,cAAc,CACnCqD,cAAc,EACdf,OAAO,EACPnC,cAAc,CAACmC,OAAO,EACtBvC,QAAQ,CAACuE,SAAS,CACnB;MACD,IAAI,CAACC,mBAAmB,CAACC,SAAS,EAAExB,IAAI,EAAE3D,aAAa,CAACkI,MAAM,EAAElD,QAAQ,CAACzB,OAAO,CAAC;MACjF,OAAOyB,QAAQ;IACjB,CAAC,CAAC,OAAOI,GAAQ,EAAE;MACjB,IAAI,CAACF,mBAAmB,CAACE,GAAG,EAAEzB,IAAI,EAAE3D,aAAa,CAACqF,MAAM,EAAGD,GAAqB,CAAC7B,OAAO,CAAC;MACzF,MAAM6B,GAAG;IACX;EACF;EAEQwB,wBAAwBA,CAC9BuB,GAAkB,EAClBC,OAAgB,EAChB7C,QAAmD;IAEnD,IAAI6C,OAAO,EAAE;MACX,OAAO;QACLX,MAAM,EAAElC,QAAQ,CAAC4C,GAAG,CAACV,MAAM,CAAC;QAC5BlE,OAAO,EAAE4E,GAAG,CAAC5E,OAAO;QACpB8E,IAAI,EAAEF,GAAG,CAACE;OACX;IACH,CAAC,MAAM;MACL,MAAMC,SAAS,GAAG/C,QAAQ,CAAC4C,GAAG,CAACV,MAAM,CAAC,CAACc,GAAG,CAAEzC,IAAS,IAAKA,IAAI,CAAC;MAC/D,OAAO;QACL2B,MAAM,EAAEa,SAAS;QACjB/E,OAAO,EAAE4E,GAAG,CAAC5E,OAAO;QACpB8E,IAAI,EAAEF,GAAG,CAACE;OACX;IACH;EACF;EAEQvD,iBAAiBA,CAAC0D,cAA8B;IACtD,MAAMvF,OAAO,GAAG,IAAI,CAACwF,gBAAgB,CAACD,cAAc,CAAC7E,IAAI,CAAC;IAE1D,IAAI6E,cAAc,CAACjF,OAAO,IAAIiF,cAAc,CAACjF,OAAO,CAAC5B,WAAW,CAAC+G,YAAY,CAAC,EAAE;MAC9E;IACF;IAEA,MAAMC,kBAAkB,GAAqBH,cAAc,CAACjF,OAAO,CACjE5B,WAAW,CAACpB,gBAAgB,CACT;IACrB,IAAI,CAACoI,kBAAkB,EAAE;MACvB;IACF;IAEA,IAAIA,kBAAkB,KAAKpI,gBAAgB,CAACqI,OAAO,EAAE;MACnD;IACF;IAEA,IAAI3F,OAAO,CAAC4F,eAAe,EAAE;MAC3B,MAAMC,YAAY,GAAG,IAAI,CAACzG,gBAAgB,CAACgC,GAAG,CAACpB,OAAO,CAAC;MACvD,IAAI6F,YAAY,EAAE;QAChBN,cAAc,CAACjF,OAAO,CAAC5B,WAAW,CAAC+G,YAAY,CAAC,GAAGI,YAAY;MACjE;IACF;EACF;EAEO,MAAMC,OAAOA,CAAI;IACtBjD,IAAI;IACJnC,IAAI;IACJC,YAAY;IACZC,UAAU;IACVC,OAAO,GAAG,EAAE;IACZC,YAAY;IACZC;EAAc,CASf;IACC,IAAI;MACF,MAAMf,OAAO,GAAAgB,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACR,IAAI,CAACC,wCAAwC,EAAE;QAClDC,MAAM,EAAErE,UAAU,CAACiJ,GAAG;QACtB1E,aAAa,EAAEtE,aAAa,CAACiJ,OAAO;QACpCtF,IAAI;QACJC,YAAY;QACZkC,IAAI;QACJjC,UAAU;QACVC,OAAO;QACPC;MAAY,EACb;MACDC,cAAc,CAACQ,OAAO,CAAC;QACrBF,aAAa,EAAEtE,aAAa,CAACiJ,OAAO;QACpCrF;OACD,CAAC;MACFX,OAAO,CAACM,OAAO,GAAG,MAAM,IAAI,CAACkB,YAAY,CAACxB,OAAO,CAAC;MAClD,IAAI,CAAC6B,iBAAiB,CAAC7B,OAAO,CAAC;MAE/B;MACAA,OAAO,CAACP,QAAQ,GAAG,MAAM,IAAI,CAACX,qBAAqB,CAACgD,sBAAsB,CACxEf,cAAc,EACdf,OAAO,CAACW,YAAY,EACpBX,OAAO,CAACqB,aAAa,CACtB;MACD,MAAMU,QAAQ,GAAG,MAAMrE,cAAc,CACnCqD,cAAc,EACdf,OAAO,EACPnC,cAAc,CAACmC,OAAO,EACtBvC,QAAQ,CAACuE,SAAS,CACnB;MACD,IAAI,CAACC,mBAAmB,CAACC,SAAS,EAAExB,IAAI,EAAE3D,aAAa,CAACiJ,OAAO,EAAEjE,QAAQ,CAACzB,OAAO,CAAC;MAClF,OAAOyB,QAAQ;IACjB,CAAC,CAAC,OAAOI,GAAQ,EAAE;MACjB,IAAI,CAACF,mBAAmB,CAACE,GAAG,EAAEzB,IAAI,EAAE3D,aAAa,CAACqF,MAAM,EAAGD,GAAqB,CAAC7B,OAAO,CAAC;MACzF,MAAM6B,GAAG;IACX;EACF;EAEO,MAAM8D,MAAMA,CAAW;IAC5BpD,IAAI;IACJnC,IAAI;IACJC,YAAY;IACZC,UAAU;IACVC,OAAO,GAAG,EAAE;IACZC,YAAY;IACZC;EAAc,CASf;IACC,IAAI;MACF,MAAMf,OAAO,GAAAgB,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACR,IAAI,CAACC,wCAAwC,EAAE;QAClDC,MAAM,EAAErE,UAAU,CAACiG,IAAI;QACvB1B,aAAa,EAAEtE,aAAa,CAACqF,MAAM;QACnC1B,IAAI;QACJC,YAAY;QACZkC,IAAI;QACJjC,UAAU;QACVC,OAAO;QACPC;MAAY,EACb;MACDC,cAAc,CAACQ,OAAO,CAAC;QACrBF,aAAa,EAAEtE,aAAa,CAACqF,MAAM;QACnCzB;OACD,CAAC;MACFX,OAAO,CAACM,OAAO,GAAG,MAAM,IAAI,CAACkB,YAAY,CAACxB,OAAO,CAAC;MAClDA,OAAO,CAACM,OAAO,CAAC5B,WAAW,CAACwH,QAAQ,CAAC,GAAG,IAAI;MAC5C,IAAI,CAACrE,iBAAiB,CAAC7B,OAAO,CAAC;MAE/B;MACAA,OAAO,CAACP,QAAQ,GAAG,MAAM,IAAI,CAACX,qBAAqB,CAACgD,sBAAsB,CACxEf,cAAc,EACdf,OAAO,CAACW,YAAY,EACpBX,OAAO,CAACqB,aAAa,CACtB;MACD,MAAMU,QAAQ,GAAG,MAAMrE,cAAc,CACnCqD,cAAc,EACdf,OAAO,EACPnC,cAAc,CAACmC,OAAO,EACtBvC,QAAQ,CAACuE,SAAS,CACnB;MACD,IAAI,CAACC,mBAAmB,CAACC,SAAS,EAAExB,IAAI,EAAE3D,aAAa,CAACqF,MAAM,EAAEL,QAAQ,CAACzB,OAAO,CAAC;MACjF,OAAOyB,QAAQ;IACjB,CAAC,CAAC,OAAOI,GAAQ,EAAE;MACjB,IAAI,CAACF,mBAAmB,CAACE,GAAG,EAAEzB,IAAI,EAAE3D,aAAa,CAACqF,MAAM,EAAGD,GAAqB,CAAC7B,OAAO,CAAC;MACzF,MAAM6B,GAAG;IACX;EACF;EAEO,MAAMgE,OAAOA,CAAI;IACtBC,SAAS;IACTC,MAAM;IACNxF,OAAO,GAAG,EAAE;IACZC,YAAY;IACZC;EAAc,CAOf;IACC;IACA;IACA,IAAIsF,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAKnE,SAAS,IAAI,CAACoE,KAAK,CAACC,OAAO,CAACF,MAAM,CAAC,EAAE;MACrEA,MAAM,GAAG,CAACA,MAAM,CAAC;IACnB;IACA,MAAM3F,IAAI,GAAGxD,eAAe,CAACkJ,SAAS,CAAC;IACvC,MAAMhC,EAAE,GAAGnH,aAAa,CAACmJ,SAAS,CAAC;IAEnC,MAAMpG,OAAO,GAAAgB,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACR,IAAI,CAACC,wCAAwC,EAAE;MAClDC,MAAM,EAAErE,UAAU,CAACiG,IAAI;MACvB1B,aAAa,EAAEtE,aAAa,CAACyJ,OAAO;MACpC9F,IAAI;MACJC,YAAY,EAAE3D,YAAY,CAACyJ,KAAK;MAChC5F,OAAO;MACPD,UAAU,EAAEwD,EAAE;MACdvB,IAAI,EAAEwD,MAAM;MACZvF;IAAY,EACb;IACDC,cAAc,CAACQ,OAAO,CAAC;MACrBF,aAAa,EAAEtE,aAAa,CAACyJ,OAAO;MACpC7F,YAAY,EAAE3D,YAAY,CAACyJ;KAC5B,CAAC;IACFzG,OAAO,CAACM,OAAO,GAAG,MAAM,IAAI,CAACkB,YAAY,CAACxB,OAAO,CAAC;IAClD;IACAA,OAAO,CAACP,QAAQ,GAAG,MAAM,IAAI,CAACX,qBAAqB,CAACgD,sBAAsB,CACxEf,cAAc,EACdf,OAAO,CAACW,YAAY,EACpBX,OAAO,CAACqB,aAAa,CACtB;IACD,MAAMU,QAAQ,GAAG,MAAMrE,cAAc,CACnCqD,cAAc,EACdf,OAAO,EACPnC,cAAc,CAACmC,OAAO,EACtBvC,QAAQ,CAACuE,SAAS,CACnB;IACD,OAAOD,QAAQ;EACjB;EAEA;;;;;EAKO,MAAM2E,kBAAkBA,CAC7B3F,cAAsC,EACtCF,OAAA,GAA0B,EAAE;IAE5B,MAAMpB,QAAQ,GAAGoB,OAAO,CAAC8F,aAAa,IAAI,IAAI,CAAC9H,mBAAmB,CAACY,QAAQ;IAC3E,MAAMO,OAAO,GAAAgB,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACR,IAAI,CAACC,wCAAwC,EAAE;MAClDzB,QAAQ;MACR0B,MAAM,EAAErE,UAAU,CAACsE,GAAG;MACtBC,aAAa,EAAEtE,aAAa,CAACuE,IAAI;MACjCZ,IAAI,EAAE,EAAE;MACRC,YAAY,EAAE3D,YAAY,CAAC4J,IAAI;MAC/B/F;IAAO,EACR;IACDE,cAAc,CAACQ,OAAO,CAAC;MACrBF,aAAa,EAAEtE,aAAa,CAACuE,IAAI;MACjCX,YAAY,EAAE3D,YAAY,CAAC4J;KAC5B,CAAC;IACF5G,OAAO,CAACM,OAAO,GAAG,MAAM,IAAI,CAACkB,YAAY,CAACxB,OAAO,CAAC;IAClD;IACA,MAAM;MAAEwE,MAAM;MAAElE,OAAO;MAAE8E,IAAI;MAAEyB,SAAS;MAAEC;IAAW,CAAE,GAAG,MAAMpJ,cAAc,CAC5EqD,cAAc,EACdf,OAAO,EACPnC,cAAc,CAACmC,OAAO,EACtBvC,QAAQ,CAACuE,SAAS,CACnB;IAED,MAAM+E,eAAe,GAAG,IAAIxJ,eAAe,CAACiH,MAAM,EAAElE,OAAO,CAAC;IAC5D,OAAO;MACLkE,MAAM,EAAEuC,eAAe;MACvBzG,OAAO;MACPwG,WAAW;MACX1B,IAAI,EAAEA,IAAI;MACVyB,SAAS,EAAEA;KACZ;EACH;EAEOG,gBAAgBA,CAACjG,cAAsC;IAC5D,OAAO,IAAI,CAACjC,qBAAqB,CAACkI,gBAAgB,CAACjG,cAAc,CAAC;EACpE;EAEOkG,eAAeA,CAAClG,cAAsC;IAC3D,OAAO,IAAI,CAACjC,qBAAqB,CAACmI,eAAe,CAAClG,cAAc,CAAC;EACnE;EAEOmG,iBAAiBA,CAAA;IACtB,OAAO,IAAI,CAACpI,qBAAqB,CAACoI,iBAAiB,EAAE;EACvD;EAEOC,gBAAgBA,CAAA;IACrB,OAAO,IAAI,CAACrI,qBAAqB,CAACqI,gBAAgB,EAAE;EACtD;EAEO,MAAMC,KAAKA,CAAI;IACpBvE,IAAI;IACJnC,IAAI;IACJI,YAAY;IACZF,UAAU;IACVC,OAAO,GAAG,EAAE;IACZE;EAAc,CAQf;IACC,IAAI;MACF,MAAMf,OAAO,GAAAgB,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACR,IAAI,CAACC,wCAAwC,EAAE;QAClDC,MAAM,EAAErE,UAAU,CAACiG,IAAI;QACvB1B,aAAa,EAAEtE,aAAa,CAACsK,KAAK;QAClC3G,IAAI;QACJmC,IAAI;QACJlC,YAAY,EAAE3D,YAAY,CAACsK,IAAI;QAC/B1G,UAAU;QACVC,OAAO;QACPC;MAAY,EACb;MACDC,cAAc,CAACQ,OAAO,CAAC;QACrBF,aAAa,EAAEtE,aAAa,CAACsK,KAAK;QAClC1G,YAAY,EAAE3D,YAAY,CAACsK;OAC5B,CAAC;MACFtH,OAAO,CAACM,OAAO,GAAG,MAAM,IAAI,CAACkB,YAAY,CAACxB,OAAO,CAAC;MAClDA,OAAO,CAACM,OAAO,CAAC5B,WAAW,CAAC6I,cAAc,CAAC,GAAG,IAAI;MAClDvH,OAAO,CAACM,OAAO,CAAC5B,WAAW,CAAC8I,aAAa,CAAC,GAAG,IAAI;MAEjD,IAAI,CAAC3F,iBAAiB,CAAC7B,OAAO,CAAC;MAE/BA,OAAO,CAACP,QAAQ,GAAG,MAAM,IAAI,CAACX,qBAAqB,CAACgD,sBAAsB,CACxEf,cAAc,EACdf,OAAO,CAACW,YAAY,EACpBX,OAAO,CAACqB,aAAa,CACtB;MACD,MAAMU,QAAQ,GAAG,MAAMrE,cAAc,CACnCqD,cAAc,EACdf,OAAO,EACPnC,cAAc,CAACmC,OAAO,EACtBvC,QAAQ,CAACuE,SAAS,CACnB;MACD,IAAI,CAACC,mBAAmB,CAACC,SAAS,EAAExB,IAAI,EAAE3D,aAAa,CAACsK,KAAK,EAAEtF,QAAQ,CAACzB,OAAO,CAAC;MAChFyB,QAAQ,CAAC+E,WAAW,GAAG/F,cAAc,CAAC0G,YAAY,CAAC,IAAI,CAACC,eAAe,EAAE,CAAC;MAC1E,OAAO3F,QAAQ;IACjB,CAAC,CAAC,OAAOI,GAAQ,EAAE;MACjB,IAAI,CAACF,mBAAmB,CAACE,GAAG,EAAEzB,IAAI,EAAE3D,aAAa,CAACqF,MAAM,EAAGD,GAAqB,CAAC7B,OAAO,CAAC;MACzF,MAAM6B,GAAG;IACX;EACF;EAEO,MAAMwF,IAAIA,CAAI;IACnB9E,IAAI;IACJnC,IAAI;IACJ8B,mBAAmB;IACnB5B,UAAU;IACVgH,WAAW,GAAG,EAAE;IAChB/G,OAAO,GAAG,EAAE;IACZE;EAAc,CASf;;IACC,IAAI;MACF,MAAMf,OAAO,GAAAgB,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACR,IAAI,CAACC,wCAAwC,EAAE;QAClDC,MAAM,EAAErE,UAAU,CAACiG,IAAI;QACvB1B,aAAa,EAAEtE,aAAa,CAACsK,KAAK;QAClC3G,IAAI;QACJmC,IAAI;QACJlC,YAAY,EAAE3D,YAAY,CAACsK,IAAI;QAC/B1G,UAAU;QACVC;MAAO,EACR;MACDE,cAAc,CAACQ,OAAO,CAAC;QACrBF,aAAa,EAAEtE,aAAa,CAACsK,KAAK;QAClC1G,YAAY,EAAE3D,YAAY,CAACsK;OAC5B,CAAC;MACFtH,OAAO,CAACM,OAAO,GAAG,MAAM,IAAI,CAACkB,YAAY,CAACxB,OAAO,CAAC;MAClDA,OAAO,CAACM,OAAO,CAAC5B,WAAW,CAAC6I,cAAc,CAAC,GAAG,IAAI;MAClDvH,OAAO,CAACM,OAAO,CAAC5B,WAAW,CAACmJ,mBAAmB,CAAC,GAAGrF,mBAAmB;MACtExC,OAAO,CAACM,OAAO,CAAC5B,WAAW,CAAC8I,aAAa,CAAC,GAAG,KAAK;MAClDxH,OAAO,CAACM,OAAO,CAAC5B,WAAW,CAACoJ,oBAAoB,CAAC,GAAG,CAAAC,EAAA,GAAAH,WAAW,CAACI,eAAe,cAAAD,EAAA,cAAAA,EAAA,GAAI,IAAI;MACvF,IAAI,CAAClG,iBAAiB,CAAC7B,OAAO,CAAC;MAE/BA,OAAO,CAACP,QAAQ,GAAG,MAAM,IAAI,CAACX,qBAAqB,CAACgD,sBAAsB,CACxEf,cAAc,EACdf,OAAO,CAACW,YAAY,EACpBX,OAAO,CAACqB,aAAa,CACtB;MACD,MAAMU,QAAQ,GAAG,MAAMrE,cAAc,CACnCqD,cAAc,EACdf,OAAO,EACPnC,cAAc,CAACmC,OAAO,EACtBvC,QAAQ,CAACuE,SAAS,CACnB;MACD,IAAI,CAACC,mBAAmB,CAACC,SAAS,EAAExB,IAAI,EAAE3D,aAAa,CAACsK,KAAK,EAAEtF,QAAQ,CAACzB,OAAO,CAAC;MAChF,OAAOyB,QAAQ;IACjB,CAAC,CAAC,OAAOI,GAAQ,EAAE;MACjB,IAAI,CAACF,mBAAmB,CAACE,GAAG,EAAEzB,IAAI,EAAE3D,aAAa,CAACqF,MAAM,EAAGD,GAAqB,CAAC7B,OAAO,CAAC;MACzF,MAAM6B,GAAG;IACX;EACF;EAEQF,mBAAmBA,CACzBE,GAAkB,EAClBzB,IAAY,EACZW,aAA4B,EAC5B4G,UAAyB;IAEzB,MAAMjI,OAAO,GAAG,IAAI,CAACwF,gBAAgB,CAAC9E,IAAI,CAAC;IAC3CV,OAAO,CAACqB,aAAa,GAAGA,aAAa;IACrC,IACE,CAACc,GAAG,IACH,CAAC,IAAI,CAAC+F,gBAAgB,CAAClI,OAAO,CAACW,YAAY,CAAC,KAC1CwB,GAAG,CAACiD,IAAI,KAAKhI,WAAW,CAAC+K,kBAAkB,IAC1ChG,GAAG,CAACiD,IAAI,KAAKhI,WAAW,CAACgL,QAAQ,IAChCjG,GAAG,CAACiD,IAAI,KAAKhI,WAAW,CAACiL,QAAQ,IAChClG,GAAG,CAAC0E,SAAS,KAAKxJ,cAAc,CAACiL,uBAAwB,CAAE,EACjE;MACA,IAAI,CAAClJ,gBAAgB,CAACmB,GAAG,CAACP,OAAO,EAAEiI,UAAU,CAAC;IAChD;EACF;EAEOpD,iBAAiBA,CAACnE,IAAY;IACnC,MAAMV,OAAO,GAAG,IAAI,CAACwF,gBAAgB,CAAC9E,IAAI,CAAC;IAC3C,IAAI,CAACtB,gBAAgB,CAACmJ,MAAM,CAACvI,OAAO,CAAC;EACvC;EAEOwI,iBAAiBA,CAACC,UAA6B;IACpD,MAAMC,SAAS,GAAG,IAAI,CAACC,mBAAmB,CAACC,MAAM,CAACH,UAAU,CAAC;IAC7D,IAAI,CAACI,gBAAgB,CAACC,KAAK,CAACJ,SAAS,CAAC;EACxC;EAEOlI,4BAA4BA,CAACxB,eAAwC;IAC1E,IAAI,CAAC2J,mBAAmB,GAAG,IAAIvK,0BAA0B,EAAE;IAC3D,QAAQY,eAAe;MACrB,KAAKX,uBAAuB,CAACiF,IAAI;QAC/B,IAAI,CAACuF,gBAAgB,GAAG,IAAI1K,oBAAoB,EAAE;QAClD;MACF;QACE,IAAI,CAAC0K,gBAAgB,GAAG,IAAI3K,mBAAmB,EAAE;IACrD;EACF;EAEA;EACQsH,gBAAgBA,CAACuD,YAAoB;IAC3C,MAAMnI,UAAU,GAAW,IAAI;IAC/B,IAAIgF,eAAe,GAAW,IAAI;IAClC,MAAMoD,YAAY,GAAG7L,SAAS,CAAC4L,YAAY,CAAC;IAE5CnD,eAAe,GAAGoD,YAAY,CAACC,UAAU,CAACC,IAAI;IAE9C,MAAMvI,YAAY,GAAGqI,YAAY,CAACpE,IAAI;IACtC,OAAO;MACLhE,UAAU;MACVgF,eAAe;MACfjF,YAAY;MACZwI,WAAW,EAAE;KACd;EACH;EAEQjB,gBAAgBA,CAACvH,YAAoB;IAC3C,IACEA,YAAY,KAAK9D,SAAS,CAACuM,IAAI,CAACC,iBAAiB,IACjD1I,YAAY,KAAK9D,SAAS,CAACuM,IAAI,CAACE,oBAAoB,IACpD3I,YAAY,KAAK9D,SAAS,CAACuM,IAAI,CAACG,gBAAgB,IAChD5I,YAAY,KAAK9D,SAAS,CAACuM,IAAI,CAACI,sBAAsB,IACtD7I,YAAY,KAAK9D,SAAS,CAACuM,IAAI,CAACK,mBAAmB,IACnD9I,YAAY,KAAK9D,SAAS,CAACuM,IAAI,CAACM,0BAA0B,IAC1D/I,YAAY,KAAK9D,SAAS,CAACuM,IAAI,CAACO,6BAA6B,IAC7DhJ,YAAY,KAAK9D,SAAS,CAACuM,IAAI,CAACQ,sBAAsB,EACtD;MACA,OAAO,IAAI;IACb;IAEA,OAAO,KAAK;EACd;EAEQpI,YAAYA,CAAC+D,cAA8B;IACjD,OAAO3H,UAAU,CAAC;MAChBiM,aAAa,EAAE,IAAI,CAAChL,mBAAmB;MACvCiL,cAAc,EAAA9I,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACT,IAAI,CAACpC,mBAAmB,CAACiL,cAAc,GACvCvE,cAAc,CAAC1E,OAAO,CAACkJ,cAAc,CACzC;MACDC,IAAI,EAAEzE,cAAc,CAACpE,MAAM;MAC3BT,IAAI,EAAE6E,cAAc,CAAC7E,IAAI;MACzBE,UAAU,EAAE2E,cAAc,CAAC3E,UAAU;MACrCD,YAAY,EAAE4E,cAAc,CAAC5E,YAAY;MACzCE,OAAO,EAAE0E,cAAc,CAAC1E,OAAO;MAC/B2B,mBAAmB,EAAE+C,cAAc,CAAC/C,mBAAmB;MACvDyH,yBAAyB,EAAE,IAAI,CAAC9K,gBAAgB,CAAC8K,yBAAyB;MAC1EnJ,YAAY,EACVyE,cAAc,CAACzE,YAAY,KAAKoB,SAAS,GACrC1E,6BAA6B,CAAC+H,cAAc,CAACzE,YAAY,CAAC,GAC1DoB,SAAS,CAAE;KAClB,CAAC;EACJ;EAEA;;;;;EAKQhB,wCAAwCA,CAAA;IAS9C,OAAO;MACLpC,qBAAqB,EAAE,IAAI,CAACA,qBAAqB;MACjDoL,YAAY,EAAE,IAAI,CAACrL,mBAAmB,CAACsL,KAAK;MAC5ChL,gBAAgB,EAAE,IAAI,CAACA,gBAAgB;MACvCiL,MAAM,EAAE,IAAI;MACZC,OAAO,EAAE,IAAI,CAACxL,mBAAmB,CAACwL,OAAO;MACzC/K,QAAQ,EAAE,IAAI,CAACA,QAAQ;MACvBgL,UAAU,EAAE,IAAI,CAACzL,mBAAmB,CAACyL;KACtC;EACH;EAEO5C,eAAeA,CAAA;IACpB,OAAO,IAAI,CAAC3I,YAAY;EAC1B;EAEA;;;EAGOwL,gBAAgBA,CAACC,aAAqB;IAC3C,MAAMC,gBAAgB,GAAGlM,YAAY,CAAC,IAAI,CAACM,mBAAmB,CAAC6L,eAAe,EAAEF,aAAa,CAAC;IAC9F,IAAI,CAAC3L,mBAAmB,CAACiL,cAAc,CAACjN,SAAS,CAAC6B,WAAW,CAACiM,SAAS,CAAC,GAAGF,gBAAgB;IAC3F,IAAI,CAAC5L,mBAAmB,CAACiL,cAAc,CAACjN,SAAS,CAAC6B,WAAW,CAACkM,eAAe,CAAC,GAC5EH,gBAAgB;EACpB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}