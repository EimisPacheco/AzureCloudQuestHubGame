{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { ChangeFeedIterator } from \"../../ChangeFeedIterator\";\nimport { Constants, copyObject, getIdFromLink, getPathFromLink, isItemResourceValid, ResourceType, StatusCodes, SubStatusCodes } from \"../../common\";\nimport { extractPartitionKeys, setPartitionKeyIfUndefined } from \"../../extractPartitionKey\";\nimport { QueryIterator } from \"../../queryIterator\";\nimport { Item } from \"./Item\";\nimport { ItemResponse } from \"./ItemResponse\";\nimport { isKeyInRange, prepareOperations, decorateBatchOperation, splitBatchBasedOnBodySize, BulkOperationType } from \"../../utils/batch\";\nimport { assertNotUndefined, isPrimitivePartitionKeyValue } from \"../../utils/typeChecks\";\nimport { hashPartitionKey } from \"../../utils/hashing/hash\";\nimport { PartitionKeyRangeCache, QueryRange } from \"../../routing\";\nimport { convertToInternalPartitionKey } from \"../../documents\";\nimport { validateChangeFeedIteratorOptions } from \"../../client/ChangeFeed/changeFeedUtils\";\nimport { DiagnosticNodeType } from \"../../diagnostics/DiagnosticNodeInternal\";\nimport { getEmptyCosmosDiagnostics, withDiagnostics, addDignosticChild } from \"../../utils/diagnostics\";\nimport { randomUUID } from \"@azure/core-util\";\nimport { readPartitionKeyDefinition } from \"../ClientUtils\";\nimport { ChangeFeedIteratorBuilder } from \"../ChangeFeed/ChangeFeedIteratorBuilder\";\nimport { TypeMarker } from \"../../encryption/enums/TypeMarker\";\nimport { EncryptionItemQueryIterator } from \"../../encryption/EncryptionItemQueryIterator\";\nimport { ErrorResponse } from \"../../request\";\n/**\n * @hidden\n */\nfunction isChangeFeedOptions(options) {\n  return options && !(isPrimitivePartitionKeyValue(options) || Array.isArray(options));\n}\n/**\n * Operations for creating new items, and reading/querying all items\n *\n * @see {@link Item} for reading, replacing, or deleting an existing container; use `.item(id)`.\n */\nexport class Items {\n  /**\n   * Create an instance of {@link Items} linked to the parent {@link Container}.\n   * @param container - The parent container.\n   * @hidden\n   */\n  constructor(container, clientContext) {\n    this.container = container;\n    this.clientContext = clientContext;\n    this.partitionKeyRangeCache = new PartitionKeyRangeCache(this.clientContext);\n  }\n  query(query, options = {}) {\n    const path = getPathFromLink(this.container.url, ResourceType.item);\n    const id = getIdFromLink(this.container.url);\n    const fetchFunction = async (diagnosticNode, innerOptions, correlatedActivityId) => {\n      const response = await this.clientContext.queryFeed({\n        path,\n        resourceType: ResourceType.item,\n        resourceId: id,\n        resultFn: result => result ? result.Documents : [],\n        query,\n        options: innerOptions,\n        partitionKey: options.partitionKey,\n        diagnosticNode,\n        correlatedActivityId: correlatedActivityId\n      });\n      return response;\n    };\n    let iterator;\n    if (this.clientContext.enableEncryption) {\n      iterator = new EncryptionItemQueryIterator(this.clientContext, query, options, fetchFunction, this.container);\n    } else {\n      iterator = new QueryIterator(this.clientContext, query, options, fetchFunction, this.container.url, ResourceType.item);\n    }\n    return iterator;\n  }\n  /**\n   * Queries all items in an encrypted container.\n   * @param queryBuilder - Query configuration for the operation. See {@link SqlQuerySpec} for more info on how to build a query on encrypted properties.\n   * @param options - Used for modifying the request (for instance, specifying the partition key).\n   * @example Read all items to array.\n   * ```typescript\n   * const queryBuilder = new EncryptionQueryBuilder(\"SELECT firstname FROM Families f WHERE f.lastName = @lastName\");\n   * queryBuilder.addStringParameter(\"@lastName\", \"Hendricks\", \"/lastname\");\n   * const queryIterator = await items.getEncryptionQueryIterator<{firstName: string}>(queryBuilder);\n   * const {result: items} = await queryIterator.fetchAll();\n   * ```\n   */\n  async getEncryptionQueryIterator(queryBuilder, options = {}) {\n    const encryptionSqlQuerySpec = queryBuilder.toEncryptionSqlQuerySpec();\n    const sqlQuerySpec = await this.buildSqlQuerySpec(encryptionSqlQuerySpec);\n    const iterator = this.query(sqlQuerySpec, options);\n    return iterator;\n  }\n  async buildSqlQuerySpec(encryptionSqlQuerySpec) {\n    let encryptionParameters = encryptionSqlQuerySpec.parameters;\n    const sqlQuerySpec = {\n      query: encryptionSqlQuerySpec.query,\n      parameters: []\n    };\n    // returns copy to avoid encryption of original parameters passed\n    encryptionParameters = copyObject(encryptionParameters);\n    for (const parameter of encryptionParameters) {\n      let value;\n      if (parameter.type !== undefined || parameter.type !== TypeMarker.Null) {\n        value = await this.container.encryptionProcessor.encryptQueryParameter(parameter.path, parameter.value, parameter.path === \"/id\", parameter.type);\n      }\n      sqlQuerySpec.parameters.push({\n        name: parameter.name,\n        value: value\n      });\n    }\n    return sqlQuerySpec;\n  }\n  readChangeFeed(partitionKeyOrChangeFeedOptions, changeFeedOptions) {\n    if (isChangeFeedOptions(partitionKeyOrChangeFeedOptions)) {\n      return this.changeFeed(partitionKeyOrChangeFeedOptions);\n    } else {\n      return this.changeFeed(partitionKeyOrChangeFeedOptions, changeFeedOptions);\n    }\n  }\n  changeFeed(partitionKeyOrChangeFeedOptions, changeFeedOptions) {\n    let partitionKey;\n    if (!changeFeedOptions && isChangeFeedOptions(partitionKeyOrChangeFeedOptions)) {\n      partitionKey = undefined;\n      changeFeedOptions = partitionKeyOrChangeFeedOptions;\n    } else if (partitionKeyOrChangeFeedOptions !== undefined && !isChangeFeedOptions(partitionKeyOrChangeFeedOptions)) {\n      partitionKey = partitionKeyOrChangeFeedOptions;\n    }\n    if (!changeFeedOptions) {\n      changeFeedOptions = {};\n    }\n    const path = getPathFromLink(this.container.url, ResourceType.item);\n    const id = getIdFromLink(this.container.url);\n    return new ChangeFeedIterator(this.clientContext, id, path, partitionKey, changeFeedOptions);\n  }\n  /**\n   * Returns an iterator to iterate over pages of changes. The iterator returned can be used to fetch changes for a single partition key, feed range or an entire container.\n   */\n  getChangeFeedIterator(changeFeedIteratorOptions) {\n    const cfOptions = changeFeedIteratorOptions !== undefined ? changeFeedIteratorOptions : {};\n    validateChangeFeedIteratorOptions(cfOptions);\n    const iterator = new ChangeFeedIteratorBuilder(cfOptions, this.clientContext, this.container, this.partitionKeyRangeCache);\n    return iterator;\n  }\n  readAll(options) {\n    return this.query(\"SELECT * from c\", options);\n  }\n  /**\n   * Create an item.\n   *\n   * Any provided type, T, is not necessarily enforced by the SDK.\n   * You may get more or less properties and it's up to your logic to enforce it.\n   *\n   * There is no set schema for JSON items. They may contain any number of custom properties.\n   *\n   * @param body - Represents the body of the item. Can contain any number of user defined properties.\n   * @param options - Used for modifying the request (for instance, specifying the partition key).\n   */\n  async create(body, options = {}) {\n    // Generate random document id if the id is missing in the payload and\n    // options.disableAutomaticIdGeneration != true\n    return withDiagnostics(async diagnosticNode => {\n      if ((body.id === undefined || body.id === \"\") && !options.disableAutomaticIdGeneration) {\n        body.id = randomUUID();\n      }\n      const partitionKeyDefinition = await readPartitionKeyDefinition(diagnosticNode, this.container);\n      let partitionKey = extractPartitionKeys(body, partitionKeyDefinition);\n      let response;\n      try {\n        if (this.clientContext.enableEncryption) {\n          await this.container.checkAndInitializeEncryption();\n          options.containerRid = this.container._rid;\n          // returns copy to avoid encryption of original body passed\n          body = copyObject(body);\n          diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsEncryptOperation);\n          const {\n            body: encryptedBody,\n            propertiesEncryptedCount\n          } = await this.container.encryptionProcessor.encrypt(body);\n          body = encryptedBody;\n          diagnosticNode.endEncryptionDiagnostics(Constants.Encryption.DiagnosticsEncryptOperation, propertiesEncryptedCount);\n          partitionKey = extractPartitionKeys(body, partitionKeyDefinition);\n        }\n        const err = {};\n        if (!isItemResourceValid(body, err)) {\n          throw err;\n        }\n        const path = getPathFromLink(this.container.url, ResourceType.item);\n        const id = getIdFromLink(this.container.url);\n        response = await this.clientContext.create({\n          body,\n          path,\n          resourceType: ResourceType.item,\n          resourceId: id,\n          diagnosticNode,\n          options,\n          partitionKey\n        });\n      } catch (error) {\n        if (this.clientContext.enableEncryption) {\n          // Todo: internally retry post policy refresh\n          await this.container.throwIfRequestNeedsARetryPostPolicyRefresh(error);\n        }\n        throw error;\n      }\n      if (this.clientContext.enableEncryption) {\n        // try block for decrypting response. This is done so that we can throw special error message in case of decryption failure\n        try {\n          diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsDecryptOperation);\n          const {\n            body: decryptedResult,\n            propertiesDecryptedCount\n          } = await this.container.encryptionProcessor.decrypt(response.result);\n          diagnosticNode.endEncryptionDiagnostics(Constants.Encryption.DiagnosticsDecryptOperation, propertiesDecryptedCount);\n          response.result = decryptedResult;\n          partitionKey = extractPartitionKeys(response.result, partitionKeyDefinition);\n        } catch (error) {\n          const decryptionError = new ErrorResponse(`Item creation was successful but response decryption failed: + ${error.message}`);\n          decryptionError.code = StatusCodes.ServiceUnavailable;\n          throw decryptionError;\n        }\n      }\n      const ref = new Item(this.container, response.result.id, this.clientContext, partitionKey);\n      return new ItemResponse(response.result, response.headers, response.code, response.substatus, ref, getEmptyCosmosDiagnostics());\n    }, this.clientContext);\n  }\n  async upsert(body, options = {}) {\n    return withDiagnostics(async diagnosticNode => {\n      // Generate random document id if the id is missing in the payload and\n      // options.disableAutomaticIdGeneration != true\n      if ((body.id === undefined || body.id === \"\") && !options.disableAutomaticIdGeneration) {\n        body.id = randomUUID();\n      }\n      const partitionKeyDefinition = await readPartitionKeyDefinition(diagnosticNode, this.container);\n      let partitionKey = extractPartitionKeys(body, partitionKeyDefinition);\n      let response;\n      try {\n        if (this.clientContext.enableEncryption) {\n          // returns copy to avoid encryption of original body passed\n          body = copyObject(body);\n          options = options || {};\n          await this.container.checkAndInitializeEncryption();\n          options.containerRid = this.container._rid;\n          diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsEncryptOperation);\n          const {\n            body: encryptedBody,\n            propertiesEncryptedCount\n          } = await this.container.encryptionProcessor.encrypt(body);\n          body = encryptedBody;\n          diagnosticNode.endEncryptionDiagnostics(Constants.Encryption.DiagnosticsEncryptOperation, propertiesEncryptedCount);\n          partitionKey = extractPartitionKeys(body, partitionKeyDefinition);\n        }\n        const err = {};\n        if (!isItemResourceValid(body, err)) {\n          throw err;\n        }\n        const path = getPathFromLink(this.container.url, ResourceType.item);\n        const id = getIdFromLink(this.container.url);\n        response = await this.clientContext.upsert({\n          body,\n          path,\n          resourceType: ResourceType.item,\n          resourceId: id,\n          options,\n          partitionKey,\n          diagnosticNode\n        });\n      } catch (error) {\n        if (this.clientContext.enableEncryption) {\n          await this.container.throwIfRequestNeedsARetryPostPolicyRefresh(error);\n        }\n        throw error;\n      }\n      if (this.clientContext.enableEncryption) {\n        try {\n          // try block for decrypting response. This is done so that we can throw special error message in case of decryption failure\n          diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsDecryptOperation);\n          const {\n            body: decryptedResult,\n            propertiesDecryptedCount\n          } = await this.container.encryptionProcessor.decrypt(response.result);\n          diagnosticNode.endEncryptionDiagnostics(Constants.Encryption.DiagnosticsDecryptOperation, propertiesDecryptedCount);\n          response.result = decryptedResult;\n          partitionKey = extractPartitionKeys(response.result, partitionKeyDefinition);\n        } catch (error) {\n          const decryptionError = new ErrorResponse(`Item upsert was successful but response decryption failed: + ${error.message}`);\n          decryptionError.code = StatusCodes.ServiceUnavailable;\n          throw decryptionError;\n        }\n      }\n      const ref = new Item(this.container, response.result.id, this.clientContext, partitionKey);\n      return new ItemResponse(response.result, response.headers, response.code, response.substatus, ref, getEmptyCosmosDiagnostics());\n    }, this.clientContext);\n  }\n  /**\n   * Execute bulk operations on items.\n   *\n   * Bulk takes an array of Operations which are typed based on what the operation does.\n   * The choices are: Create, Upsert, Read, Replace, and Delete\n   *\n   * Usage example:\n   * ```typescript\n   * // partitionKey is optional at the top level if present in the resourceBody\n   * const operations: OperationInput[] = [\n   *    {\n   *       operationType: \"Create\",\n   *       resourceBody: { id: \"doc1\", name: \"sample\", key: \"A\" }\n   *    },\n   *    {\n   *       operationType: \"Upsert\",\n   *       partitionKey: 'A',\n   *       resourceBody: { id: \"doc2\", name: \"other\", key: \"A\" }\n   *    }\n   * ]\n   *\n   * await database.container.items.bulk(operations)\n   * ```\n   *\n   * @param operations - List of operations. Limit 100\n   * @param bulkOptions - Optional options object to modify bulk behavior. Pass \\{ continueOnError: false \\} to stop executing operations when one fails. (Defaults to true)\n   * @param options - Used for modifying the request.\n   */\n  async bulk(operations, bulkOptions, options) {\n    return withDiagnostics(async diagnosticNode => {\n      const partitionKeyRanges = (await this.partitionKeyRangeCache.onCollectionRoutingMap(this.container.url, diagnosticNode)).getOrderedParitionKeyRanges();\n      const partitionKeyDefinition = await readPartitionKeyDefinition(diagnosticNode, this.container);\n      if (this.clientContext.enableEncryption) {\n        // returns copy to avoid encryption of original operations body passed\n        operations = copyObject(operations);\n        options = options || {};\n        await this.container.checkAndInitializeEncryption();\n        options.containerRid = this.container._rid;\n        diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsEncryptOperation);\n        const {\n          operations: encryptedOperations,\n          totalPropertiesEncryptedCount\n        } = await this.bulkBatchEncryptionHelper(operations);\n        operations = encryptedOperations;\n        diagnosticNode.endEncryptionDiagnostics(Constants.Encryption.DiagnosticsEncryptOperation, totalPropertiesEncryptedCount);\n      }\n      const batches = partitionKeyRanges.map(keyRange => {\n        return {\n          min: keyRange.minInclusive,\n          max: keyRange.maxExclusive,\n          rangeId: keyRange.id,\n          indexes: [],\n          operations: []\n        };\n      });\n      this.groupOperationsBasedOnPartitionKey(operations, partitionKeyDefinition, options, batches);\n      const path = getPathFromLink(this.container.url, ResourceType.item);\n      const orderedResponses = [];\n      // split batches based on cumulative size of operations\n      const batchMap = batches.filter(batch => batch.operations.length).flatMap(batch => splitBatchBasedOnBodySize(batch));\n      await Promise.all(this.executeBatchOperations(batchMap, path, bulkOptions, options, diagnosticNode, orderedResponses, partitionKeyDefinition));\n      const response = orderedResponses;\n      response.diagnostics = diagnosticNode.toDiagnostic(this.clientContext.getClientConfig());\n      return response;\n    }, this.clientContext);\n  }\n  executeBatchOperations(batchMap, path, bulkOptions, options, diagnosticNode, orderedResponses, partitionKeyDefinition) {\n    return batchMap.map(async batch => {\n      if (batch.operations.length > 100) {\n        throw new Error(\"Cannot run bulk request with more than 100 operations per partition\");\n      }\n      let response;\n      try {\n        response = await addDignosticChild(async childNode => this.clientContext.bulk({\n          body: batch.operations,\n          partitionKeyRangeId: batch.rangeId,\n          path,\n          resourceId: this.container.url,\n          bulkOptions,\n          options,\n          diagnosticNode: childNode\n        }), diagnosticNode, DiagnosticNodeType.BATCH_REQUEST);\n        response.result.forEach((operationResponse, index) => {\n          orderedResponses[batch.indexes[index]] = operationResponse;\n        });\n      } catch (err) {\n        if (this.clientContext.enableEncryption) {\n          await this.container.throwIfRequestNeedsARetryPostPolicyRefresh(err);\n        }\n        // In the case of 410 errors, we need to recompute the partition key ranges\n        // and redo the batch request, however, 410 errors occur for unsupported\n        // partition key types as well since we don't support them, so for now we throw\n        if (err.code === StatusCodes.Gone) {\n          const isPartitionSplit = err.substatus === SubStatusCodes.PartitionKeyRangeGone || err.substatus === SubStatusCodes.CompletingSplit;\n          if (isPartitionSplit) {\n            const queryRange = new QueryRange(batch.min, batch.max, true, false);\n            const overlappingRanges = await this.partitionKeyRangeCache.getOverlappingRanges(this.container.url, queryRange, diagnosticNode, true);\n            if (overlappingRanges.length < 1) {\n              throw new Error(\"Partition split/merge detected but no overlapping ranges found.\");\n            }\n            // Handles both merge (overlappingRanges.length === 1) and split (overlappingRanges.length > 1) cases.\n            if (overlappingRanges.length >= 1) {\n              // const splitBatches: Batch[] = [];\n              const newBatches = this.createNewBatches(overlappingRanges, batch, partitionKeyDefinition);\n              await Promise.all(this.executeBatchOperations(newBatches, path, bulkOptions, options, diagnosticNode, orderedResponses, partitionKeyDefinition));\n            }\n          } else {\n            throw new Error(\"Partition key error. An operation has an unsupported partitionKey type\" + err.message);\n          }\n        } else {\n          throw new Error(`Bulk request errored with: ${err.message}`);\n        }\n      }\n      if (response) {\n        try {\n          if (this.clientContext.enableEncryption) {\n            diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsDecryptOperation);\n            let count = 0;\n            for (const result of response.result) {\n              if (result.resourceBody) {\n                const {\n                  body,\n                  propertiesDecryptedCount\n                } = await this.container.encryptionProcessor.decrypt(result.resourceBody);\n                result.resourceBody = body;\n                count += propertiesDecryptedCount;\n              }\n            }\n            diagnosticNode.endEncryptionDiagnostics(Constants.Encryption.DiagnosticsDecryptOperation, count);\n          }\n        } catch (error) {\n          const decryptionError = new ErrorResponse(`Batch response was received but response decryption failed: + ${error.message}`);\n          decryptionError.code = StatusCodes.ServiceUnavailable;\n          throw decryptionError;\n        }\n        response.result.forEach((operationResponse, index) => {\n          orderedResponses[batch.indexes[index]] = operationResponse;\n        });\n      }\n    });\n  }\n  /**\n   * Function to create new batches based of partition key Ranges.\n   *\n   * @param overlappingRanges - Overlapping partition key ranges.\n   * @param batch - Batch to be split.\n   * @param partitionKeyDefinition - PartitionKey definition of container.\n   * @returns Array of new batches.\n   */\n  createNewBatches(overlappingRanges, batch, partitionKeyDefinition) {\n    const newBatches = overlappingRanges.map(keyRange => {\n      return {\n        min: keyRange.minInclusive,\n        max: keyRange.maxExclusive,\n        rangeId: keyRange.id,\n        indexes: [],\n        operations: []\n      };\n    });\n    let indexValue = 0;\n    batch.operations.forEach(operation => {\n      const partitionKey = JSON.parse(operation.partitionKey);\n      const hashed = hashPartitionKey(assertNotUndefined(partitionKey, \"undefined value for PartitionKey is not expected during grouping of bulk operations.\"), partitionKeyDefinition);\n      const batchForKey = assertNotUndefined(newBatches.find(newBatch => {\n        return isKeyInRange(newBatch.min, newBatch.max, hashed);\n      }), \"No suitable Batch found.\");\n      batchForKey.operations.push(operation);\n      batchForKey.indexes.push(batch.indexes[indexValue]);\n      indexValue++;\n    });\n    return newBatches;\n  }\n  /**\n   * Function to create batches based of partition key Ranges.\n   * @param operations - operations to group\n   * @param partitionDefinition - PartitionKey definition of container.\n   * @param options - Request options for bulk request.\n   * @param batches - Groups to be filled with operations.\n   */\n  groupOperationsBasedOnPartitionKey(operations, partitionDefinition, options, batches) {\n    operations.forEach((operationInput, index) => {\n      const {\n        operation,\n        partitionKey\n      } = prepareOperations(operationInput, partitionDefinition, options);\n      const hashed = hashPartitionKey(assertNotUndefined(partitionKey, \"undefined value for PartitionKey is not expected during grouping of bulk operations.\"), partitionDefinition);\n      const batchForKey = assertNotUndefined(batches.find(batch => {\n        return isKeyInRange(batch.min, batch.max, hashed);\n      }), \"No suitable Batch found.\");\n      batchForKey.operations.push(operation);\n      batchForKey.indexes.push(index);\n    });\n  }\n  /**\n   * Execute transactional batch operations on items.\n   *\n   * Batch takes an array of Operations which are typed based on what the operation does. Batch is transactional and will rollback all operations if one fails.\n   * The choices are: Create, Upsert, Read, Replace, and Delete\n   *\n   * Usage example:\n   * ```typescript\n   * // The partitionKey is a required second argument. If it’s undefined, it defaults to the expected partition key format.\n   * const operations: OperationInput[] = [\n   *    {\n   *       operationType: \"Create\",\n   *       resourceBody: { id: \"doc1\", name: \"sample\", key: \"A\" }\n   *    },\n   *    {\n   *       operationType: \"Upsert\",\n   *       resourceBody: { id: \"doc2\", name: \"other\", key: \"A\" }\n   *    }\n   * ]\n   *\n   * await database.container.items.batch(operations, \"A\")\n   * ```\n   *\n   * @param operations - List of operations. Limit 100\n   * @param options - Used for modifying the request\n   */\n  async batch(operations, partitionKey, options) {\n    return withDiagnostics(async diagnosticNode => {\n      operations.map(operation => decorateBatchOperation(operation, options));\n      partitionKey = await setPartitionKeyIfUndefined(diagnosticNode, this.container, partitionKey);\n      const path = getPathFromLink(this.container.url, ResourceType.item);\n      if (operations.length > 100) {\n        throw new Error(\"Cannot run batch request with more than 100 operations per partition\");\n      }\n      let response;\n      try {\n        if (this.clientContext.enableEncryption) {\n          // returns copy to avoid encryption of original operations body passed\n          operations = copyObject(operations);\n          options = options || {};\n          await this.container.checkAndInitializeEncryption();\n          options.containerRid = this.container._rid;\n          let count = 0;\n          diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsEncryptOperation);\n          if (partitionKey) {\n            const partitionKeyInternal = convertToInternalPartitionKey(partitionKey);\n            const {\n              partitionKeyList,\n              encryptedCount\n            } = await this.container.encryptionProcessor.getEncryptedPartitionKeyValue(partitionKeyInternal);\n            partitionKey = partitionKeyList;\n            count += encryptedCount;\n          }\n          const {\n            operations: encryptedOperations,\n            totalPropertiesEncryptedCount\n          } = await this.bulkBatchEncryptionHelper(operations);\n          operations = encryptedOperations;\n          count += totalPropertiesEncryptedCount;\n          diagnosticNode.endEncryptionDiagnostics(Constants.Encryption.DiagnosticsEncryptOperation, count);\n        }\n        response = await this.clientContext.batch({\n          body: operations,\n          partitionKey,\n          path,\n          resourceId: this.container.url,\n          options,\n          diagnosticNode\n        });\n      } catch (err) {\n        if (this.clientContext.enableEncryption) {\n          await this.container.throwIfRequestNeedsARetryPostPolicyRefresh(err);\n        }\n        throw new Error(`Batch request error: ${err.message}`);\n      }\n      if (this.clientContext.enableEncryption) {\n        try {\n          diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsDecryptOperation);\n          let count = 0;\n          for (const result of response.result) {\n            if (result.resourceBody) {\n              const {\n                body,\n                propertiesDecryptedCount\n              } = await this.container.encryptionProcessor.decrypt(result.resourceBody);\n              result.resourceBody = body;\n              count += propertiesDecryptedCount;\n            }\n          }\n          diagnosticNode.endEncryptionDiagnostics(Constants.Encryption.DiagnosticsDecryptOperation, count);\n        } catch (error) {\n          const decryptionError = new ErrorResponse(`Batch response was received but response decryption failed: + ${error.message}`);\n          decryptionError.code = StatusCodes.ServiceUnavailable;\n          throw decryptionError;\n        }\n      }\n      return response;\n    }, this.clientContext);\n  }\n  async bulkBatchEncryptionHelper(operations) {\n    let totalPropertiesEncryptedCount = 0;\n    for (const operation of operations) {\n      if (Object.prototype.hasOwnProperty.call(operation, \"partitionKey\")) {\n        const partitionKeyInternal = convertToInternalPartitionKey(operation.partitionKey);\n        const {\n          partitionKeyList,\n          encryptedCount\n        } = await this.container.encryptionProcessor.getEncryptedPartitionKeyValue(partitionKeyInternal);\n        operation.partitionKey = partitionKeyList;\n        totalPropertiesEncryptedCount += encryptedCount;\n      }\n      switch (operation.operationType) {\n        case BulkOperationType.Create:\n        case BulkOperationType.Upsert:\n          {\n            const {\n              body,\n              propertiesEncryptedCount\n            } = await this.container.encryptionProcessor.encrypt(operation.resourceBody);\n            operation.resourceBody = body;\n            totalPropertiesEncryptedCount += propertiesEncryptedCount;\n            break;\n          }\n        case BulkOperationType.Read:\n        case BulkOperationType.Delete:\n          if (await this.container.encryptionProcessor.isPathEncrypted(\"/id\")) {\n            operation.id = await this.container.encryptionProcessor.getEncryptedId(operation.id);\n            totalPropertiesEncryptedCount++;\n          }\n          break;\n        case BulkOperationType.Replace:\n          {\n            if (await this.container.encryptionProcessor.isPathEncrypted(\"/id\")) {\n              operation.id = await this.container.encryptionProcessor.getEncryptedId(operation.id);\n              totalPropertiesEncryptedCount++;\n            }\n            const {\n              body,\n              propertiesEncryptedCount\n            } = await this.container.encryptionProcessor.encrypt(operation.resourceBody);\n            operation.resourceBody = body;\n            totalPropertiesEncryptedCount += propertiesEncryptedCount;\n            break;\n          }\n        case BulkOperationType.Patch:\n          {\n            if (await this.container.encryptionProcessor.isPathEncrypted(\"/id\")) {\n              operation.id = await this.container.encryptionProcessor.getEncryptedId(operation.id);\n              totalPropertiesEncryptedCount++;\n            }\n            const body = operation.resourceBody;\n            const patchRequestBody = Array.isArray(body) ? body : body.operations;\n            for (const patchOperation of patchRequestBody) {\n              if (\"value\" in patchOperation) {\n                if (this.container.encryptionProcessor.isPathEncrypted(patchOperation.path)) {\n                  patchOperation.value = await this.container.encryptionProcessor.encryptProperty(patchOperation.path, patchOperation.value);\n                  totalPropertiesEncryptedCount++;\n                }\n              }\n            }\n            break;\n          }\n      }\n    }\n    return {\n      operations,\n      totalPropertiesEncryptedCount\n    };\n  }\n}","map":{"version":3,"names":["ChangeFeedIterator","Constants","copyObject","getIdFromLink","getPathFromLink","isItemResourceValid","ResourceType","StatusCodes","SubStatusCodes","extractPartitionKeys","setPartitionKeyIfUndefined","QueryIterator","Item","ItemResponse","isKeyInRange","prepareOperations","decorateBatchOperation","splitBatchBasedOnBodySize","BulkOperationType","assertNotUndefined","isPrimitivePartitionKeyValue","hashPartitionKey","PartitionKeyRangeCache","QueryRange","convertToInternalPartitionKey","validateChangeFeedIteratorOptions","DiagnosticNodeType","getEmptyCosmosDiagnostics","withDiagnostics","addDignosticChild","randomUUID","readPartitionKeyDefinition","ChangeFeedIteratorBuilder","TypeMarker","EncryptionItemQueryIterator","ErrorResponse","isChangeFeedOptions","options","Array","isArray","Items","constructor","container","clientContext","partitionKeyRangeCache","query","path","url","item","id","fetchFunction","diagnosticNode","innerOptions","correlatedActivityId","response","queryFeed","resourceType","resourceId","resultFn","result","Documents","partitionKey","iterator","enableEncryption","getEncryptionQueryIterator","queryBuilder","encryptionSqlQuerySpec","toEncryptionSqlQuerySpec","sqlQuerySpec","buildSqlQuerySpec","encryptionParameters","parameters","parameter","value","type","undefined","Null","encryptionProcessor","encryptQueryParameter","push","name","readChangeFeed","partitionKeyOrChangeFeedOptions","changeFeedOptions","changeFeed","getChangeFeedIterator","changeFeedIteratorOptions","cfOptions","readAll","create","body","disableAutomaticIdGeneration","partitionKeyDefinition","checkAndInitializeEncryption","containerRid","_rid","beginEncryptionDiagnostics","Encryption","DiagnosticsEncryptOperation","encryptedBody","propertiesEncryptedCount","encrypt","endEncryptionDiagnostics","err","error","throwIfRequestNeedsARetryPostPolicyRefresh","DiagnosticsDecryptOperation","decryptedResult","propertiesDecryptedCount","decrypt","decryptionError","message","code","ServiceUnavailable","ref","headers","substatus","upsert","bulk","operations","bulkOptions","partitionKeyRanges","onCollectionRoutingMap","getOrderedParitionKeyRanges","encryptedOperations","totalPropertiesEncryptedCount","bulkBatchEncryptionHelper","batches","map","keyRange","min","minInclusive","max","maxExclusive","rangeId","indexes","groupOperationsBasedOnPartitionKey","orderedResponses","batchMap","filter","batch","length","flatMap","Promise","all","executeBatchOperations","diagnostics","toDiagnostic","getClientConfig","Error","childNode","partitionKeyRangeId","BATCH_REQUEST","forEach","operationResponse","index","Gone","isPartitionSplit","PartitionKeyRangeGone","CompletingSplit","queryRange","overlappingRanges","getOverlappingRanges","newBatches","createNewBatches","count","resourceBody","indexValue","operation","JSON","parse","hashed","batchForKey","find","newBatch","partitionDefinition","operationInput","partitionKeyInternal","partitionKeyList","encryptedCount","getEncryptedPartitionKeyValue","Object","prototype","hasOwnProperty","call","operationType","Create","Upsert","Read","Delete","isPathEncrypted","getEncryptedId","Replace","Patch","patchRequestBody","patchOperation","encryptProperty"],"sources":["/Users/eimis/test-server/Azure Hackthons/azure-cloud-architecture-game /node_modules/@azure/cosmos/src/client/Item/Items.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { ChangeFeedIterator } from \"../../ChangeFeedIterator\";\nimport type { ChangeFeedOptions } from \"../../ChangeFeedOptions\";\nimport type { ClientContext } from \"../../ClientContext\";\nimport {\n  Constants,\n  copyObject,\n  getIdFromLink,\n  getPathFromLink,\n  isItemResourceValid,\n  ResourceType,\n  StatusCodes,\n  SubStatusCodes,\n} from \"../../common\";\nimport { extractPartitionKeys, setPartitionKeyIfUndefined } from \"../../extractPartitionKey\";\nimport type { FetchFunctionCallback, SqlQuerySpec } from \"../../queryExecutionContext\";\nimport { QueryIterator } from \"../../queryIterator\";\nimport type { FeedOptions, RequestOptions, Response } from \"../../request\";\nimport type { Container, PartitionKeyRange } from \"../Container\";\nimport { Item } from \"./Item\";\nimport type { ItemDefinition } from \"./ItemDefinition\";\nimport { ItemResponse } from \"./ItemResponse\";\nimport type {\n  Batch,\n  OperationResponse,\n  OperationInput,\n  BulkOptions,\n  BulkOperationResponse,\n  Operation,\n} from \"../../utils/batch\";\nimport {\n  isKeyInRange,\n  prepareOperations,\n  decorateBatchOperation,\n  splitBatchBasedOnBodySize,\n  BulkOperationType,\n} from \"../../utils/batch\";\nimport { assertNotUndefined, isPrimitivePartitionKeyValue } from \"../../utils/typeChecks\";\nimport { hashPartitionKey } from \"../../utils/hashing/hash\";\nimport { PartitionKeyRangeCache, QueryRange } from \"../../routing\";\nimport type { PartitionKey, PartitionKeyDefinition } from \"../../documents\";\nimport { convertToInternalPartitionKey } from \"../../documents\";\nimport type {\n  ChangeFeedPullModelIterator,\n  ChangeFeedIteratorOptions,\n} from \"../../client/ChangeFeed\";\nimport { validateChangeFeedIteratorOptions } from \"../../client/ChangeFeed/changeFeedUtils\";\nimport type { DiagnosticNodeInternal } from \"../../diagnostics/DiagnosticNodeInternal\";\nimport { DiagnosticNodeType } from \"../../diagnostics/DiagnosticNodeInternal\";\nimport {\n  getEmptyCosmosDiagnostics,\n  withDiagnostics,\n  addDignosticChild,\n} from \"../../utils/diagnostics\";\nimport { randomUUID } from \"@azure/core-util\";\nimport { readPartitionKeyDefinition } from \"../ClientUtils\";\nimport { ChangeFeedIteratorBuilder } from \"../ChangeFeed/ChangeFeedIteratorBuilder\";\nimport type { EncryptionQueryBuilder } from \"../../encryption\";\nimport type { EncryptionSqlParameter } from \"../../encryption/EncryptionQueryBuilder\";\nimport type { Resource } from \"../Resource\";\nimport { TypeMarker } from \"../../encryption/enums/TypeMarker\";\nimport { EncryptionItemQueryIterator } from \"../../encryption/EncryptionItemQueryIterator\";\nimport { ErrorResponse } from \"../../request\";\n\n/**\n * @hidden\n */\nfunction isChangeFeedOptions(options: unknown): options is ChangeFeedOptions {\n  return options && !(isPrimitivePartitionKeyValue(options) || Array.isArray(options));\n}\n\n/**\n * Operations for creating new items, and reading/querying all items\n *\n * @see {@link Item} for reading, replacing, or deleting an existing container; use `.item(id)`.\n */\nexport class Items {\n  private partitionKeyRangeCache: PartitionKeyRangeCache;\n  /**\n   * Create an instance of {@link Items} linked to the parent {@link Container}.\n   * @param container - The parent container.\n   * @hidden\n   */\n  constructor(\n    public readonly container: Container,\n    private readonly clientContext: ClientContext,\n  ) {\n    this.partitionKeyRangeCache = new PartitionKeyRangeCache(this.clientContext);\n  }\n\n  /**\n   * Queries all items.\n   * @param query - Query configuration for the operation. See {@link SqlQuerySpec} for more info on how to configure a query.\n   * @param options - Used for modifying the request (for instance, specifying the partition key).\n   * @example Read all items to array.\n   * ```typescript\n   * const querySpec: SqlQuerySpec = {\n   *   query: \"SELECT * FROM Families f WHERE f.lastName = @lastName\",\n   *   parameters: [\n   *     {name: \"@lastName\", value: \"Hendricks\"}\n   *   ]\n   * };\n   * const {result: items} = await items.query(querySpec).fetchAll();\n   * ```\n   */\n\n  //\n  public query(query: string | SqlQuerySpec, options?: FeedOptions): QueryIterator<any>;\n  /**\n   * Queries all items.\n   * @param query - Query configuration for the operation. See {@link SqlQuerySpec} for more info on how to configure a query.\n   * @param options - Used for modifying the request (for instance, specifying the partition key).\n   * @example Read all items to array.\n   * ```typescript\n   * const querySpec: SqlQuerySpec = {\n   *   query: \"SELECT firstname FROM Families f WHERE f.lastName = @lastName\",\n   *   parameters: [\n   *     {name: \"@lastName\", value: \"Hendricks\"}\n   *   ]\n   * };\n   * const {result: items} = await items.query<{firstName: string}>(querySpec).fetchAll();\n   * ```\n   */\n  public query<T>(query: string | SqlQuerySpec, options?: FeedOptions): QueryIterator<T>;\n  public query<T>(query: string | SqlQuerySpec, options: FeedOptions = {}): QueryIterator<T> {\n    const path = getPathFromLink(this.container.url, ResourceType.item);\n    const id = getIdFromLink(this.container.url);\n\n    const fetchFunction: FetchFunctionCallback = async (\n      diagnosticNode: DiagnosticNodeInternal,\n      innerOptions: FeedOptions,\n      correlatedActivityId: string,\n    ) => {\n      const response = await this.clientContext.queryFeed({\n        path,\n        resourceType: ResourceType.item,\n        resourceId: id,\n        resultFn: (result) => (result ? result.Documents : []),\n        query,\n        options: innerOptions,\n        partitionKey: options.partitionKey,\n        diagnosticNode,\n        correlatedActivityId: correlatedActivityId,\n      });\n      return response;\n    };\n    let iterator: QueryIterator<T>;\n    if (this.clientContext.enableEncryption) {\n      iterator = new EncryptionItemQueryIterator(\n        this.clientContext,\n        query,\n        options,\n        fetchFunction,\n        this.container,\n      );\n    } else {\n      iterator = new QueryIterator<T>(\n        this.clientContext,\n        query,\n        options,\n        fetchFunction,\n        this.container.url,\n        ResourceType.item,\n      );\n    }\n    return iterator;\n  }\n  /**\n   * Queries all items in an encrypted container.\n   * @param queryBuilder - Query configuration for the operation. See {@link SqlQuerySpec} for more info on how to build a query on encrypted properties.\n   * @param options - Used for modifying the request (for instance, specifying the partition key).\n   * @example Read all items to array.\n   * ```typescript\n   * const queryBuilder = new EncryptionQueryBuilder(\"SELECT firstname FROM Families f WHERE f.lastName = @lastName\");\n   * queryBuilder.addStringParameter(\"@lastName\", \"Hendricks\", \"/lastname\");\n   * const queryIterator = await items.getEncryptionQueryIterator<{firstName: string}>(queryBuilder);\n   * const {result: items} = await queryIterator.fetchAll();\n   * ```\n   */\n  public async getEncryptionQueryIterator(\n    queryBuilder: EncryptionQueryBuilder,\n    options: FeedOptions = {},\n  ): Promise<QueryIterator<ItemDefinition>> {\n    const encryptionSqlQuerySpec = queryBuilder.toEncryptionSqlQuerySpec();\n    const sqlQuerySpec = await this.buildSqlQuerySpec(encryptionSqlQuerySpec);\n    const iterator = this.query<ItemDefinition>(sqlQuerySpec, options);\n    return iterator;\n  }\n\n  private async buildSqlQuerySpec(encryptionSqlQuerySpec: SqlQuerySpec): Promise<SqlQuerySpec> {\n    let encryptionParameters = encryptionSqlQuerySpec.parameters as EncryptionSqlParameter[];\n    const sqlQuerySpec: SqlQuerySpec = {\n      query: encryptionSqlQuerySpec.query,\n      parameters: [],\n    };\n    // returns copy to avoid encryption of original parameters passed\n    encryptionParameters = copyObject(encryptionParameters);\n    for (const parameter of encryptionParameters) {\n      let value: any;\n      if (parameter.type !== undefined || parameter.type !== TypeMarker.Null) {\n        value = await this.container.encryptionProcessor.encryptQueryParameter(\n          parameter.path,\n          parameter.value,\n          parameter.path === \"/id\",\n          parameter.type,\n        );\n      }\n      sqlQuerySpec.parameters.push({ name: parameter.name, value: value });\n    }\n    return sqlQuerySpec;\n  }\n\n  /**\n   * Create a `ChangeFeedIterator` to iterate over pages of changes\n   *\n   * @deprecated Use `getChangeFeedIterator` instead.\n   *\n   * @example Read from the beginning of the change feed.\n   * ```javascript\n   * const iterator = items.readChangeFeed({ startFromBeginning: true });\n   * const firstPage = await iterator.fetchNext();\n   * const firstPageResults = firstPage.result\n   * const secondPage = await iterator.fetchNext();\n   * ```\n   */\n  public readChangeFeed(\n    partitionKey: PartitionKey,\n    changeFeedOptions?: ChangeFeedOptions,\n  ): ChangeFeedIterator<any>;\n  /**\n   * Create a `ChangeFeedIterator` to iterate over pages of changes\n   * @deprecated Use `getChangeFeedIterator` instead.\n   *\n   */\n  public readChangeFeed(changeFeedOptions?: ChangeFeedOptions): ChangeFeedIterator<any>;\n  /**\n   * Create a `ChangeFeedIterator` to iterate over pages of changes\n   * @deprecated Use `getChangeFeedIterator` instead.\n   */\n  public readChangeFeed<T>(\n    partitionKey: PartitionKey,\n    changeFeedOptions?: ChangeFeedOptions,\n  ): ChangeFeedIterator<T>;\n  /**\n   * Create a `ChangeFeedIterator` to iterate over pages of changes\n   * @deprecated Use `getChangeFeedIterator` instead.\n   */\n  public readChangeFeed<T>(changeFeedOptions?: ChangeFeedOptions): ChangeFeedIterator<T>;\n  public readChangeFeed<T>(\n    partitionKeyOrChangeFeedOptions?: PartitionKey | ChangeFeedOptions,\n    changeFeedOptions?: ChangeFeedOptions,\n  ): ChangeFeedIterator<T> {\n    if (isChangeFeedOptions(partitionKeyOrChangeFeedOptions)) {\n      return this.changeFeed(partitionKeyOrChangeFeedOptions);\n    } else {\n      return this.changeFeed(partitionKeyOrChangeFeedOptions, changeFeedOptions);\n    }\n  }\n\n  /**\n   * Create a `ChangeFeedIterator` to iterate over pages of changes\n   * @deprecated Use `getChangeFeedIterator` instead.\n   * @example Read from the beginning of the change feed.\n   * ```javascript\n   * const iterator = items.readChangeFeed({ startFromBeginning: true });\n   * const firstPage = await iterator.fetchNext();\n   * const firstPageResults = firstPage.result\n   * const secondPage = await iterator.fetchNext();\n   * ```\n   */\n  public changeFeed(\n    partitionKey: PartitionKey,\n    changeFeedOptions?: ChangeFeedOptions,\n  ): ChangeFeedIterator<any>;\n  /**\n   * Create a `ChangeFeedIterator` to iterate over pages of changes\n   * @deprecated Use `getChangeFeedIterator` instead.\n   */\n  public changeFeed(changeFeedOptions?: ChangeFeedOptions): ChangeFeedIterator<any>;\n  /**\n   * Create a `ChangeFeedIterator` to iterate over pages of changes\n   * @deprecated Use `getChangeFeedIterator` instead.\n   */\n  public changeFeed<T>(\n    partitionKey: PartitionKey,\n    changeFeedOptions?: ChangeFeedOptions,\n  ): ChangeFeedIterator<T>;\n  /**\n   * Create a `ChangeFeedIterator` to iterate over pages of changes\n   * @deprecated Use `getChangeFeedIterator` instead.\n   */\n  public changeFeed<T>(changeFeedOptions?: ChangeFeedOptions): ChangeFeedIterator<T>;\n  public changeFeed<T>(\n    partitionKeyOrChangeFeedOptions?: PartitionKey | ChangeFeedOptions,\n    changeFeedOptions?: ChangeFeedOptions,\n  ): ChangeFeedIterator<T> {\n    let partitionKey: PartitionKey;\n    if (!changeFeedOptions && isChangeFeedOptions(partitionKeyOrChangeFeedOptions)) {\n      partitionKey = undefined;\n      changeFeedOptions = partitionKeyOrChangeFeedOptions;\n    } else if (\n      partitionKeyOrChangeFeedOptions !== undefined &&\n      !isChangeFeedOptions(partitionKeyOrChangeFeedOptions)\n    ) {\n      partitionKey = partitionKeyOrChangeFeedOptions;\n    }\n\n    if (!changeFeedOptions) {\n      changeFeedOptions = {};\n    }\n\n    const path = getPathFromLink(this.container.url, ResourceType.item);\n    const id = getIdFromLink(this.container.url);\n    return new ChangeFeedIterator<T>(this.clientContext, id, path, partitionKey, changeFeedOptions);\n  }\n\n  /**\n   * Returns an iterator to iterate over pages of changes. The iterator returned can be used to fetch changes for a single partition key, feed range or an entire container.\n   */\n  public getChangeFeedIterator<T>(\n    changeFeedIteratorOptions?: ChangeFeedIteratorOptions,\n  ): ChangeFeedPullModelIterator<T> {\n    const cfOptions = changeFeedIteratorOptions !== undefined ? changeFeedIteratorOptions : {};\n    validateChangeFeedIteratorOptions(cfOptions);\n    const iterator = new ChangeFeedIteratorBuilder<T>(\n      cfOptions,\n      this.clientContext,\n      this.container,\n      this.partitionKeyRangeCache,\n    );\n    return iterator;\n  }\n\n  /**\n   * Read all items.\n   *\n   * There is no set schema for JSON items. They may contain any number of custom properties.\n   *\n   * @param options - Used for modifying the request (for instance, specifying the partition key).\n   * @example Read all items to array.\n   * ```typescript\n   * const {body: containerList} = await items.readAll().fetchAll();\n   * ```\n   */\n  public readAll(options?: FeedOptions): QueryIterator<ItemDefinition>;\n  /**\n   * Read all items.\n   *\n   * Any provided type, T, is not necessarily enforced by the SDK.\n   * You may get more or less properties and it's up to your logic to enforce it.\n   *\n   * There is no set schema for JSON items. They may contain any number of custom properties.\n   *\n   * @param options - Used for modifying the request (for instance, specifying the partition key).\n   * @example Read all items to array.\n   * ```typescript\n   * const {body: containerList} = await items.readAll().fetchAll();\n   * ```\n   */\n  public readAll<T extends ItemDefinition>(options?: FeedOptions): QueryIterator<T>;\n  public readAll<T extends ItemDefinition>(options?: FeedOptions): QueryIterator<T> {\n    return this.query<T>(\"SELECT * from c\", options);\n  }\n\n  /**\n   * Create an item.\n   *\n   * Any provided type, T, is not necessarily enforced by the SDK.\n   * You may get more or less properties and it's up to your logic to enforce it.\n   *\n   * There is no set schema for JSON items. They may contain any number of custom properties.\n   *\n   * @param body - Represents the body of the item. Can contain any number of user defined properties.\n   * @param options - Used for modifying the request (for instance, specifying the partition key).\n   */\n  public async create<T extends ItemDefinition = any>(\n    body: T,\n    options: RequestOptions = {},\n  ): Promise<ItemResponse<T>> {\n    // Generate random document id if the id is missing in the payload and\n    // options.disableAutomaticIdGeneration != true\n\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      if ((body.id === undefined || body.id === \"\") && !options.disableAutomaticIdGeneration) {\n        body.id = randomUUID();\n      }\n      const partitionKeyDefinition = await readPartitionKeyDefinition(\n        diagnosticNode,\n        this.container,\n      );\n      let partitionKey = extractPartitionKeys(body, partitionKeyDefinition);\n      let response: Response<T & Resource>;\n      try {\n        if (this.clientContext.enableEncryption) {\n          await this.container.checkAndInitializeEncryption();\n          options.containerRid = this.container._rid;\n          // returns copy to avoid encryption of original body passed\n          body = copyObject(body);\n          diagnosticNode.beginEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsEncryptOperation,\n          );\n          const { body: encryptedBody, propertiesEncryptedCount } =\n            await this.container.encryptionProcessor.encrypt(body);\n          body = encryptedBody;\n          diagnosticNode.endEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsEncryptOperation,\n            propertiesEncryptedCount,\n          );\n\n          partitionKey = extractPartitionKeys(body, partitionKeyDefinition);\n        }\n        const err = {};\n        if (!isItemResourceValid(body, err)) {\n          throw err;\n        }\n        const path = getPathFromLink(this.container.url, ResourceType.item);\n        const id = getIdFromLink(this.container.url);\n        response = await this.clientContext.create<T>({\n          body,\n          path,\n          resourceType: ResourceType.item,\n          resourceId: id,\n          diagnosticNode,\n          options,\n          partitionKey,\n        });\n      } catch (error: any) {\n        if (this.clientContext.enableEncryption) {\n          // Todo: internally retry post policy refresh\n          await this.container.throwIfRequestNeedsARetryPostPolicyRefresh(error);\n        }\n        throw error;\n      }\n\n      if (this.clientContext.enableEncryption) {\n        // try block for decrypting response. This is done so that we can throw special error message in case of decryption failure\n        try {\n          diagnosticNode.beginEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsDecryptOperation,\n          );\n          const { body: decryptedResult, propertiesDecryptedCount } =\n            await this.container.encryptionProcessor.decrypt(response.result);\n          diagnosticNode.endEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsDecryptOperation,\n            propertiesDecryptedCount,\n          );\n          response.result = decryptedResult;\n          partitionKey = extractPartitionKeys(response.result, partitionKeyDefinition);\n        } catch (error) {\n          const decryptionError = new ErrorResponse(\n            `Item creation was successful but response decryption failed: + ${error.message}`,\n          );\n          decryptionError.code = StatusCodes.ServiceUnavailable;\n          throw decryptionError;\n        }\n      }\n      const ref = new Item(\n        this.container,\n        (response.result as any).id,\n        this.clientContext,\n        partitionKey,\n      );\n      return new ItemResponse(\n        response.result,\n        response.headers,\n        response.code,\n        response.substatus,\n        ref,\n        getEmptyCosmosDiagnostics(),\n      );\n    }, this.clientContext);\n  }\n\n  /**\n   * Upsert an item.\n   *\n   * There is no set schema for JSON items. They may contain any number of custom properties.\n   *\n   * @param body - Represents the body of the item. Can contain any number of user defined properties.\n   * @param options - Used for modifying the request (for instance, specifying the partition key).\n   */\n  public async upsert(\n    body: unknown,\n    options?: RequestOptions,\n  ): Promise<ItemResponse<ItemDefinition>>;\n  /**\n   * Upsert an item.\n   *\n   * Any provided type, T, is not necessarily enforced by the SDK.\n   * You may get more or less properties and it's up to your logic to enforce it.\n   *\n   * There is no set schema for JSON items. They may contain any number of custom properties.\n   *\n   * @param body - Represents the body of the item. Can contain any number of user defined properties.\n   * @param options - Used for modifying the request (for instance, specifying the partition key).\n   */\n  public async upsert<T extends ItemDefinition>(\n    body: T,\n    options?: RequestOptions,\n  ): Promise<ItemResponse<T>>;\n  public async upsert<T extends ItemDefinition>(\n    body: T,\n    options: RequestOptions = {},\n  ): Promise<ItemResponse<T>> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      // Generate random document id if the id is missing in the payload and\n      // options.disableAutomaticIdGeneration != true\n      if ((body.id === undefined || body.id === \"\") && !options.disableAutomaticIdGeneration) {\n        body.id = randomUUID();\n      }\n\n      const partitionKeyDefinition = await readPartitionKeyDefinition(\n        diagnosticNode,\n        this.container,\n      );\n      let partitionKey = extractPartitionKeys(body, partitionKeyDefinition);\n      let response: Response<T & Resource>;\n      try {\n        if (this.clientContext.enableEncryption) {\n          // returns copy to avoid encryption of original body passed\n          body = copyObject(body);\n          options = options || {};\n          await this.container.checkAndInitializeEncryption();\n          options.containerRid = this.container._rid;\n          diagnosticNode.beginEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsEncryptOperation,\n          );\n          const { body: encryptedBody, propertiesEncryptedCount } =\n            await this.container.encryptionProcessor.encrypt(body);\n          body = encryptedBody;\n          diagnosticNode.endEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsEncryptOperation,\n            propertiesEncryptedCount,\n          );\n          partitionKey = extractPartitionKeys(body, partitionKeyDefinition);\n        }\n\n        const err = {};\n        if (!isItemResourceValid(body, err)) {\n          throw err;\n        }\n\n        const path = getPathFromLink(this.container.url, ResourceType.item);\n        const id = getIdFromLink(this.container.url);\n        response = await this.clientContext.upsert<T>({\n          body,\n          path,\n          resourceType: ResourceType.item,\n          resourceId: id,\n          options,\n          partitionKey,\n          diagnosticNode,\n        });\n      } catch (error: any) {\n        if (this.clientContext.enableEncryption) {\n          await this.container.throwIfRequestNeedsARetryPostPolicyRefresh(error);\n        }\n        throw error;\n      }\n      if (this.clientContext.enableEncryption) {\n        try {\n          // try block for decrypting response. This is done so that we can throw special error message in case of decryption failure\n          diagnosticNode.beginEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsDecryptOperation,\n          );\n          const { body: decryptedResult, propertiesDecryptedCount } =\n            await this.container.encryptionProcessor.decrypt(response.result);\n          diagnosticNode.endEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsDecryptOperation,\n            propertiesDecryptedCount,\n          );\n          response.result = decryptedResult;\n          partitionKey = extractPartitionKeys(response.result, partitionKeyDefinition);\n        } catch (error) {\n          const decryptionError = new ErrorResponse(\n            `Item upsert was successful but response decryption failed: + ${error.message}`,\n          );\n          decryptionError.code = StatusCodes.ServiceUnavailable;\n          throw decryptionError;\n        }\n      }\n\n      const ref = new Item(\n        this.container,\n        (response.result as any).id,\n        this.clientContext,\n        partitionKey,\n      );\n      return new ItemResponse(\n        response.result,\n        response.headers,\n        response.code,\n        response.substatus,\n        ref,\n        getEmptyCosmosDiagnostics(),\n      );\n    }, this.clientContext);\n  }\n\n  /**\n   * Execute bulk operations on items.\n   *\n   * Bulk takes an array of Operations which are typed based on what the operation does.\n   * The choices are: Create, Upsert, Read, Replace, and Delete\n   *\n   * Usage example:\n   * ```typescript\n   * // partitionKey is optional at the top level if present in the resourceBody\n   * const operations: OperationInput[] = [\n   *    {\n   *       operationType: \"Create\",\n   *       resourceBody: { id: \"doc1\", name: \"sample\", key: \"A\" }\n   *    },\n   *    {\n   *       operationType: \"Upsert\",\n   *       partitionKey: 'A',\n   *       resourceBody: { id: \"doc2\", name: \"other\", key: \"A\" }\n   *    }\n   * ]\n   *\n   * await database.container.items.bulk(operations)\n   * ```\n   *\n   * @param operations - List of operations. Limit 100\n   * @param bulkOptions - Optional options object to modify bulk behavior. Pass \\{ continueOnError: false \\} to stop executing operations when one fails. (Defaults to true)\n   * @param options - Used for modifying the request.\n   */\n  public async bulk(\n    operations: OperationInput[],\n    bulkOptions?: BulkOptions,\n    options?: RequestOptions,\n  ): Promise<BulkOperationResponse> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      const partitionKeyRanges = (\n        await this.partitionKeyRangeCache.onCollectionRoutingMap(this.container.url, diagnosticNode)\n      ).getOrderedParitionKeyRanges();\n\n      const partitionKeyDefinition = await readPartitionKeyDefinition(\n        diagnosticNode,\n        this.container,\n      );\n\n      if (this.clientContext.enableEncryption) {\n        // returns copy to avoid encryption of original operations body passed\n        operations = copyObject(operations);\n        options = options || {};\n        await this.container.checkAndInitializeEncryption();\n        options.containerRid = this.container._rid;\n        diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsEncryptOperation);\n        const { operations: encryptedOperations, totalPropertiesEncryptedCount } =\n          await this.bulkBatchEncryptionHelper(operations);\n        operations = encryptedOperations;\n        diagnosticNode.endEncryptionDiagnostics(\n          Constants.Encryption.DiagnosticsEncryptOperation,\n          totalPropertiesEncryptedCount,\n        );\n      }\n\n      const batches: Batch[] = partitionKeyRanges.map((keyRange: PartitionKeyRange) => {\n        return {\n          min: keyRange.minInclusive,\n          max: keyRange.maxExclusive,\n          rangeId: keyRange.id,\n          indexes: [] as number[],\n          operations: [] as Operation[],\n        };\n      });\n\n      this.groupOperationsBasedOnPartitionKey(operations, partitionKeyDefinition, options, batches);\n\n      const path = getPathFromLink(this.container.url, ResourceType.item);\n\n      const orderedResponses: OperationResponse[] = [];\n      // split batches based on cumulative size of operations\n      const batchMap = batches\n        .filter((batch: Batch) => batch.operations.length)\n        .flatMap((batch: Batch) => splitBatchBasedOnBodySize(batch));\n\n      await Promise.all(\n        this.executeBatchOperations(\n          batchMap,\n          path,\n          bulkOptions,\n          options,\n          diagnosticNode,\n          orderedResponses,\n          partitionKeyDefinition,\n        ),\n      );\n      const response: any = orderedResponses;\n      response.diagnostics = diagnosticNode.toDiagnostic(this.clientContext.getClientConfig());\n      return response;\n    }, this.clientContext);\n  }\n\n  private executeBatchOperations(\n    batchMap: Batch[],\n    path: string,\n    bulkOptions: BulkOptions,\n    options: RequestOptions,\n    diagnosticNode: DiagnosticNodeInternal,\n    orderedResponses: OperationResponse[],\n    partitionKeyDefinition: PartitionKeyDefinition,\n  ): Promise<void>[] {\n    return batchMap.map(async (batch: Batch) => {\n      if (batch.operations.length > 100) {\n        throw new Error(\"Cannot run bulk request with more than 100 operations per partition\");\n      }\n      let response: Response<OperationResponse[]>;\n      try {\n        response = await addDignosticChild(\n          async (childNode: DiagnosticNodeInternal) =>\n            this.clientContext.bulk({\n              body: batch.operations,\n              partitionKeyRangeId: batch.rangeId,\n              path,\n              resourceId: this.container.url,\n              bulkOptions,\n              options,\n              diagnosticNode: childNode,\n            }),\n          diagnosticNode,\n          DiagnosticNodeType.BATCH_REQUEST,\n        );\n        response.result.forEach((operationResponse: OperationResponse, index: number) => {\n          orderedResponses[batch.indexes[index]] = operationResponse;\n        });\n      } catch (err: any) {\n        if (this.clientContext.enableEncryption) {\n          await this.container.throwIfRequestNeedsARetryPostPolicyRefresh(err);\n        }\n        // In the case of 410 errors, we need to recompute the partition key ranges\n        // and redo the batch request, however, 410 errors occur for unsupported\n        // partition key types as well since we don't support them, so for now we throw\n        if (err.code === StatusCodes.Gone) {\n          const isPartitionSplit =\n            err.substatus === SubStatusCodes.PartitionKeyRangeGone ||\n            err.substatus === SubStatusCodes.CompletingSplit;\n\n          if (isPartitionSplit) {\n            const queryRange = new QueryRange(batch.min, batch.max, true, false);\n            const overlappingRanges = await this.partitionKeyRangeCache.getOverlappingRanges(\n              this.container.url,\n              queryRange,\n              diagnosticNode,\n              true,\n            );\n            if (overlappingRanges.length < 1) {\n              throw new Error(\"Partition split/merge detected but no overlapping ranges found.\");\n            }\n            // Handles both merge (overlappingRanges.length === 1) and split (overlappingRanges.length > 1) cases.\n            if (overlappingRanges.length >= 1) {\n              // const splitBatches: Batch[] = [];\n              const newBatches: Batch[] = this.createNewBatches(\n                overlappingRanges,\n                batch,\n                partitionKeyDefinition,\n              );\n\n              await Promise.all(\n                this.executeBatchOperations(\n                  newBatches,\n                  path,\n                  bulkOptions,\n                  options,\n                  diagnosticNode,\n                  orderedResponses,\n                  partitionKeyDefinition,\n                ),\n              );\n            }\n          } else {\n            throw new Error(\n              \"Partition key error. An operation has an unsupported partitionKey type\" +\n                err.message,\n            );\n          }\n        } else {\n          throw new Error(`Bulk request errored with: ${err.message}`);\n        }\n      }\n      if (response) {\n        try {\n          if (this.clientContext.enableEncryption) {\n            diagnosticNode.beginEncryptionDiagnostics(\n              Constants.Encryption.DiagnosticsDecryptOperation,\n            );\n            let count = 0;\n            for (const result of response.result) {\n              if (result.resourceBody) {\n                const { body, propertiesDecryptedCount } =\n                  await this.container.encryptionProcessor.decrypt(result.resourceBody);\n                result.resourceBody = body;\n                count += propertiesDecryptedCount;\n              }\n            }\n            diagnosticNode.endEncryptionDiagnostics(\n              Constants.Encryption.DiagnosticsDecryptOperation,\n              count,\n            );\n          }\n        } catch (error) {\n          const decryptionError = new ErrorResponse(\n            `Batch response was received but response decryption failed: + ${error.message}`,\n          );\n          decryptionError.code = StatusCodes.ServiceUnavailable;\n          throw decryptionError;\n        }\n        response.result.forEach((operationResponse: OperationResponse, index: number) => {\n          orderedResponses[batch.indexes[index]] = operationResponse;\n        });\n      }\n    });\n  }\n\n  /**\n   * Function to create new batches based of partition key Ranges.\n   *\n   * @param overlappingRanges - Overlapping partition key ranges.\n   * @param batch - Batch to be split.\n   * @param partitionKeyDefinition - PartitionKey definition of container.\n   * @returns Array of new batches.\n   */\n  private createNewBatches(\n    overlappingRanges: PartitionKeyRange[],\n    batch: Batch,\n    partitionKeyDefinition: PartitionKeyDefinition,\n  ): Batch[] {\n    const newBatches: Batch[] = overlappingRanges.map((keyRange: PartitionKeyRange) => {\n      return {\n        min: keyRange.minInclusive,\n        max: keyRange.maxExclusive,\n        rangeId: keyRange.id,\n        indexes: [] as number[],\n        operations: [] as Operation[],\n      };\n    });\n    let indexValue = 0;\n    batch.operations.forEach((operation) => {\n      const partitionKey = JSON.parse(operation.partitionKey);\n      const hashed = hashPartitionKey(\n        assertNotUndefined(\n          partitionKey,\n          \"undefined value for PartitionKey is not expected during grouping of bulk operations.\",\n        ),\n        partitionKeyDefinition,\n      );\n      const batchForKey = assertNotUndefined(\n        newBatches.find((newBatch: Batch) => {\n          return isKeyInRange(newBatch.min, newBatch.max, hashed);\n        }),\n        \"No suitable Batch found.\",\n      );\n      batchForKey.operations.push(operation);\n      batchForKey.indexes.push(batch.indexes[indexValue]);\n      indexValue++;\n    });\n    return newBatches;\n  }\n\n  /**\n   * Function to create batches based of partition key Ranges.\n   * @param operations - operations to group\n   * @param partitionDefinition - PartitionKey definition of container.\n   * @param options - Request options for bulk request.\n   * @param batches - Groups to be filled with operations.\n   */\n  private groupOperationsBasedOnPartitionKey(\n    operations: OperationInput[],\n    partitionDefinition: PartitionKeyDefinition,\n    options: RequestOptions | undefined,\n    batches: Batch[],\n  ) {\n    operations.forEach((operationInput, index: number) => {\n      const { operation, partitionKey } = prepareOperations(\n        operationInput,\n        partitionDefinition,\n        options,\n      );\n      const hashed = hashPartitionKey(\n        assertNotUndefined(\n          partitionKey,\n          \"undefined value for PartitionKey is not expected during grouping of bulk operations.\",\n        ),\n        partitionDefinition,\n      );\n      const batchForKey = assertNotUndefined(\n        batches.find((batch: Batch) => {\n          return isKeyInRange(batch.min, batch.max, hashed);\n        }),\n        \"No suitable Batch found.\",\n      );\n      batchForKey.operations.push(operation);\n      batchForKey.indexes.push(index);\n    });\n  }\n\n  /**\n   * Execute transactional batch operations on items.\n   *\n   * Batch takes an array of Operations which are typed based on what the operation does. Batch is transactional and will rollback all operations if one fails.\n   * The choices are: Create, Upsert, Read, Replace, and Delete\n   *\n   * Usage example:\n   * ```typescript\n   * // The partitionKey is a required second argument. If it’s undefined, it defaults to the expected partition key format.\n   * const operations: OperationInput[] = [\n   *    {\n   *       operationType: \"Create\",\n   *       resourceBody: { id: \"doc1\", name: \"sample\", key: \"A\" }\n   *    },\n   *    {\n   *       operationType: \"Upsert\",\n   *       resourceBody: { id: \"doc2\", name: \"other\", key: \"A\" }\n   *    }\n   * ]\n   *\n   * await database.container.items.batch(operations, \"A\")\n   * ```\n   *\n   * @param operations - List of operations. Limit 100\n   * @param options - Used for modifying the request\n   */\n  public async batch(\n    operations: OperationInput[],\n    partitionKey?: PartitionKey,\n    options?: RequestOptions,\n  ): Promise<Response<OperationResponse[]>> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      operations.map((operation) => decorateBatchOperation(operation, options));\n      partitionKey = await setPartitionKeyIfUndefined(diagnosticNode, this.container, partitionKey);\n      const path = getPathFromLink(this.container.url, ResourceType.item);\n\n      if (operations.length > 100) {\n        throw new Error(\"Cannot run batch request with more than 100 operations per partition\");\n      }\n      let response: Response<OperationResponse[]>;\n      try {\n        if (this.clientContext.enableEncryption) {\n          // returns copy to avoid encryption of original operations body passed\n          operations = copyObject(operations);\n          options = options || {};\n          await this.container.checkAndInitializeEncryption();\n          options.containerRid = this.container._rid;\n          let count = 0;\n          diagnosticNode.beginEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsEncryptOperation,\n          );\n          if (partitionKey) {\n            const partitionKeyInternal = convertToInternalPartitionKey(partitionKey);\n            const { partitionKeyList, encryptedCount } =\n              await this.container.encryptionProcessor.getEncryptedPartitionKeyValue(\n                partitionKeyInternal,\n              );\n            partitionKey = partitionKeyList;\n            count += encryptedCount;\n          }\n          const { operations: encryptedOperations, totalPropertiesEncryptedCount } =\n            await this.bulkBatchEncryptionHelper(operations);\n          operations = encryptedOperations;\n          count += totalPropertiesEncryptedCount;\n          diagnosticNode.endEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsEncryptOperation,\n            count,\n          );\n        }\n\n        response = await this.clientContext.batch({\n          body: operations,\n          partitionKey,\n          path,\n          resourceId: this.container.url,\n          options,\n          diagnosticNode,\n        });\n      } catch (err: any) {\n        if (this.clientContext.enableEncryption) {\n          await this.container.throwIfRequestNeedsARetryPostPolicyRefresh(err);\n        }\n        throw new Error(`Batch request error: ${err.message}`);\n      }\n      if (this.clientContext.enableEncryption) {\n        try {\n          diagnosticNode.beginEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsDecryptOperation,\n          );\n          let count = 0;\n          for (const result of response.result) {\n            if (result.resourceBody) {\n              const { body, propertiesDecryptedCount } =\n                await this.container.encryptionProcessor.decrypt(result.resourceBody);\n              result.resourceBody = body;\n              count += propertiesDecryptedCount;\n            }\n          }\n          diagnosticNode.endEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsDecryptOperation,\n            count,\n          );\n        } catch (error) {\n          const decryptionError = new ErrorResponse(\n            `Batch response was received but response decryption failed: + ${error.message}`,\n          );\n          decryptionError.code = StatusCodes.ServiceUnavailable;\n          throw decryptionError;\n        }\n      }\n      return response;\n    }, this.clientContext);\n  }\n\n  private async bulkBatchEncryptionHelper(\n    operations: OperationInput[],\n  ): Promise<{ operations: OperationInput[]; totalPropertiesEncryptedCount: number }> {\n    let totalPropertiesEncryptedCount = 0;\n    for (const operation of operations) {\n      if (Object.prototype.hasOwnProperty.call(operation, \"partitionKey\")) {\n        const partitionKeyInternal = convertToInternalPartitionKey(operation.partitionKey);\n        const { partitionKeyList, encryptedCount } =\n          await this.container.encryptionProcessor.getEncryptedPartitionKeyValue(\n            partitionKeyInternal,\n          );\n        operation.partitionKey = partitionKeyList;\n        totalPropertiesEncryptedCount += encryptedCount;\n      }\n      switch (operation.operationType) {\n        case BulkOperationType.Create:\n        case BulkOperationType.Upsert: {\n          const { body, propertiesEncryptedCount } =\n            await this.container.encryptionProcessor.encrypt(operation.resourceBody);\n          operation.resourceBody = body;\n          totalPropertiesEncryptedCount += propertiesEncryptedCount;\n          break;\n        }\n        case BulkOperationType.Read:\n        case BulkOperationType.Delete:\n          if (await this.container.encryptionProcessor.isPathEncrypted(\"/id\")) {\n            operation.id = await this.container.encryptionProcessor.getEncryptedId(operation.id);\n            totalPropertiesEncryptedCount++;\n          }\n          break;\n        case BulkOperationType.Replace: {\n          if (await this.container.encryptionProcessor.isPathEncrypted(\"/id\")) {\n            operation.id = await this.container.encryptionProcessor.getEncryptedId(operation.id);\n            totalPropertiesEncryptedCount++;\n          }\n          const { body, propertiesEncryptedCount } =\n            await this.container.encryptionProcessor.encrypt(operation.resourceBody);\n          operation.resourceBody = body;\n          totalPropertiesEncryptedCount += propertiesEncryptedCount;\n          break;\n        }\n        case BulkOperationType.Patch: {\n          if (await this.container.encryptionProcessor.isPathEncrypted(\"/id\")) {\n            operation.id = await this.container.encryptionProcessor.getEncryptedId(operation.id);\n            totalPropertiesEncryptedCount++;\n          }\n          const body = operation.resourceBody;\n          const patchRequestBody = Array.isArray(body) ? body : body.operations;\n          for (const patchOperation of patchRequestBody) {\n            if (\"value\" in patchOperation) {\n              if (this.container.encryptionProcessor.isPathEncrypted(patchOperation.path)) {\n                patchOperation.value = await this.container.encryptionProcessor.encryptProperty(\n                  patchOperation.path,\n                  patchOperation.value,\n                );\n                totalPropertiesEncryptedCount++;\n              }\n            }\n          }\n          break;\n        }\n      }\n    }\n    return { operations, totalPropertiesEncryptedCount };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}