{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from \"tslib\";\nimport { Constants, ResourceType } from \"../common/constants\";\nimport { DiagnosticNodeInternal, DiagnosticNodeType } from \"../diagnostics/DiagnosticNodeInternal\";\nimport { QueryIterator } from \"../queryIterator\";\nimport { withDiagnostics } from \"../utils/diagnostics\";\n/**\n * @internal\n * Provides the iterator for handling encrypted items in the Azure Cosmos DB database service.\n * extends @see {@link QueryIterator}\n */\nexport class EncryptionItemQueryIterator extends QueryIterator {\n  constructor(clientContext, query, options, fetchFunctions, container) {\n    super(clientContext, query, options, fetchFunctions, container.url, ResourceType.item);\n    this.container = container;\n    this.encryptionClientContext = clientContext;\n    this.encryptionOptions = options;\n  }\n  /**\n   * Gets an async iterator that will yield results until completion.\n   */\n  getAsyncIterator() {\n    return __asyncGenerator(this, arguments, function* getAsyncIterator_1() {\n      var _a;\n      let response;\n      const diagnosticNode = new DiagnosticNodeInternal(this.encryptionClientContext.diagnosticLevel, DiagnosticNodeType.CLIENT_REQUEST_NODE, null);\n      try {\n        response = yield __await(yield* __asyncDelegator(__asyncValues(QueryIterator.prototype.getAsyncIteratorInternal.call(this, diagnosticNode))));\n      } catch (error) {\n        yield __await(this.container.throwIfRequestNeedsARetryPostPolicyRefresh(error));\n      }\n      if (((_a = response === null || response === void 0 ? void 0 : response.resources) === null || _a === void 0 ? void 0 : _a.length) > 0) {\n        let count = 0;\n        diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsDecryptOperation);\n        for (let resource of response.resources) {\n          const {\n            body,\n            propertiesDecryptedCount\n          } = yield __await(this.container.encryptionProcessor.decrypt(resource));\n          resource = body;\n          count += propertiesDecryptedCount;\n        }\n        diagnosticNode.endEncryptionDiagnostics(Constants.Encryption.DiagnosticsDecryptOperation, count);\n      }\n      yield yield __await(response);\n    });\n  }\n  /**\n   * Fetch all pages for the query and return a single FeedResponse.\n   */\n  async fetchAll() {\n    return withDiagnostics(async diagnosticNode => {\n      var _a;\n      let response;\n      try {\n        response = await QueryIterator.prototype.fetchAllInternal.call(this, diagnosticNode);\n      } catch (error) {\n        await this.container.throwIfRequestNeedsARetryPostPolicyRefresh(error);\n      }\n      if (((_a = response === null || response === void 0 ? void 0 : response.resources) === null || _a === void 0 ? void 0 : _a.length) > 0) {\n        let count = 0;\n        diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsDecryptOperation);\n        for (let resource of response.resources) {\n          const {\n            body,\n            propertiesDecryptedCount\n          } = await this.container.encryptionProcessor.decrypt(resource);\n          resource = body;\n          count += propertiesDecryptedCount;\n        }\n        diagnosticNode.endEncryptionDiagnostics(Constants.Encryption.DiagnosticsDecryptOperation, count);\n      }\n      return response;\n    }, this.encryptionClientContext);\n  }\n  /**\n   * Retrieve the next batch from the feed.\n   */\n  async fetchNext() {\n    return withDiagnostics(async diagnosticNode => {\n      var _a;\n      let response;\n      try {\n        response = await QueryIterator.prototype.fetchNextInternal.call(this, diagnosticNode);\n      } catch (error) {\n        await this.container.throwIfRequestNeedsARetryPostPolicyRefresh(error);\n      }\n      if (((_a = response === null || response === void 0 ? void 0 : response.resources) === null || _a === void 0 ? void 0 : _a.length) > 0) {\n        let count = 0;\n        diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsDecryptOperation);\n        for (let resource of response.resources) {\n          const {\n            body,\n            propertiesDecryptedCount\n          } = await this.container.encryptionProcessor.decrypt(resource);\n          resource = body;\n          count += propertiesDecryptedCount;\n        }\n        diagnosticNode.endEncryptionDiagnostics(Constants.Encryption.DiagnosticsDecryptOperation, count);\n      }\n      return response;\n    }, this.encryptionClientContext);\n  }\n  /**\n   * @internal\n   */\n  async init(diagnosticNode) {\n    // Ensure encryption is initialized and set rid in options\n    await this.container.checkAndInitializeEncryption();\n    this.encryptionOptions.containerRid = this.container._rid;\n    await QueryIterator.prototype.init.call(this, diagnosticNode);\n  }\n}","map":{"version":3,"names":["Constants","ResourceType","DiagnosticNodeInternal","DiagnosticNodeType","QueryIterator","withDiagnostics","EncryptionItemQueryIterator","constructor","clientContext","query","options","fetchFunctions","container","url","item","encryptionClientContext","encryptionOptions","getAsyncIterator","response","diagnosticNode","diagnosticLevel","CLIENT_REQUEST_NODE","__await","__asyncDelegator","__asyncValues","prototype","getAsyncIteratorInternal","call","error","throwIfRequestNeedsARetryPostPolicyRefresh","_a","resources","length","count","beginEncryptionDiagnostics","Encryption","DiagnosticsDecryptOperation","resource","body","propertiesDecryptedCount","encryptionProcessor","decrypt","endEncryptionDiagnostics","fetchAll","fetchAllInternal","fetchNext","fetchNextInternal","init","checkAndInitializeEncryption","containerRid","_rid"],"sources":["/Users/eimis/test-server/Azure Hackthons/azure-cloud-architecture-game /node_modules/@azure/cosmos/src/encryption/EncryptionItemQueryIterator.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { Container } from \"../client\";\nimport type { ClientContext } from \"../ClientContext\";\nimport { Constants, ResourceType } from \"../common/constants\";\nimport { DiagnosticNodeInternal, DiagnosticNodeType } from \"../diagnostics/DiagnosticNodeInternal\";\nimport type { SqlQuerySpec, FetchFunctionCallback } from \"../queryExecutionContext\";\nimport { QueryIterator } from \"../queryIterator\";\nimport type { FeedOptions, FeedResponse } from \"../request\";\nimport { withDiagnostics } from \"../utils/diagnostics\";\n\n/**\n * @internal\n * Provides the iterator for handling encrypted items in the Azure Cosmos DB database service.\n * extends @see {@link QueryIterator}\n */\nexport class EncryptionItemQueryIterator<Item> extends QueryIterator<Item> {\n  private container: Container;\n  private encryptionClientContext: ClientContext;\n  private encryptionOptions: FeedOptions;\n\n  constructor(\n    clientContext: ClientContext,\n    query: SqlQuerySpec | string,\n    options: FeedOptions,\n    fetchFunctions: FetchFunctionCallback | FetchFunctionCallback[],\n    container: Container,\n  ) {\n    super(clientContext, query, options, fetchFunctions, container.url, ResourceType.item);\n    this.container = container;\n    this.encryptionClientContext = clientContext;\n    this.encryptionOptions = options;\n  }\n\n  /**\n   * Gets an async iterator that will yield results until completion.\n   */\n  public override async *getAsyncIterator(): AsyncIterable<FeedResponse<Item>> {\n    let response: FeedResponse<Item>;\n    const diagnosticNode = new DiagnosticNodeInternal(\n      this.encryptionClientContext.diagnosticLevel,\n      DiagnosticNodeType.CLIENT_REQUEST_NODE,\n      null,\n    );\n    try {\n      response = yield* QueryIterator.prototype.getAsyncIteratorInternal.call(this, diagnosticNode);\n    } catch (error) {\n      await this.container.throwIfRequestNeedsARetryPostPolicyRefresh(error);\n    }\n    if (response?.resources?.length > 0) {\n      let count = 0;\n      diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsDecryptOperation);\n      for (let resource of response.resources) {\n        const { body, propertiesDecryptedCount } =\n          await this.container.encryptionProcessor.decrypt(resource);\n        resource = body;\n        count += propertiesDecryptedCount;\n      }\n      diagnosticNode.endEncryptionDiagnostics(\n        Constants.Encryption.DiagnosticsDecryptOperation,\n        count,\n      );\n    }\n    yield response;\n  }\n\n  /**\n   * Fetch all pages for the query and return a single FeedResponse.\n   */\n  public override async fetchAll(): Promise<FeedResponse<Item>> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      let response: FeedResponse<Item>;\n      try {\n        response = await QueryIterator.prototype.fetchAllInternal.call(this, diagnosticNode);\n      } catch (error) {\n        await this.container.throwIfRequestNeedsARetryPostPolicyRefresh(error);\n      }\n      if (response?.resources?.length > 0) {\n        let count = 0;\n        diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsDecryptOperation);\n        for (let resource of response.resources) {\n          const { body, propertiesDecryptedCount } =\n            await this.container.encryptionProcessor.decrypt(resource);\n          resource = body;\n          count += propertiesDecryptedCount;\n        }\n        diagnosticNode.endEncryptionDiagnostics(\n          Constants.Encryption.DiagnosticsDecryptOperation,\n          count,\n        );\n      }\n      return response;\n    }, this.encryptionClientContext);\n  }\n\n  /**\n   * Retrieve the next batch from the feed.\n   */\n  public override async fetchNext(): Promise<FeedResponse<Item>> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      let response: FeedResponse<Item>;\n      try {\n        response = await QueryIterator.prototype.fetchNextInternal.call(this, diagnosticNode);\n      } catch (error) {\n        await this.container.throwIfRequestNeedsARetryPostPolicyRefresh(error);\n      }\n      if (response?.resources?.length > 0) {\n        let count = 0;\n        diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsDecryptOperation);\n        for (let resource of response.resources) {\n          const { body, propertiesDecryptedCount } =\n            await this.container.encryptionProcessor.decrypt(resource);\n          resource = body;\n          count += propertiesDecryptedCount;\n        }\n        diagnosticNode.endEncryptionDiagnostics(\n          Constants.Encryption.DiagnosticsDecryptOperation,\n          count,\n        );\n      }\n      return response;\n    }, this.encryptionClientContext);\n  }\n  /**\n   * @internal\n   */\n  public override async init(diagnosticNode: DiagnosticNodeInternal): Promise<void> {\n    // Ensure encryption is initialized and set rid in options\n    await this.container.checkAndInitializeEncryption();\n    this.encryptionOptions.containerRid = this.container._rid;\n    await QueryIterator.prototype.init.call(this, diagnosticNode);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}