{"ast":null,"code":"import { AZURE_ICON_CATEGORIES, SERVICE_MAPPINGS } from '../services/IconResolver';\n\n// Constants\nconst AZURE_BUCKET_URL = process.env.REACT_APP_AZURE_BUCKET_URL;\nconst ICONS_BASE_PATH = process.env.REACT_APP_ICONS_BASE_PATH;\n\n/**\n * Get a random category and its icons\n * @returns {Object} Object containing category name, display name, and icons\n */\nexport const getRandomCategory = () => {\n  // Get all categories\n  const categories = Object.keys(AZURE_ICON_CATEGORIES);\n\n  // Select a random category\n  const randomCategory = categories[Math.floor(Math.random() * categories.length)];\n\n  // Format display name\n  const displayName = randomCategory.split('_').map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(' ');\n\n  // Get the category path\n  const categoryPath = AZURE_ICON_CATEGORIES[randomCategory];\n\n  // Get all icons for this category - limit to 5 for a reasonable challenge\n  const categoryIcons = getCategoryIcons(categoryPath);\n\n  // Get random icons from other categories as distractors\n  const distractorIcons = getDistractorIcons(categoryPath, 25 - categoryIcons.length);\n\n  // Combine and shuffle all icons\n  const allIcons = [...categoryIcons, ...distractorIcons].sort(() => 0.5 - Math.random());\n  return {\n    category: categoryPath,\n    displayName: displayName,\n    icons: allIcons,\n    targetIcons: categoryIcons.map(icon => icon.name)\n  };\n};\n\n/**\n * Get all icons for a specific category\n * @param {String} categoryPath The category path\n * @returns {Array} Array of icon objects\n */\nexport const getCategoryIcons = categoryPath => {\n  return Object.entries(SERVICE_MAPPINGS).filter(([_, path]) => path.includes(categoryPath)).slice(0, 5).map(([name, path]) => ({\n    name: name,\n    path: path,\n    isTarget: true\n  }));\n};\n\n/**\n * Get random icons from other categories as distractors\n * @param {String} excludeCategoryPath The category path to exclude\n * @param {Number} count Number of distractor icons to get\n * @returns {Array} Array of icon objects\n */\nexport const getDistractorIcons = (excludeCategoryPath, count) => {\n  // Get icons from other categories\n  const otherIcons = Object.entries(SERVICE_MAPPINGS).filter(([_, path]) => !path.includes(excludeCategoryPath)).map(([name, path]) => ({\n    name: name,\n    path: path,\n    isTarget: false\n  }));\n\n  // Shuffle and take the requested number\n  return otherIcons.sort(() => 0.5 - Math.random()).slice(0, count);\n};\n\n/**\n * Check if the selected icons match the target icons\n * @param {Array} selectedIcons Array of selected icon names\n * @param {Array} targetIcons Array of target icon names\n * @returns {Boolean} True if selections match targets\n */\nexport const checkSelectionComplete = (selectedIcons, targetIcons) => {\n  // Check if all target icons are selected (and no extras)\n  return targetIcons.every(icon => selectedIcons.includes(icon)) && selectedIcons.every(icon => targetIcons.includes(icon));\n};","map":{"version":3,"names":["AZURE_ICON_CATEGORIES","SERVICE_MAPPINGS","AZURE_BUCKET_URL","process","env","REACT_APP_AZURE_BUCKET_URL","ICONS_BASE_PATH","REACT_APP_ICONS_BASE_PATH","getRandomCategory","categories","Object","keys","randomCategory","Math","floor","random","length","displayName","split","map","word","charAt","toUpperCase","slice","toLowerCase","join","categoryPath","categoryIcons","getCategoryIcons","distractorIcons","getDistractorIcons","allIcons","sort","category","icons","targetIcons","icon","name","entries","filter","_","path","includes","isTarget","excludeCategoryPath","count","otherIcons","checkSelectionComplete","selectedIcons","every"],"sources":["/Users/eimis/test-server/Azure Hackthons/azure-cloud-architecture-game /src/utils/categorySelectionUtils.js"],"sourcesContent":["import { AZURE_ICON_CATEGORIES, SERVICE_MAPPINGS } from '../services/IconResolver';\n\n// Constants\nconst AZURE_BUCKET_URL = process.env.REACT_APP_AZURE_BUCKET_URL;\nconst ICONS_BASE_PATH = process.env.REACT_APP_ICONS_BASE_PATH;\n\n/**\n * Get a random category and its icons\n * @returns {Object} Object containing category name, display name, and icons\n */\nexport const getRandomCategory = () => {\n  // Get all categories\n  const categories = Object.keys(AZURE_ICON_CATEGORIES);\n  \n  // Select a random category\n  const randomCategory = categories[Math.floor(Math.random() * categories.length)];\n  \n  // Format display name\n  const displayName = randomCategory.split('_')\n    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n    .join(' ');\n  \n  // Get the category path\n  const categoryPath = AZURE_ICON_CATEGORIES[randomCategory];\n  \n  // Get all icons for this category - limit to 5 for a reasonable challenge\n  const categoryIcons = getCategoryIcons(categoryPath);\n  \n  // Get random icons from other categories as distractors\n  const distractorIcons = getDistractorIcons(categoryPath, 25 - categoryIcons.length);\n  \n  // Combine and shuffle all icons\n  const allIcons = [...categoryIcons, ...distractorIcons].sort(() => 0.5 - Math.random());\n  \n  return {\n    category: categoryPath,\n    displayName: displayName,\n    icons: allIcons,\n    targetIcons: categoryIcons.map(icon => icon.name)\n  };\n};\n\n/**\n * Get all icons for a specific category\n * @param {String} categoryPath The category path\n * @returns {Array} Array of icon objects\n */\nexport const getCategoryIcons = (categoryPath) => {\n  return Object.entries(SERVICE_MAPPINGS)\n    .filter(([_, path]) => path.includes(categoryPath))\n    .slice(0, 5)\n    .map(([name, path]) => ({\n      name: name,\n      path: path,\n      isTarget: true\n    }));\n};\n\n/**\n * Get random icons from other categories as distractors\n * @param {String} excludeCategoryPath The category path to exclude\n * @param {Number} count Number of distractor icons to get\n * @returns {Array} Array of icon objects\n */\nexport const getDistractorIcons = (excludeCategoryPath, count) => {\n  // Get icons from other categories\n  const otherIcons = Object.entries(SERVICE_MAPPINGS)\n    .filter(([_, path]) => !path.includes(excludeCategoryPath))\n    .map(([name, path]) => ({\n      name: name,\n      path: path,\n      isTarget: false\n    }));\n  \n  // Shuffle and take the requested number\n  return otherIcons\n    .sort(() => 0.5 - Math.random())\n    .slice(0, count);\n};\n\n/**\n * Check if the selected icons match the target icons\n * @param {Array} selectedIcons Array of selected icon names\n * @param {Array} targetIcons Array of target icon names\n * @returns {Boolean} True if selections match targets\n */\nexport const checkSelectionComplete = (selectedIcons, targetIcons) => {\n  // Check if all target icons are selected (and no extras)\n  return (\n    targetIcons.every(icon => selectedIcons.includes(icon)) && \n    selectedIcons.every(icon => targetIcons.includes(icon))\n  );\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}