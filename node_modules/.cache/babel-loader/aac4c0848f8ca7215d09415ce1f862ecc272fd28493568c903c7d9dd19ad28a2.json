{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { KnownKeyOperations } from \"./keysModels.js\";\nimport { RemoteCryptographyProvider } from \"./cryptography/remoteCryptographyProvider.js\";\nimport { randomBytes } from \"./cryptography/crypto.js\";\nimport { RsaCryptographyProvider } from \"./cryptography/rsaCryptographyProvider.js\";\nimport { AesCryptographyProvider } from \"./cryptography/aesCryptographyProvider.js\";\nimport { tracingClient } from \"./tracing.js\";\nimport { isRestError } from \"@azure/core-rest-pipeline\";\nimport { logger } from \"./log.js\";\n/**\n * A client used to perform cryptographic operations on an Azure Key vault key\n * or a local {@link JsonWebKey}.\n */\nexport class CryptographyClient {\n  /**\n   * Internal constructor implementation for either local or Key Vault backed keys.\n   * @param key - The key to use during cryptography tasks.\n   * @param credential - Teh credential to use when constructing a Key Vault Cryptography client.\n   */\n  constructor(key, credential, pipelineOptions = {}) {\n    if (typeof key === \"string\") {\n      // Key URL for remote-local operations.\n      this.key = {\n        kind: \"identifier\",\n        value: key\n      };\n      this.remoteProvider = new RemoteCryptographyProvider(key, credential, pipelineOptions);\n    } else if (\"name\" in key) {\n      // KeyVault key for remote-local operations.\n      this.key = {\n        kind: \"KeyVaultKey\",\n        value: key\n      };\n      this.remoteProvider = new RemoteCryptographyProvider(key, credential, pipelineOptions);\n    } else {\n      // JsonWebKey for local-only operations.\n      this.key = {\n        kind: \"JsonWebKey\",\n        value: key\n      };\n    }\n  }\n  /**\n   * The base URL to the vault. If a local {@link JsonWebKey} is used vaultUrl will be empty.\n   */\n  get vaultUrl() {\n    var _a;\n    return ((_a = this.remoteProvider) === null || _a === void 0 ? void 0 : _a.vaultUrl) || \"\";\n  }\n  /**\n   * The ID of the key used to perform cryptographic operations for the client.\n   */\n  get keyID() {\n    if (this.key.kind === \"identifier\" || this.key.kind === \"remoteOnlyIdentifier\") {\n      return this.key.value;\n    } else if (this.key.kind === \"KeyVaultKey\") {\n      return this.key.value.id;\n    } else {\n      return this.key.value.kid;\n    }\n  }\n  encrypt(...args) {\n    const [parameters, options] = this.disambiguateEncryptArguments(args);\n    return tracingClient.withSpan(\"CryptographyClient.encrypt\", options, async updatedOptions => {\n      this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.Encrypt);\n      this.initializeIV(parameters);\n      const provider = await this.getProvider(\"encrypt\", parameters.algorithm, updatedOptions);\n      try {\n        return provider.encrypt(parameters, updatedOptions);\n      } catch (error) {\n        if (this.remoteProvider) {\n          return this.remoteProvider.encrypt(parameters, updatedOptions);\n        }\n        throw error;\n      }\n    });\n  }\n  initializeIV(parameters) {\n    // For AES-GCM the service **must** generate the IV, so we only populate it for AES-CBC\n    const algorithmsRequiringIV = [\"A128CBC\", \"A128CBCPAD\", \"A192CBC\", \"A192CBCPAD\", \"A256CBC\", \"A256CBCPAD\"];\n    if (parameters.algorithm in algorithmsRequiringIV) {\n      try {\n        const cbcParams = parameters;\n        if (!cbcParams.iv) {\n          cbcParams.iv = randomBytes(16);\n        }\n      } catch (e) {\n        throw new Error(`Unable to initialize IV for algorithm ${parameters.algorithm}. You may pass a valid IV to avoid this error. Error: ${e.message}`);\n      }\n    }\n  }\n  /**\n   * Standardizes the arguments of multiple overloads into a single shape.\n   * @param args - The encrypt arguments\n   */\n  disambiguateEncryptArguments(args) {\n    if (typeof args[0] === \"string\") {\n      // Sample shape: [\"RSA1_5\", buffer, options]\n      return [{\n        algorithm: args[0],\n        plaintext: args[1]\n      }, args[2] || {}];\n    } else {\n      // Sample shape: [{ algorithm: \"RSA1_5\", plaintext: buffer }, options]\n      return [args[0], args[1] || {}];\n    }\n  }\n  decrypt(...args) {\n    const [parameters, options] = this.disambiguateDecryptArguments(args);\n    return tracingClient.withSpan(\"CryptographyClient.decrypt\", options, async updatedOptions => {\n      this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.Decrypt);\n      const provider = await this.getProvider(\"decrypt\", parameters.algorithm, updatedOptions);\n      try {\n        return provider.decrypt(parameters, updatedOptions);\n      } catch (error) {\n        if (this.remoteProvider) {\n          return this.remoteProvider.decrypt(parameters, updatedOptions);\n        }\n        throw error;\n      }\n    });\n  }\n  /**\n   * Standardizes the arguments of multiple overloads into a single shape.\n   * @param args - The decrypt arguments\n   */\n  disambiguateDecryptArguments(args) {\n    if (typeof args[0] === \"string\") {\n      // Sample shape: [\"RSA1_5\", encryptedBuffer, options]\n      return [{\n        algorithm: args[0],\n        ciphertext: args[1]\n      }, args[2] || {}];\n    } else {\n      // Sample shape: [{ algorithm: \"RSA1_5\", ciphertext: encryptedBuffer }, options]\n      return [args[0], args[1] || {}];\n    }\n  }\n  /**\n   * Wraps the given key using the specified cryptography algorithm\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.wrapKey(\"RSA1_5\", keyToWrap);\n   * ```\n   * @param algorithm - The encryption algorithm to use to wrap the given key.\n   * @param key - The key to wrap.\n   * @param options - Additional options.\n   */\n  wrapKey(algorithm, key, options = {}) {\n    return tracingClient.withSpan(\"CryptographyClient.wrapKey\", options, async updatedOptions => {\n      this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.WrapKey);\n      const provider = await this.getProvider(\"wrapKey\", algorithm, updatedOptions);\n      try {\n        return provider.wrapKey(algorithm, key, updatedOptions);\n      } catch (err) {\n        if (this.remoteProvider) {\n          return this.remoteProvider.wrapKey(algorithm, key, options);\n        }\n        throw err;\n      }\n    });\n  }\n  /**\n   * Unwraps the given wrapped key using the specified cryptography algorithm\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.unwrapKey(\"RSA1_5\", keyToUnwrap);\n   * ```\n   * @param algorithm - The decryption algorithm to use to unwrap the key.\n   * @param encryptedKey - The encrypted key to unwrap.\n   * @param options - Additional options.\n   */\n  unwrapKey(algorithm, encryptedKey, options = {}) {\n    return tracingClient.withSpan(\"CryptographyClient.unwrapKey\", options, async updatedOptions => {\n      this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.UnwrapKey);\n      const provider = await this.getProvider(\"unwrapKey\", algorithm, updatedOptions);\n      try {\n        return provider.unwrapKey(algorithm, encryptedKey, updatedOptions);\n      } catch (err) {\n        if (this.remoteProvider) {\n          return this.remoteProvider.unwrapKey(algorithm, encryptedKey, options);\n        }\n        throw err;\n      }\n    });\n  }\n  /**\n   * Cryptographically sign the digest of a message\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.sign(\"RS256\", digest);\n   * ```\n   * @param algorithm - The signing algorithm to use.\n   * @param digest - The digest of the data to sign.\n   * @param options - Additional options.\n   */\n  sign(algorithm, digest, options = {}) {\n    return tracingClient.withSpan(\"CryptographyClient.sign\", options, async updatedOptions => {\n      this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.Sign);\n      const provider = await this.getProvider(\"sign\", algorithm, updatedOptions);\n      try {\n        return provider.sign(algorithm, digest, updatedOptions);\n      } catch (err) {\n        if (this.remoteProvider) {\n          return this.remoteProvider.sign(algorithm, digest, updatedOptions);\n        }\n        throw err;\n      }\n    });\n  }\n  /**\n   * Verify the signed message digest\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.verify(\"RS256\", signedDigest, signature);\n   * ```\n   * @param algorithm - The signing algorithm to use to verify with.\n   * @param digest - The digest to verify.\n   * @param signature - The signature to verify the digest against.\n   * @param options - Additional options.\n   */\n  verify(algorithm, digest, signature, options = {}) {\n    return tracingClient.withSpan(\"CryptographyClient.verify\", options, async updatedOptions => {\n      this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.Verify);\n      const provider = await this.getProvider(\"verify\", algorithm, updatedOptions);\n      try {\n        return provider.verify(algorithm, digest, signature, updatedOptions);\n      } catch (err) {\n        if (this.remoteProvider) {\n          return this.remoteProvider.verify(algorithm, digest, signature, updatedOptions);\n        }\n        throw err;\n      }\n    });\n  }\n  /**\n   * Cryptographically sign a block of data\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.signData(\"RS256\", message);\n   * ```\n   * @param algorithm - The signing algorithm to use.\n   * @param data - The data to sign.\n   * @param options - Additional options.\n   */\n  signData(algorithm, data,\n  // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n  options = {}) {\n    return tracingClient.withSpan(\"CryptographyClient.signData\", options, async updatedOptions => {\n      this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.Sign);\n      const provider = await this.getProvider(\"signData\", algorithm, updatedOptions);\n      try {\n        return provider.signData(algorithm, data, updatedOptions);\n      } catch (err) {\n        if (this.remoteProvider) {\n          return this.remoteProvider.signData(algorithm, data, options);\n        }\n        throw err;\n      }\n    });\n  }\n  /**\n   * Verify the signed block of data\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.verifyData(\"RS256\", signedMessage, signature);\n   * ```\n   * @param algorithm - The algorithm to use to verify with.\n   * @param data - The signed block of data to verify.\n   * @param signature - The signature to verify the block against.\n   * @param options - Additional options.\n   */\n  verifyData(algorithm, data, signature,\n  // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n  options = {}) {\n    return tracingClient.withSpan(\"CryptographyClient.verifyData\", options, async updatedOptions => {\n      this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.Verify);\n      const provider = await this.getProvider(\"verifyData\", algorithm, updatedOptions);\n      try {\n        return provider.verifyData(algorithm, data, signature, updatedOptions);\n      } catch (err) {\n        if (this.remoteProvider) {\n          return this.remoteProvider.verifyData(algorithm, data, signature, updatedOptions);\n        }\n        throw err;\n      }\n    });\n  }\n  /**\n   * Retrieves the {@link JsonWebKey} from the Key Vault, if possible. Returns undefined if the key could not be retrieved due to insufficient permissions.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.getKeyMaterial();\n   * ```\n   */\n  async getKeyMaterial(options) {\n    const key = await this.fetchKey(options);\n    switch (key.kind) {\n      case \"JsonWebKey\":\n        return key.value;\n      case \"KeyVaultKey\":\n        return key.value.key;\n      default:\n        return undefined;\n    }\n  }\n  /**\n   * Returns the underlying key used for cryptographic operations.\n   * If needed, attempts to fetch the key from KeyVault and exchanges the ID for the actual key.\n   * @param options - The additional options.\n   */\n  async fetchKey(options) {\n    if (this.key.kind === \"identifier\") {\n      // Exchange the identifier with the actual key when needed\n      let key;\n      try {\n        key = await this.remoteProvider.getKey(options);\n      } catch (e) {\n        if (isRestError(e) && e.statusCode === 403) {\n          // If we don't have permission to get the key, we'll fall back to using the remote provider.\n          // Marking the key as a remoteOnlyIdentifier will ensure that we don't attempt to fetch the key again.\n          logger.verbose(`Permission denied to get key ${this.key.value}. Falling back to remote operation.`);\n          this.key = {\n            kind: \"remoteOnlyIdentifier\",\n            value: this.key.value\n          };\n        } else {\n          throw e;\n        }\n      }\n      if (key) {\n        this.key = {\n          kind: \"KeyVaultKey\",\n          value: key\n        };\n      }\n    }\n    return this.key;\n  }\n  /**\n   * Gets the provider that support this algorithm and operation.\n   * The available providers are ordered by priority such that the first provider that supports this\n   * operation is the one we should use.\n   * @param operation - The {@link KeyOperation}.\n   * @param algorithm - The algorithm to use.\n   */\n  async getProvider(operation, algorithm, options) {\n    if (!this.providers) {\n      const keyMaterial = await this.getKeyMaterial(options);\n      this.providers = [];\n      // Add local crypto providers as needed\n      if (keyMaterial) {\n        this.providers.push(new RsaCryptographyProvider(keyMaterial), new AesCryptographyProvider(keyMaterial));\n      }\n      // If the remote provider exists, we're in hybrid-mode. Otherwise we're in local-only mode.\n      // If we're in hybrid mode the remote provider is used as a catch-all and should be last in the list.\n      if (this.remoteProvider) {\n        this.providers.push(this.remoteProvider);\n      }\n    }\n    const providers = this.providers.filter(p => p.isSupported(algorithm, operation));\n    if (providers.length === 0) {\n      throw new Error(`Unable to support operation: \"${operation}\" with algorithm: \"${algorithm}\" ${this.key.kind === \"JsonWebKey\" ? \"using a local JsonWebKey\" : \"\"}`);\n    }\n    // Return the first provider that supports this request\n    return providers[0];\n  }\n  ensureValid(key, operation) {\n    var _a;\n    if (key.kind === \"KeyVaultKey\") {\n      const keyOps = key.value.keyOperations;\n      const {\n        notBefore,\n        expiresOn\n      } = key.value.properties;\n      const now = new Date();\n      // Check KeyVault Key Expiration\n      if (notBefore && now < notBefore) {\n        throw new Error(`Key ${key.value.id} can't be used before ${notBefore.toISOString()}`);\n      }\n      if (expiresOn && now > expiresOn) {\n        throw new Error(`Key ${key.value.id} expired at ${expiresOn.toISOString()}`);\n      }\n      // Check Key operations\n      if (operation && keyOps && !(keyOps === null || keyOps === void 0 ? void 0 : keyOps.includes(operation))) {\n        throw new Error(`Operation ${operation} is not supported on key ${key.value.id}`);\n      }\n    } else if (key.kind === \"JsonWebKey\") {\n      // Check JsonWebKey Key operations\n      if (operation && key.value.keyOps && !((_a = key.value.keyOps) === null || _a === void 0 ? void 0 : _a.includes(operation))) {\n        throw new Error(`Operation ${operation} is not supported on key ${key.value.kid}`);\n      }\n    }\n  }\n}","map":{"version":3,"names":["KnownKeyOperations","RemoteCryptographyProvider","randomBytes","RsaCryptographyProvider","AesCryptographyProvider","tracingClient","isRestError","logger","CryptographyClient","constructor","key","credential","pipelineOptions","kind","value","remoteProvider","vaultUrl","_a","keyID","id","kid","encrypt","args","parameters","options","disambiguateEncryptArguments","withSpan","updatedOptions","ensureValid","fetchKey","Encrypt","initializeIV","provider","getProvider","algorithm","error","algorithmsRequiringIV","cbcParams","iv","e","Error","message","plaintext","decrypt","disambiguateDecryptArguments","Decrypt","ciphertext","wrapKey","WrapKey","err","unwrapKey","encryptedKey","UnwrapKey","sign","digest","Sign","verify","signature","Verify","signData","data","verifyData","getKeyMaterial","undefined","getKey","statusCode","verbose","operation","providers","keyMaterial","push","filter","p","isSupported","length","keyOps","keyOperations","notBefore","expiresOn","properties","now","Date","toISOString","includes"],"sources":["/Users/eimis/test-server/Azure Hackthons/azure-cloud-architecture-game /node_modules/@azure/keyvault-keys/src/cryptographyClient.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { OperationOptions } from \"@azure/core-client\";\nimport { TokenCredential } from \"@azure/core-auth\";\nimport {\n  CryptographyClientOptions,\n  GetKeyOptions,\n  JsonWebKey,\n  KeyOperation,\n  KeyVaultKey,\n  KnownKeyOperations,\n} from \"./keysModels.js\";\nimport {\n  AesCbcEncryptParameters,\n  AesCbcEncryptionAlgorithm,\n  CryptographyClientKey,\n  DecryptOptions,\n  DecryptParameters,\n  DecryptResult,\n  EncryptOptions,\n  EncryptParameters,\n  EncryptResult,\n  EncryptionAlgorithm,\n  KeyWrapAlgorithm,\n  SignOptions,\n  SignResult,\n  SignatureAlgorithm,\n  UnwrapKeyOptions,\n  UnwrapResult,\n  VerifyOptions,\n  VerifyResult,\n  WrapKeyOptions,\n  WrapResult,\n} from \"./cryptographyClientModels.js\";\nimport { RemoteCryptographyProvider } from \"./cryptography/remoteCryptographyProvider.js\";\nimport { randomBytes } from \"./cryptography/crypto.js\";\nimport { CryptographyProvider, CryptographyProviderOperation } from \"./cryptography/models.js\";\nimport { RsaCryptographyProvider } from \"./cryptography/rsaCryptographyProvider.js\";\nimport { AesCryptographyProvider } from \"./cryptography/aesCryptographyProvider.js\";\nimport { tracingClient } from \"./tracing.js\";\nimport { isRestError } from \"@azure/core-rest-pipeline\";\nimport { logger } from \"./log.js\";\n\n/**\n * A client used to perform cryptographic operations on an Azure Key vault key\n * or a local {@link JsonWebKey}.\n */\nexport class CryptographyClient {\n  /**\n   * The key the CryptographyClient currently holds.\n   */\n  private key: CryptographyClientKey;\n\n  /**\n   * The remote provider, which would be undefined if used in local mode.\n   */\n  private remoteProvider?: RemoteCryptographyProvider;\n\n  /**\n   * Constructs a new instance of the Cryptography client for the given key\n   *\n   * Example usage:\n   * ```ts\n   * import { KeyClient, CryptographyClient } from \"@azure/keyvault-keys\";\n   * import { DefaultAzureCredential } from \"@azure/identity\";\n   *\n   * let vaultUrl = `https://<MY KEYVAULT HERE>.vault.azure.net`;\n   * let credentials = new DefaultAzureCredential();\n   *\n   * let keyClient = new KeyClient(vaultUrl, credentials);\n   * let keyVaultKey = await keyClient.getKey(\"MyKey\");\n   *\n   * let client = new CryptographyClient(keyVaultKey.id, credentials);\n   * // or\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * ```\n   * @param key - The key to use during cryptography tasks. You can also pass the identifier of the key i.e its url here.\n   * @param credential - An object that implements the `TokenCredential` interface used to authenticate requests to the service. Use the \\@azure/identity package to create a credential that suits your needs.\n   * @param pipelineOptions - Pipeline options used to configure Key Vault API requests.\n   *                          Omit this parameter to use the default pipeline configuration.\n   */\n  constructor(\n    key: string | KeyVaultKey,\n    credential: TokenCredential,\n    pipelineOptions?: CryptographyClientOptions,\n  );\n  /**\n   * Constructs a new instance of the Cryptography client for the given key in local mode.\n   *\n   * Example usage:\n   * ```ts\n   * import { CryptographyClient } from \"@azure/keyvault-keys\";\n   *\n   * const jsonWebKey: JsonWebKey = {\n   *   // ...\n   * };\n   * const client = new CryptographyClient(jsonWebKey);\n   * ```\n   * @param key - The JsonWebKey to use during cryptography operations.\n   */\n  constructor(key: JsonWebKey);\n  /**\n   * Internal constructor implementation for either local or Key Vault backed keys.\n   * @param key - The key to use during cryptography tasks.\n   * @param credential - Teh credential to use when constructing a Key Vault Cryptography client.\n   */\n  constructor(\n    key: string | KeyVaultKey | JsonWebKey,\n    credential?: TokenCredential,\n    pipelineOptions: CryptographyClientOptions = {},\n  ) {\n    if (typeof key === \"string\") {\n      // Key URL for remote-local operations.\n      this.key = {\n        kind: \"identifier\",\n        value: key,\n      };\n      this.remoteProvider = new RemoteCryptographyProvider(key, credential!, pipelineOptions);\n    } else if (\"name\" in key) {\n      // KeyVault key for remote-local operations.\n      this.key = {\n        kind: \"KeyVaultKey\",\n        value: key,\n      };\n      this.remoteProvider = new RemoteCryptographyProvider(key, credential!, pipelineOptions);\n    } else {\n      // JsonWebKey for local-only operations.\n      this.key = {\n        kind: \"JsonWebKey\",\n        value: key,\n      };\n    }\n  }\n\n  /**\n   * The base URL to the vault. If a local {@link JsonWebKey} is used vaultUrl will be empty.\n   */\n  get vaultUrl(): string {\n    return this.remoteProvider?.vaultUrl || \"\";\n  }\n\n  /**\n   * The ID of the key used to perform cryptographic operations for the client.\n   */\n  get keyID(): string | undefined {\n    if (this.key.kind === \"identifier\" || this.key.kind === \"remoteOnlyIdentifier\") {\n      return this.key.value;\n    } else if (this.key.kind === \"KeyVaultKey\") {\n      return this.key.value.id;\n    } else {\n      return this.key.value.kid;\n    }\n  }\n\n  /**\n   * Encrypts the given plaintext with the specified encryption parameters.\n   * Depending on the algorithm set in the encryption parameters, the set of possible encryption parameters will change.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.encrypt({ algorithm: \"RSA1_5\", plaintext: Buffer.from(\"My Message\")});\n   * let result = await client.encrypt({ algorithm: \"A256GCM\", plaintext: Buffer.from(\"My Message\"), additionalAuthenticatedData: Buffer.from(\"My authenticated data\")});\n   * ```\n   * @param encryptParameters - The encryption parameters, keyed on the encryption algorithm chosen.\n   * @param options - Additional options.\n   */\n  public encrypt(\n    encryptParameters: EncryptParameters,\n    options?: EncryptOptions,\n  ): Promise<EncryptResult>;\n  /**\n   * Encrypts the given plaintext with the specified cryptography algorithm\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.encrypt(\"RSA1_5\", Buffer.from(\"My Message\"));\n   * ```\n   * @param algorithm - The algorithm to use.\n   * @param plaintext - The text to encrypt.\n   * @param options - Additional options.\n   * @deprecated Use `encrypt({ algorithm, plaintext }, options)` instead.\n   */\n  public encrypt(\n    algorithm: EncryptionAlgorithm,\n    plaintext: Uint8Array,\n    options?: EncryptOptions,\n  ): Promise<EncryptResult>;\n  public encrypt(\n    ...args:\n      | [EncryptParameters, EncryptOptions?]\n      | [EncryptionAlgorithm, Uint8Array, EncryptOptions?]\n  ): Promise<EncryptResult> {\n    const [parameters, options] = this.disambiguateEncryptArguments(args);\n    return tracingClient.withSpan(\"CryptographyClient.encrypt\", options, async (updatedOptions) => {\n      this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.Encrypt);\n      this.initializeIV(parameters);\n      const provider = await this.getProvider(\"encrypt\", parameters.algorithm, updatedOptions);\n      try {\n        return provider.encrypt(parameters, updatedOptions);\n      } catch (error: any) {\n        if (this.remoteProvider) {\n          return this.remoteProvider.encrypt(parameters, updatedOptions);\n        }\n        throw error;\n      }\n    });\n  }\n\n  private initializeIV(parameters: EncryptParameters): void {\n    // For AES-GCM the service **must** generate the IV, so we only populate it for AES-CBC\n    const algorithmsRequiringIV: AesCbcEncryptionAlgorithm[] = [\n      \"A128CBC\",\n      \"A128CBCPAD\",\n      \"A192CBC\",\n      \"A192CBCPAD\",\n      \"A256CBC\",\n      \"A256CBCPAD\",\n    ];\n\n    if (parameters.algorithm in algorithmsRequiringIV) {\n      try {\n        const cbcParams = parameters as AesCbcEncryptParameters;\n        if (!cbcParams.iv) {\n          cbcParams.iv = randomBytes(16);\n        }\n      } catch (e: any) {\n        throw new Error(\n          `Unable to initialize IV for algorithm ${parameters.algorithm}. You may pass a valid IV to avoid this error. Error: ${e.message}`,\n        );\n      }\n    }\n  }\n\n  /**\n   * Standardizes the arguments of multiple overloads into a single shape.\n   * @param args - The encrypt arguments\n   */\n  private disambiguateEncryptArguments(\n    args: [EncryptParameters, EncryptOptions?] | [string, Uint8Array, EncryptOptions?],\n  ): [EncryptParameters, EncryptOptions] {\n    if (typeof args[0] === \"string\") {\n      // Sample shape: [\"RSA1_5\", buffer, options]\n      return [\n        {\n          algorithm: args[0],\n          plaintext: args[1],\n        } as EncryptParameters,\n        args[2] || {},\n      ];\n    } else {\n      // Sample shape: [{ algorithm: \"RSA1_5\", plaintext: buffer }, options]\n      return [args[0], (args[1] || {}) as EncryptOptions];\n    }\n  }\n\n  /**\n   * Decrypts the given ciphertext with the specified decryption parameters.\n   * Depending on the algorithm used in the decryption parameters, the set of possible decryption parameters will change.\n   *\n   * Microsoft recommends you not use CBC without first ensuring the integrity of the ciphertext using, for example, an HMAC. See https://docs.microsoft.com/dotnet/standard/security/vulnerabilities-cbc-mode for more information.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.decrypt({ algorithm: \"RSA1_5\", ciphertext: encryptedBuffer });\n   * let result = await client.decrypt({ algorithm: \"A256GCM\", iv: ivFromEncryptResult, authenticationTag: tagFromEncryptResult });\n   * ```\n   * @param decryptParameters - The decryption parameters.\n   * @param options - Additional options.\n   */\n  public async decrypt(\n    decryptParameters: DecryptParameters,\n    options?: DecryptOptions,\n  ): Promise<DecryptResult>;\n  /**\n   * Decrypts the given ciphertext with the specified cryptography algorithm\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.decrypt(\"RSA1_5\", encryptedBuffer);\n   * ```\n   *\n   * Microsoft recommends you not use CBC without first ensuring the integrity of the ciphertext using, for example, an HMAC. See https://docs.microsoft.com/dotnet/standard/security/vulnerabilities-cbc-mode for more information.\n   *\n   * @param algorithm - The algorithm to use.\n   * @param ciphertext - The text to decrypt.\n   * @param options - Additional options.\n   * @deprecated Use `decrypt({ algorithm, ciphertext }, options)` instead.\n   */\n  public decrypt(\n    algorithm: EncryptionAlgorithm,\n    ciphertext: Uint8Array,\n    options?: DecryptOptions,\n  ): Promise<DecryptResult>;\n  public decrypt(\n    ...args:\n      | [DecryptParameters, DecryptOptions?]\n      | [EncryptionAlgorithm, Uint8Array, DecryptOptions?]\n  ): Promise<DecryptResult> {\n    const [parameters, options] = this.disambiguateDecryptArguments(args);\n\n    return tracingClient.withSpan(\"CryptographyClient.decrypt\", options, async (updatedOptions) => {\n      this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.Decrypt);\n      const provider = await this.getProvider(\"decrypt\", parameters.algorithm, updatedOptions);\n      try {\n        return provider.decrypt(parameters, updatedOptions);\n      } catch (error: any) {\n        if (this.remoteProvider) {\n          return this.remoteProvider.decrypt(parameters, updatedOptions);\n        }\n        throw error;\n      }\n    });\n  }\n\n  /**\n   * Standardizes the arguments of multiple overloads into a single shape.\n   * @param args - The decrypt arguments\n   */\n  private disambiguateDecryptArguments(\n    args: [DecryptParameters, DecryptOptions?] | [string, Uint8Array, DecryptOptions?],\n  ): [DecryptParameters, DecryptOptions] {\n    if (typeof args[0] === \"string\") {\n      // Sample shape: [\"RSA1_5\", encryptedBuffer, options]\n      return [\n        {\n          algorithm: args[0],\n          ciphertext: args[1],\n        } as DecryptParameters,\n        args[2] || {},\n      ];\n    } else {\n      // Sample shape: [{ algorithm: \"RSA1_5\", ciphertext: encryptedBuffer }, options]\n      return [args[0], (args[1] || {}) as DecryptOptions];\n    }\n  }\n\n  /**\n   * Wraps the given key using the specified cryptography algorithm\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.wrapKey(\"RSA1_5\", keyToWrap);\n   * ```\n   * @param algorithm - The encryption algorithm to use to wrap the given key.\n   * @param key - The key to wrap.\n   * @param options - Additional options.\n   */\n  public wrapKey(\n    algorithm: KeyWrapAlgorithm,\n    key: Uint8Array,\n    options: WrapKeyOptions = {},\n  ): Promise<WrapResult> {\n    return tracingClient.withSpan(\"CryptographyClient.wrapKey\", options, async (updatedOptions) => {\n      this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.WrapKey);\n      const provider = await this.getProvider(\"wrapKey\", algorithm, updatedOptions);\n      try {\n        return provider.wrapKey(algorithm, key, updatedOptions);\n      } catch (err: any) {\n        if (this.remoteProvider) {\n          return this.remoteProvider.wrapKey(algorithm, key, options);\n        }\n        throw err;\n      }\n    });\n  }\n\n  /**\n   * Unwraps the given wrapped key using the specified cryptography algorithm\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.unwrapKey(\"RSA1_5\", keyToUnwrap);\n   * ```\n   * @param algorithm - The decryption algorithm to use to unwrap the key.\n   * @param encryptedKey - The encrypted key to unwrap.\n   * @param options - Additional options.\n   */\n  public unwrapKey(\n    algorithm: KeyWrapAlgorithm,\n    encryptedKey: Uint8Array,\n    options: UnwrapKeyOptions = {},\n  ): Promise<UnwrapResult> {\n    return tracingClient.withSpan(\n      \"CryptographyClient.unwrapKey\",\n      options,\n      async (updatedOptions) => {\n        this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.UnwrapKey);\n        const provider = await this.getProvider(\"unwrapKey\", algorithm, updatedOptions);\n        try {\n          return provider.unwrapKey(algorithm, encryptedKey, updatedOptions);\n        } catch (err: any) {\n          if (this.remoteProvider) {\n            return this.remoteProvider.unwrapKey(algorithm, encryptedKey, options);\n          }\n          throw err;\n        }\n      },\n    );\n  }\n\n  /**\n   * Cryptographically sign the digest of a message\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.sign(\"RS256\", digest);\n   * ```\n   * @param algorithm - The signing algorithm to use.\n   * @param digest - The digest of the data to sign.\n   * @param options - Additional options.\n   */\n  public sign(\n    algorithm: SignatureAlgorithm,\n    digest: Uint8Array,\n    options: SignOptions = {},\n  ): Promise<SignResult> {\n    return tracingClient.withSpan(\"CryptographyClient.sign\", options, async (updatedOptions) => {\n      this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.Sign);\n      const provider = await this.getProvider(\"sign\", algorithm, updatedOptions);\n      try {\n        return provider.sign(algorithm, digest, updatedOptions);\n      } catch (err: any) {\n        if (this.remoteProvider) {\n          return this.remoteProvider.sign(algorithm, digest, updatedOptions);\n        }\n        throw err;\n      }\n    });\n  }\n\n  /**\n   * Verify the signed message digest\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.verify(\"RS256\", signedDigest, signature);\n   * ```\n   * @param algorithm - The signing algorithm to use to verify with.\n   * @param digest - The digest to verify.\n   * @param signature - The signature to verify the digest against.\n   * @param options - Additional options.\n   */\n  public verify(\n    algorithm: SignatureAlgorithm,\n    digest: Uint8Array,\n    signature: Uint8Array,\n    options: VerifyOptions = {},\n  ): Promise<VerifyResult> {\n    return tracingClient.withSpan(\"CryptographyClient.verify\", options, async (updatedOptions) => {\n      this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.Verify);\n      const provider = await this.getProvider(\"verify\", algorithm, updatedOptions);\n      try {\n        return provider.verify(algorithm, digest, signature, updatedOptions);\n      } catch (err: any) {\n        if (this.remoteProvider) {\n          return this.remoteProvider.verify(algorithm, digest, signature, updatedOptions);\n        }\n        throw err;\n      }\n    });\n  }\n\n  /**\n   * Cryptographically sign a block of data\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.signData(\"RS256\", message);\n   * ```\n   * @param algorithm - The signing algorithm to use.\n   * @param data - The data to sign.\n   * @param options - Additional options.\n   */\n  public signData(\n    algorithm: SignatureAlgorithm,\n    data: Uint8Array,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options: SignOptions = {},\n  ): Promise<SignResult> {\n    return tracingClient.withSpan(\n      \"CryptographyClient.signData\",\n      options,\n      async (updatedOptions) => {\n        this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.Sign);\n        const provider = await this.getProvider(\"signData\", algorithm, updatedOptions);\n        try {\n          return provider.signData(algorithm, data, updatedOptions);\n        } catch (err: any) {\n          if (this.remoteProvider) {\n            return this.remoteProvider.signData(algorithm, data, options);\n          }\n          throw err;\n        }\n      },\n    );\n  }\n\n  /**\n   * Verify the signed block of data\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.verifyData(\"RS256\", signedMessage, signature);\n   * ```\n   * @param algorithm - The algorithm to use to verify with.\n   * @param data - The signed block of data to verify.\n   * @param signature - The signature to verify the block against.\n   * @param options - Additional options.\n   */\n  public verifyData(\n    algorithm: SignatureAlgorithm,\n    data: Uint8Array,\n    signature: Uint8Array,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options: VerifyOptions = {},\n  ): Promise<VerifyResult> {\n    return tracingClient.withSpan(\n      \"CryptographyClient.verifyData\",\n      options,\n      async (updatedOptions) => {\n        this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.Verify);\n        const provider = await this.getProvider(\"verifyData\", algorithm, updatedOptions);\n        try {\n          return provider.verifyData(algorithm, data, signature, updatedOptions);\n        } catch (err: any) {\n          if (this.remoteProvider) {\n            return this.remoteProvider.verifyData(algorithm, data, signature, updatedOptions);\n          }\n          throw err;\n        }\n      },\n    );\n  }\n\n  /**\n   * Retrieves the {@link JsonWebKey} from the Key Vault, if possible. Returns undefined if the key could not be retrieved due to insufficient permissions.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.getKeyMaterial();\n   * ```\n   */\n  private async getKeyMaterial(options: GetKeyOptions): Promise<JsonWebKey | undefined> {\n    const key = await this.fetchKey(options);\n\n    switch (key.kind) {\n      case \"JsonWebKey\":\n        return key.value;\n      case \"KeyVaultKey\":\n        return key.value.key!;\n      default:\n        return undefined;\n    }\n  }\n\n  /**\n   * Returns the underlying key used for cryptographic operations.\n   * If needed, attempts to fetch the key from KeyVault and exchanges the ID for the actual key.\n   * @param options - The additional options.\n   */\n  private async fetchKey<T extends OperationOptions>(options: T): Promise<CryptographyClientKey> {\n    if (this.key.kind === \"identifier\") {\n      // Exchange the identifier with the actual key when needed\n      let key: KeyVaultKey | undefined;\n      try {\n        key = await this.remoteProvider!.getKey(options);\n      } catch (e: unknown) {\n        if (isRestError(e) && e.statusCode === 403) {\n          // If we don't have permission to get the key, we'll fall back to using the remote provider.\n          // Marking the key as a remoteOnlyIdentifier will ensure that we don't attempt to fetch the key again.\n          logger.verbose(\n            `Permission denied to get key ${this.key.value}. Falling back to remote operation.`,\n          );\n          this.key = { kind: \"remoteOnlyIdentifier\", value: this.key.value };\n        } else {\n          throw e;\n        }\n      }\n\n      if (key) {\n        this.key = { kind: \"KeyVaultKey\", value: key };\n      }\n    }\n\n    return this.key;\n  }\n\n  private providers?: CryptographyProvider[];\n  /**\n   * Gets the provider that support this algorithm and operation.\n   * The available providers are ordered by priority such that the first provider that supports this\n   * operation is the one we should use.\n   * @param operation - The {@link KeyOperation}.\n   * @param algorithm - The algorithm to use.\n   */\n  private async getProvider<T extends OperationOptions>(\n    operation: CryptographyProviderOperation,\n    algorithm: string,\n    options: T,\n  ): Promise<CryptographyProvider> {\n    if (!this.providers) {\n      const keyMaterial = await this.getKeyMaterial(options);\n      this.providers = [];\n\n      // Add local crypto providers as needed\n      if (keyMaterial) {\n        this.providers.push(\n          new RsaCryptographyProvider(keyMaterial),\n          new AesCryptographyProvider(keyMaterial),\n        );\n      }\n\n      // If the remote provider exists, we're in hybrid-mode. Otherwise we're in local-only mode.\n      // If we're in hybrid mode the remote provider is used as a catch-all and should be last in the list.\n      if (this.remoteProvider) {\n        this.providers.push(this.remoteProvider);\n      }\n    }\n\n    const providers = this.providers.filter((p) => p.isSupported(algorithm, operation));\n\n    if (providers.length === 0) {\n      throw new Error(\n        `Unable to support operation: \"${operation}\" with algorithm: \"${algorithm}\" ${\n          this.key.kind === \"JsonWebKey\" ? \"using a local JsonWebKey\" : \"\"\n        }`,\n      );\n    }\n\n    // Return the first provider that supports this request\n    return providers[0];\n  }\n\n  private ensureValid(key: CryptographyClientKey, operation?: KeyOperation): void {\n    if (key.kind === \"KeyVaultKey\") {\n      const keyOps = key.value.keyOperations;\n      const { notBefore, expiresOn } = key.value.properties;\n      const now = new Date();\n\n      // Check KeyVault Key Expiration\n      if (notBefore && now < notBefore) {\n        throw new Error(`Key ${key.value.id} can't be used before ${notBefore.toISOString()}`);\n      }\n\n      if (expiresOn && now > expiresOn) {\n        throw new Error(`Key ${key.value.id} expired at ${expiresOn.toISOString()}`);\n      }\n\n      // Check Key operations\n      if (operation && keyOps && !keyOps?.includes(operation)) {\n        throw new Error(`Operation ${operation} is not supported on key ${key.value.id}`);\n      }\n    } else if (key.kind === \"JsonWebKey\") {\n      // Check JsonWebKey Key operations\n      if (operation && key.value.keyOps && !key.value.keyOps?.includes(operation)) {\n        throw new Error(`Operation ${operation} is not supported on key ${key.value.kid}`);\n      }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}