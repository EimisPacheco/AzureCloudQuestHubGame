{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from \"tslib\";\nimport { DiagnosticNodeInternal, DiagnosticNodeType } from \"./diagnostics/DiagnosticNodeInternal\";\nimport { getPathFromLink, ResourceType, StatusCodes } from \"./common\";\nimport { DefaultQueryExecutionContext, getInitialHeader, mergeHeaders, PipelinedQueryExecutionContext } from \"./queryExecutionContext\";\nimport { FeedResponse } from \"./request/FeedResponse\";\nimport { getEmptyCosmosDiagnostics, withDiagnostics, withMetadataDiagnostics } from \"./utils/diagnostics\";\nimport { MetadataLookUpType } from \"./CosmosDiagnostics\";\nimport { randomUUID } from \"@azure/core-util\";\nimport { HybridQueryExecutionContext } from \"./queryExecutionContext/hybridQueryExecutionContext\";\nimport { PartitionKeyRangeCache } from \"./routing\";\n/**\n * Represents a QueryIterator Object, an implementation of feed or query response that enables\n * traversal and iterating over the response\n * in the Azure Cosmos DB database service.\n */\nexport class QueryIterator {\n  /**\n   * @hidden\n   */\n  constructor(clientContext, query, options, fetchFunctions, resourceLink, resourceType) {\n    this.clientContext = clientContext;\n    this.query = query;\n    this.options = options;\n    this.fetchFunctions = fetchFunctions;\n    this.resourceLink = resourceLink;\n    this.resourceType = resourceType;\n    this.query = query;\n    this.fetchFunctions = fetchFunctions;\n    this.options = options || {};\n    this.resourceLink = resourceLink;\n    this.fetchAllLastResHeaders = getInitialHeader();\n    this.reset();\n    this.isInitialized = false;\n    this.partitionKeyRangeCache = new PartitionKeyRangeCache(this.clientContext);\n  }\n  /**\n   * Gets an async iterator that will yield results until completion.\n   *\n   * NOTE: AsyncIterators are a very new feature and you might need to\n   * use polyfils/etc. in order to use them in your code.\n   *\n   * If you're using TypeScript, you can use the following polyfill as long\n   * as you target ES6 or higher and are running on Node 6 or higher.\n   *\n   * ```typescript\n   * if (!Symbol || !Symbol.asyncIterator) {\n   *   (Symbol as any).asyncIterator = Symbol.for(\"Symbol.asyncIterator\");\n   * }\n   * ```\n   *\n   * @example Iterate over all databases\n   * ```typescript\n   * for await(const { resources: db } of client.databases.readAll().getAsyncIterator()) {\n   *   console.log(`Got ${db} from AsyncIterator`);\n   * }\n   * ```\n   */\n  getAsyncIterator() {\n    return __asyncGenerator(this, arguments, function* getAsyncIterator_1() {\n      const diagnosticNode = new DiagnosticNodeInternal(this.clientContext.diagnosticLevel, DiagnosticNodeType.CLIENT_REQUEST_NODE, null);\n      yield __await(yield* __asyncDelegator(__asyncValues(this.getAsyncIteratorInternal(diagnosticNode))));\n    });\n  }\n  /**\n   * @internal\n   */\n  getAsyncIteratorInternal(diagnosticNode) {\n    return __asyncGenerator(this, arguments, function* getAsyncIteratorInternal_1() {\n      this.reset();\n      this.queryPlanPromise = this.fetchQueryPlan(diagnosticNode);\n      while (this.queryExecutionContext.hasMoreResults()) {\n        let response;\n        try {\n          response = yield __await(this.queryExecutionContext.fetchMore(diagnosticNode));\n        } catch (error) {\n          if (this.needsQueryPlan(error)) {\n            yield __await(this.createExecutionContext(diagnosticNode));\n            try {\n              response = yield __await(this.queryExecutionContext.fetchMore(diagnosticNode));\n            } catch (queryError) {\n              this.handleSplitError(queryError);\n            }\n          } else {\n            throw error;\n          }\n        }\n        const feedResponse = new FeedResponse(response.result, response.headers, this.queryExecutionContext.hasMoreResults(), diagnosticNode.toDiagnostic(this.clientContext.getClientConfig()));\n        diagnosticNode = new DiagnosticNodeInternal(this.clientContext.diagnosticLevel, DiagnosticNodeType.CLIENT_REQUEST_NODE, null);\n        if (response.result !== undefined) {\n          yield yield __await(feedResponse);\n        }\n      }\n    });\n  }\n  /**\n   * Determine if there are still remaining resources to process based on the value of the continuation token or the\n   * elements remaining on the current batch in the QueryIterator.\n   * @returns true if there is other elements to process in the QueryIterator.\n   */\n  hasMoreResults() {\n    return this.queryExecutionContext.hasMoreResults();\n  }\n  /**\n   * Fetch all pages for the query and return a single FeedResponse.\n   */\n  async fetchAll() {\n    return withDiagnostics(async diagnosticNode => {\n      return this.fetchAllInternal(diagnosticNode);\n    }, this.clientContext);\n  }\n  /**\n   * @hidden\n   */\n  async fetchAllInternal(diagnosticNode) {\n    this.reset();\n    let response;\n    try {\n      response = await this.toArrayImplementation(diagnosticNode);\n    } catch (error) {\n      this.handleSplitError(error);\n    }\n    return response;\n  }\n  /**\n   * Retrieve the next batch from the feed.\n   *\n   * This may or may not fetch more pages from the backend depending on your settings\n   * and the type of query. Aggregate queries will generally fetch all backend pages\n   * before returning the first batch of responses.\n   */\n  async fetchNext() {\n    return withDiagnostics(async diagnosticNode => {\n      return this.fetchNextInternal(diagnosticNode);\n    }, this.clientContext);\n  }\n  /**\n   * @internal\n   */\n  async fetchNextInternal(diagnosticNode) {\n    this.queryPlanPromise = withMetadataDiagnostics(async metadataNode => {\n      return this.fetchQueryPlan(metadataNode);\n    }, diagnosticNode, MetadataLookUpType.QueryPlanLookUp);\n    if (!this.isInitialized) {\n      await this.init(diagnosticNode);\n    }\n    let response;\n    try {\n      response = await this.queryExecutionContext.fetchMore(diagnosticNode);\n    } catch (error) {\n      if (this.needsQueryPlan(error)) {\n        await this.createExecutionContext(diagnosticNode);\n        try {\n          response = await this.queryExecutionContext.fetchMore(diagnosticNode);\n        } catch (queryError) {\n          this.handleSplitError(queryError);\n        }\n      } else {\n        throw error;\n      }\n    }\n    return new FeedResponse(response.result, response.headers, this.queryExecutionContext.hasMoreResults(), getEmptyCosmosDiagnostics());\n  }\n  /**\n   * Reset the QueryIterator to the beginning and clear all the resources inside it\n   */\n  reset() {\n    this.correlatedActivityId = randomUUID();\n    this.queryPlanPromise = undefined;\n    this.fetchAllLastResHeaders = getInitialHeader();\n    this.fetchAllTempResources = [];\n    this.queryExecutionContext = new DefaultQueryExecutionContext(this.options, this.fetchFunctions, this.correlatedActivityId);\n  }\n  async toArrayImplementation(diagnosticNode) {\n    this.queryPlanPromise = withMetadataDiagnostics(async metadataNode => {\n      return this.fetchQueryPlan(metadataNode);\n    }, diagnosticNode, MetadataLookUpType.QueryPlanLookUp);\n    // this.queryPlanPromise = this.fetchQueryPlan(diagnosticNode);\n    if (!this.isInitialized) {\n      await this.init(diagnosticNode);\n    }\n    while (this.queryExecutionContext.hasMoreResults()) {\n      let response;\n      try {\n        response = await this.queryExecutionContext.fetchMore(diagnosticNode);\n      } catch (error) {\n        if (this.needsQueryPlan(error)) {\n          await this.createExecutionContext(diagnosticNode);\n          response = await this.queryExecutionContext.fetchMore(diagnosticNode);\n        } else {\n          throw error;\n        }\n      }\n      const {\n        result,\n        headers\n      } = response;\n      // concatenate the results and fetch more\n      mergeHeaders(this.fetchAllLastResHeaders, headers);\n      if (result) {\n        this.fetchAllTempResources.push(...result);\n      }\n    }\n    return new FeedResponse(this.fetchAllTempResources, this.fetchAllLastResHeaders, this.queryExecutionContext.hasMoreResults(), getEmptyCosmosDiagnostics());\n  }\n  async createExecutionContext(diagnosticNode) {\n    const queryPlanResponse = await this.queryPlanPromise;\n    // We always coerce queryPlanPromise to resolved. So if it errored, we need to manually inspect the resolved value\n    if (queryPlanResponse instanceof Error) {\n      throw queryPlanResponse;\n    }\n    const queryPlan = queryPlanResponse.result;\n    if (queryPlan.hybridSearchQueryInfo && queryPlan.hybridSearchQueryInfo !== null) {\n      await this.createHybridQueryExecutionContext(queryPlan, diagnosticNode);\n    } else {\n      await this.createPipelinedExecutionContext(queryPlan);\n    }\n  }\n  async createHybridQueryExecutionContext(queryPlan, diagnosticNode) {\n    const allPartitionKeyRanges = (await this.partitionKeyRangeCache.onCollectionRoutingMap(this.resourceLink, diagnosticNode)).getOrderedParitionKeyRanges();\n    // convert allPartitionKeyRanges to QueryRanges\n    const queryRanges = allPartitionKeyRanges.map(partitionKeyRange => {\n      return {\n        min: partitionKeyRange.minInclusive,\n        max: partitionKeyRange.maxExclusive,\n        isMinInclusive: true,\n        isMaxInclusive: false\n      };\n    });\n    this.queryExecutionContext = new HybridQueryExecutionContext(this.clientContext, this.resourceLink, this.options, queryPlan, this.correlatedActivityId, queryRanges);\n  }\n  async createPipelinedExecutionContext(queryPlan) {\n    const queryInfo = queryPlan.queryInfo;\n    if (queryInfo.aggregates.length > 0 && queryInfo.hasSelectValue === false) {\n      throw new Error(\"Aggregate queries must use the VALUE keyword\");\n    }\n    this.queryExecutionContext = new PipelinedQueryExecutionContext(this.clientContext, this.resourceLink, this.query, this.options, queryPlan, this.correlatedActivityId);\n  }\n  async fetchQueryPlan(diagnosticNode) {\n    if (!this.queryPlanPromise && this.resourceType === ResourceType.item) {\n      return this.clientContext.getQueryPlan(getPathFromLink(this.resourceLink) + \"/docs\", ResourceType.item, this.resourceLink, this.query, this.options, diagnosticNode, this.correlatedActivityId).catch(error => error); // Without this catch, node reports an unhandled rejection. So we stash the promise as resolved even if it errored.\n    }\n    return this.queryPlanPromise;\n  }\n  needsQueryPlan(error) {\n    var _a;\n    if (((_a = error.body) === null || _a === void 0 ? void 0 : _a.additionalErrorInfo) || error.message.includes(\"Cross partition query only supports\")) {\n      return error.code === StatusCodes.BadRequest && this.resourceType === ResourceType.item;\n    } else {\n      throw error;\n    }\n  }\n  /**\n   * @internal\n   */\n  async init(diagnosticNode) {\n    if (this.isInitialized === true) {\n      return;\n    }\n    if (this.initPromise === undefined) {\n      this.initPromise = this._init(diagnosticNode);\n    }\n    return this.initPromise;\n  }\n  async _init(diagnosticNode) {\n    if (this.options.forceQueryPlan === true && this.resourceType === ResourceType.item) {\n      await this.createExecutionContext(diagnosticNode);\n    }\n    this.isInitialized = true;\n  }\n  handleSplitError(err) {\n    if (err.code === 410) {\n      const error = new Error(\"Encountered partition split and could not recover. This request is retryable\");\n      error.code = 503;\n      error.originalError = err;\n      throw error;\n    } else {\n      throw err;\n    }\n  }\n}","map":{"version":3,"names":["DiagnosticNodeInternal","DiagnosticNodeType","getPathFromLink","ResourceType","StatusCodes","DefaultQueryExecutionContext","getInitialHeader","mergeHeaders","PipelinedQueryExecutionContext","FeedResponse","getEmptyCosmosDiagnostics","withDiagnostics","withMetadataDiagnostics","MetadataLookUpType","randomUUID","HybridQueryExecutionContext","PartitionKeyRangeCache","QueryIterator","constructor","clientContext","query","options","fetchFunctions","resourceLink","resourceType","fetchAllLastResHeaders","reset","isInitialized","partitionKeyRangeCache","getAsyncIterator","diagnosticNode","diagnosticLevel","CLIENT_REQUEST_NODE","__await","__asyncDelegator","__asyncValues","getAsyncIteratorInternal","queryPlanPromise","fetchQueryPlan","queryExecutionContext","hasMoreResults","response","fetchMore","error","needsQueryPlan","createExecutionContext","queryError","handleSplitError","feedResponse","result","headers","toDiagnostic","getClientConfig","undefined","fetchAll","fetchAllInternal","toArrayImplementation","fetchNext","fetchNextInternal","metadataNode","QueryPlanLookUp","init","correlatedActivityId","fetchAllTempResources","push","queryPlanResponse","Error","queryPlan","hybridSearchQueryInfo","createHybridQueryExecutionContext","createPipelinedExecutionContext","allPartitionKeyRanges","onCollectionRoutingMap","getOrderedParitionKeyRanges","queryRanges","map","partitionKeyRange","min","minInclusive","max","maxExclusive","isMinInclusive","isMaxInclusive","queryInfo","aggregates","length","hasSelectValue","item","getQueryPlan","catch","_a","body","additionalErrorInfo","message","includes","code","BadRequest","initPromise","_init","forceQueryPlan","err","originalError"],"sources":["/Users/eimis/test-server/Azure Hackthons/azure-cloud-architecture-game /node_modules/@azure/cosmos/src/queryIterator.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n/// <reference lib=\"esnext.asynciterable\" />\nimport type { ClientContext } from \"./ClientContext\";\nimport { DiagnosticNodeInternal, DiagnosticNodeType } from \"./diagnostics/DiagnosticNodeInternal\";\nimport { getPathFromLink, ResourceType, StatusCodes } from \"./common\";\nimport type {\n  CosmosHeaders,\n  ExecutionContext,\n  FetchFunctionCallback,\n  SqlQuerySpec,\n} from \"./queryExecutionContext\";\nimport {\n  DefaultQueryExecutionContext,\n  getInitialHeader,\n  mergeHeaders,\n  PipelinedQueryExecutionContext,\n} from \"./queryExecutionContext\";\nimport type { Response } from \"./request\";\nimport type {\n  ErrorResponse,\n  PartitionedQueryExecutionInfo,\n  QueryRange,\n} from \"./request/ErrorResponse\";\nimport type { FeedOptions } from \"./request/FeedOptions\";\nimport { FeedResponse } from \"./request/FeedResponse\";\nimport {\n  getEmptyCosmosDiagnostics,\n  withDiagnostics,\n  withMetadataDiagnostics,\n} from \"./utils/diagnostics\";\nimport { MetadataLookUpType } from \"./CosmosDiagnostics\";\nimport { randomUUID } from \"@azure/core-util\";\nimport { HybridQueryExecutionContext } from \"./queryExecutionContext/hybridQueryExecutionContext\";\nimport { PartitionKeyRangeCache } from \"./routing\";\n\n/**\n * Represents a QueryIterator Object, an implementation of feed or query response that enables\n * traversal and iterating over the response\n * in the Azure Cosmos DB database service.\n */\nexport class QueryIterator<T> {\n  private fetchAllTempResources: T[]; // TODO\n  private fetchAllLastResHeaders: CosmosHeaders;\n  private queryExecutionContext: ExecutionContext;\n  private queryPlanPromise: Promise<Response<PartitionedQueryExecutionInfo>>;\n  private isInitialized: boolean;\n  private correlatedActivityId: string;\n  private partitionKeyRangeCache: PartitionKeyRangeCache;\n  /**\n   * @hidden\n   */\n  constructor(\n    private clientContext: ClientContext,\n    private query: SqlQuerySpec | string,\n    private options: FeedOptions,\n    private fetchFunctions: FetchFunctionCallback | FetchFunctionCallback[],\n    private resourceLink?: string,\n    private resourceType?: ResourceType,\n  ) {\n    this.query = query;\n    this.fetchFunctions = fetchFunctions;\n    this.options = options || {};\n    this.resourceLink = resourceLink;\n    this.fetchAllLastResHeaders = getInitialHeader();\n    this.reset();\n    this.isInitialized = false;\n    this.partitionKeyRangeCache = new PartitionKeyRangeCache(this.clientContext);\n  }\n\n  /**\n   * Gets an async iterator that will yield results until completion.\n   *\n   * NOTE: AsyncIterators are a very new feature and you might need to\n   * use polyfils/etc. in order to use them in your code.\n   *\n   * If you're using TypeScript, you can use the following polyfill as long\n   * as you target ES6 or higher and are running on Node 6 or higher.\n   *\n   * ```typescript\n   * if (!Symbol || !Symbol.asyncIterator) {\n   *   (Symbol as any).asyncIterator = Symbol.for(\"Symbol.asyncIterator\");\n   * }\n   * ```\n   *\n   * @example Iterate over all databases\n   * ```typescript\n   * for await(const { resources: db } of client.databases.readAll().getAsyncIterator()) {\n   *   console.log(`Got ${db} from AsyncIterator`);\n   * }\n   * ```\n   */\n  public async *getAsyncIterator(): AsyncIterable<FeedResponse<T>> {\n    const diagnosticNode = new DiagnosticNodeInternal(\n      this.clientContext.diagnosticLevel,\n      DiagnosticNodeType.CLIENT_REQUEST_NODE,\n      null,\n    );\n    yield* this.getAsyncIteratorInternal(diagnosticNode);\n  }\n  /**\n   * @internal\n   */\n  public async *getAsyncIteratorInternal(\n    diagnosticNode: DiagnosticNodeInternal,\n  ): AsyncIterable<FeedResponse<T>> {\n    this.reset();\n    this.queryPlanPromise = this.fetchQueryPlan(diagnosticNode);\n    while (this.queryExecutionContext.hasMoreResults()) {\n      let response: Response<any>;\n      try {\n        response = await this.queryExecutionContext.fetchMore(diagnosticNode);\n      } catch (error: any) {\n        if (this.needsQueryPlan(error)) {\n          await this.createExecutionContext(diagnosticNode);\n          try {\n            response = await this.queryExecutionContext.fetchMore(diagnosticNode);\n          } catch (queryError: any) {\n            this.handleSplitError(queryError);\n          }\n        } else {\n          throw error;\n        }\n      }\n\n      const feedResponse = new FeedResponse<T>(\n        response.result,\n        response.headers,\n        this.queryExecutionContext.hasMoreResults(),\n        diagnosticNode.toDiagnostic(this.clientContext.getClientConfig()),\n      );\n      diagnosticNode = new DiagnosticNodeInternal(\n        this.clientContext.diagnosticLevel,\n        DiagnosticNodeType.CLIENT_REQUEST_NODE,\n        null,\n      );\n      if (response.result !== undefined) {\n        yield feedResponse;\n      }\n    }\n  }\n\n  /**\n   * Determine if there are still remaining resources to process based on the value of the continuation token or the\n   * elements remaining on the current batch in the QueryIterator.\n   * @returns true if there is other elements to process in the QueryIterator.\n   */\n  public hasMoreResults(): boolean {\n    return this.queryExecutionContext.hasMoreResults();\n  }\n\n  /**\n   * Fetch all pages for the query and return a single FeedResponse.\n   */\n\n  public async fetchAll(): Promise<FeedResponse<T>> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      return this.fetchAllInternal(diagnosticNode);\n    }, this.clientContext);\n  }\n\n  /**\n   * @hidden\n   */\n  public async fetchAllInternal(diagnosticNode: DiagnosticNodeInternal): Promise<FeedResponse<T>> {\n    this.reset();\n    let response: FeedResponse<T>;\n    try {\n      response = await this.toArrayImplementation(diagnosticNode);\n    } catch (error: any) {\n      this.handleSplitError(error);\n    }\n    return response;\n  }\n\n  /**\n   * Retrieve the next batch from the feed.\n   *\n   * This may or may not fetch more pages from the backend depending on your settings\n   * and the type of query. Aggregate queries will generally fetch all backend pages\n   * before returning the first batch of responses.\n   */\n  public async fetchNext(): Promise<FeedResponse<T>> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      return this.fetchNextInternal(diagnosticNode);\n    }, this.clientContext);\n  }\n  /**\n   * @internal\n   */\n  public async fetchNextInternal(diagnosticNode: DiagnosticNodeInternal): Promise<FeedResponse<T>> {\n    this.queryPlanPromise = withMetadataDiagnostics(\n      async (metadataNode: DiagnosticNodeInternal) => {\n        return this.fetchQueryPlan(metadataNode);\n      },\n      diagnosticNode,\n      MetadataLookUpType.QueryPlanLookUp,\n    );\n    if (!this.isInitialized) {\n      await this.init(diagnosticNode);\n    }\n    let response: Response<any>;\n    try {\n      response = await this.queryExecutionContext.fetchMore(diagnosticNode);\n    } catch (error: any) {\n      if (this.needsQueryPlan(error)) {\n        await this.createExecutionContext(diagnosticNode);\n        try {\n          response = await this.queryExecutionContext.fetchMore(diagnosticNode);\n        } catch (queryError: any) {\n          this.handleSplitError(queryError);\n        }\n      } else {\n        throw error;\n      }\n    }\n    return new FeedResponse<T>(\n      response.result,\n      response.headers,\n      this.queryExecutionContext.hasMoreResults(),\n      getEmptyCosmosDiagnostics(),\n    );\n  }\n\n  /**\n   * Reset the QueryIterator to the beginning and clear all the resources inside it\n   */\n  public reset(): void {\n    this.correlatedActivityId = randomUUID();\n    this.queryPlanPromise = undefined;\n    this.fetchAllLastResHeaders = getInitialHeader();\n    this.fetchAllTempResources = [];\n    this.queryExecutionContext = new DefaultQueryExecutionContext(\n      this.options,\n      this.fetchFunctions,\n      this.correlatedActivityId,\n    );\n  }\n\n  private async toArrayImplementation(\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<FeedResponse<T>> {\n    this.queryPlanPromise = withMetadataDiagnostics(\n      async (metadataNode: DiagnosticNodeInternal) => {\n        return this.fetchQueryPlan(metadataNode);\n      },\n      diagnosticNode,\n      MetadataLookUpType.QueryPlanLookUp,\n    );\n    // this.queryPlanPromise = this.fetchQueryPlan(diagnosticNode);\n    if (!this.isInitialized) {\n      await this.init(diagnosticNode);\n    }\n    while (this.queryExecutionContext.hasMoreResults()) {\n      let response: Response<any>;\n      try {\n        response = await this.queryExecutionContext.fetchMore(diagnosticNode);\n      } catch (error: any) {\n        if (this.needsQueryPlan(error)) {\n          await this.createExecutionContext(diagnosticNode);\n          response = await this.queryExecutionContext.fetchMore(diagnosticNode);\n        } else {\n          throw error;\n        }\n      }\n      const { result, headers } = response;\n      // concatenate the results and fetch more\n      mergeHeaders(this.fetchAllLastResHeaders, headers);\n      if (result) {\n        this.fetchAllTempResources.push(...result);\n      }\n    }\n    return new FeedResponse(\n      this.fetchAllTempResources,\n      this.fetchAllLastResHeaders,\n      this.queryExecutionContext.hasMoreResults(),\n      getEmptyCosmosDiagnostics(),\n    );\n  }\n\n  private async createExecutionContext(diagnosticNode?: DiagnosticNodeInternal): Promise<void> {\n    const queryPlanResponse = await this.queryPlanPromise;\n\n    // We always coerce queryPlanPromise to resolved. So if it errored, we need to manually inspect the resolved value\n    if (queryPlanResponse instanceof Error) {\n      throw queryPlanResponse;\n    }\n\n    const queryPlan: PartitionedQueryExecutionInfo = queryPlanResponse.result;\n    if (queryPlan.hybridSearchQueryInfo && queryPlan.hybridSearchQueryInfo !== null) {\n      await this.createHybridQueryExecutionContext(queryPlan, diagnosticNode);\n    } else {\n      await this.createPipelinedExecutionContext(queryPlan);\n    }\n  }\n\n  private async createHybridQueryExecutionContext(\n    queryPlan: PartitionedQueryExecutionInfo,\n    diagnosticNode?: DiagnosticNodeInternal,\n  ): Promise<void> {\n    const allPartitionKeyRanges = (\n      await this.partitionKeyRangeCache.onCollectionRoutingMap(this.resourceLink, diagnosticNode)\n    ).getOrderedParitionKeyRanges();\n\n    // convert allPartitionKeyRanges to QueryRanges\n    const queryRanges: QueryRange[] = allPartitionKeyRanges.map((partitionKeyRange) => {\n      return {\n        min: partitionKeyRange.minInclusive,\n        max: partitionKeyRange.maxExclusive,\n        isMinInclusive: true,\n        isMaxInclusive: false,\n      };\n    });\n\n    this.queryExecutionContext = new HybridQueryExecutionContext(\n      this.clientContext,\n      this.resourceLink,\n      this.options,\n      queryPlan,\n      this.correlatedActivityId,\n      queryRanges,\n    );\n  }\n\n  private async createPipelinedExecutionContext(\n    queryPlan: PartitionedQueryExecutionInfo,\n  ): Promise<void> {\n    const queryInfo = queryPlan.queryInfo;\n    if (queryInfo.aggregates.length > 0 && queryInfo.hasSelectValue === false) {\n      throw new Error(\"Aggregate queries must use the VALUE keyword\");\n    }\n    this.queryExecutionContext = new PipelinedQueryExecutionContext(\n      this.clientContext,\n      this.resourceLink,\n      this.query,\n      this.options,\n      queryPlan,\n      this.correlatedActivityId,\n    );\n  }\n\n  private async fetchQueryPlan(diagnosticNode: DiagnosticNodeInternal): Promise<any> {\n    if (!this.queryPlanPromise && this.resourceType === ResourceType.item) {\n      return this.clientContext\n        .getQueryPlan(\n          getPathFromLink(this.resourceLink) + \"/docs\",\n          ResourceType.item,\n          this.resourceLink,\n          this.query,\n          this.options,\n          diagnosticNode,\n          this.correlatedActivityId,\n        )\n        .catch((error: any) => error); // Without this catch, node reports an unhandled rejection. So we stash the promise as resolved even if it errored.\n    }\n    return this.queryPlanPromise;\n  }\n\n  private needsQueryPlan(error: ErrorResponse): error is ErrorResponse {\n    if (\n      error.body?.additionalErrorInfo ||\n      error.message.includes(\"Cross partition query only supports\")\n    ) {\n      return error.code === StatusCodes.BadRequest && this.resourceType === ResourceType.item;\n    } else {\n      throw error;\n    }\n  }\n\n  private initPromise: Promise<void>;\n  /**\n   * @internal\n   */\n  public async init(diagnosticNode: DiagnosticNodeInternal): Promise<void> {\n    if (this.isInitialized === true) {\n      return;\n    }\n    if (this.initPromise === undefined) {\n      this.initPromise = this._init(diagnosticNode);\n    }\n    return this.initPromise;\n  }\n  private async _init(diagnosticNode: DiagnosticNodeInternal): Promise<void> {\n    if (this.options.forceQueryPlan === true && this.resourceType === ResourceType.item) {\n      await this.createExecutionContext(diagnosticNode);\n    }\n    this.isInitialized = true;\n  }\n\n  private handleSplitError(err: any): void {\n    if (err.code === 410) {\n      const error = new Error(\n        \"Encountered partition split and could not recover. This request is retryable\",\n      ) as any;\n      error.code = 503;\n      error.originalError = err;\n      throw error;\n    } else {\n      throw err;\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}