{"ast":null,"code":"import { createDatabaseUri, getIdFromLink, getPathFromLink, ResourceType } from \"../../common\";\nimport { ErrorResponse } from \"../../request\";\nimport { Container, Containers } from \"../Container\";\nimport { User, Users } from \"../User\";\nimport { DatabaseResponse } from \"./DatabaseResponse\";\nimport { OfferResponse, Offer } from \"../Offer\";\nimport { getEmptyCosmosDiagnostics, withDiagnostics, withMetadataDiagnostics } from \"../../utils/diagnostics\";\nimport { MetadataLookUpType } from \"../../CosmosDiagnostics\";\nimport { ClientEncryptionKeyResponse, EncryptionAlgorithm, KeyEncryptionAlgorithm } from \"../../encryption\";\n/**\n * Operations for reading or deleting an existing database.\n *\n * @see {@link Databases} for creating new databases, and reading/querying all databases; use `client.databases`.\n *\n * Note: all these operations make calls against a fixed budget.\n * You should design your system such that these calls scale sublinearly with your application.\n * For instance, do not call `database.read()` before every single `item.read()` call, to ensure the database exists;\n * do this once on application start up.\n */\nexport class Database {\n  /**\n   * Returns a reference URL to the resource. Used for linking in Permissions.\n   */\n  get url() {\n    return createDatabaseUri(this.id);\n  }\n  /** Returns a new {@link Database} instance.\n   *\n   * Note: the intention is to get this object from {@link CosmosClient} via `client.database(id)`, not to instantiate it yourself.\n   * @hidden\n   */\n  constructor(client, id, clientContext, encryptionManager, _rid) {\n    this.client = client;\n    this.id = id;\n    this.clientContext = clientContext;\n    this.encryptionManager = encryptionManager;\n    this.containers = new Containers(this, this.clientContext, this.encryptionManager);\n    this.users = new Users(this, this.clientContext);\n    this._rid = _rid;\n  }\n  /**\n   * Used to read, replace, or delete a specific, existing {@link Database} by id.\n   *\n   * Use `.containers` creating new containers, or querying/reading all containers.\n   *\n   * @example Delete a container\n   * ```typescript\n   * await client.database(\"<db id>\").container(\"<container id>\").delete();\n   * ```\n   */\n  container(id) {\n    return new Container(this, id, this.clientContext, this.encryptionManager);\n  }\n  /**\n   * Used to read, replace, or delete a specific, existing {@link User} by id.\n   *\n   * Use `.users` for creating new users, or querying/reading all users.\n   */\n  user(id) {\n    return new User(this, id, this.clientContext);\n  }\n  /** Read the definition of the given Database. */\n  async read(options) {\n    return withDiagnostics(async diagnosticNode => {\n      return this.readInternal(diagnosticNode, options);\n    }, this.clientContext);\n  }\n  /**\n   * @hidden\n   */\n  async readInternal(diagnosticNode, options) {\n    const path = getPathFromLink(this.url);\n    const id = getIdFromLink(this.url);\n    const response = await this.clientContext.read({\n      path,\n      resourceType: ResourceType.database,\n      resourceId: id,\n      options,\n      diagnosticNode\n    });\n    return new DatabaseResponse(response.result, response.headers, response.code, this, getEmptyCosmosDiagnostics());\n  }\n  /** Delete the given Database. */\n  async delete(options) {\n    return withDiagnostics(async diagnosticNode => {\n      const path = getPathFromLink(this.url);\n      const id = getIdFromLink(this.url);\n      const response = await this.clientContext.delete({\n        path,\n        resourceType: ResourceType.database,\n        resourceId: id,\n        options,\n        diagnosticNode\n      });\n      return new DatabaseResponse(response.result, response.headers, response.code, this, getEmptyCosmosDiagnostics());\n    }, this.clientContext);\n  }\n  /**\n   * Gets offer on database. If none exists, returns an OfferResponse with undefined.\n   */\n  async readOffer(options = {}) {\n    return withDiagnostics(async diagnosticNode => {\n      const {\n        resource: record\n      } = await withMetadataDiagnostics(async node => {\n        return this.readInternal(node);\n      }, diagnosticNode, MetadataLookUpType.DatabaseLookUp);\n      const path = \"/offers\";\n      const url = record._self;\n      const response = await this.clientContext.queryFeed({\n        path,\n        resourceId: \"\",\n        resourceType: ResourceType.offer,\n        query: `SELECT * from root where root.resource = \"${url}\"`,\n        resultFn: result => result.Offers,\n        options,\n        diagnosticNode\n      });\n      const offer = response.result[0] ? new Offer(this.client, response.result[0].id, this.clientContext) : undefined;\n      return new OfferResponse(response.result[0], response.headers, response.code, getEmptyCosmosDiagnostics(), offer);\n    }, this.clientContext);\n  }\n  /**\n   * Create Encryption key for database account\n   */\n  async createClientEncryptionKey(clientEncryptionKeyId, encryptionAlgorithm, keyWrapMetadata) {\n    if (clientEncryptionKeyId == null || !clientEncryptionKeyId.trim()) {\n      throw new Error(\"encryption key id cannot be null or empty\");\n    }\n    if (encryptionAlgorithm !== EncryptionAlgorithm.AEAD_AES_256_CBC_HMAC_SHA256) {\n      throw new Error(`Invalid encryption algorithm '${encryptionAlgorithm}' passed.`);\n    }\n    if (!keyWrapMetadata) {\n      throw new Error(\"encryptionKeyWrapMetadata cannot be null.\");\n    }\n    if (keyWrapMetadata.algorithm !== KeyEncryptionAlgorithm.RSA_OAEP) {\n      throw new Error(`Invalid key wrap algorithm '${keyWrapMetadata.algorithm}' passed.`);\n    }\n    if (!this.clientContext.enableEncryption) {\n      throw new Error(\"Creating a client encryption key requires the use of an encryption-enabled client.\");\n    }\n    const keyEncryptionKey = this.encryptionManager.keyEncryptionKeyCache.getOrCreate(keyWrapMetadata.name, keyWrapMetadata.value, this.encryptionManager.encryptionKeyStoreProvider);\n    const protectedDataEncryptionKey = await this.encryptionManager.protectedDataEncryptionKeyCache.getOrCreate(clientEncryptionKeyId, keyEncryptionKey);\n    const wrappedDataEncryptionKey = protectedDataEncryptionKey.encryptedValue;\n    const body = {\n      id: clientEncryptionKeyId,\n      encryptionAlgorithm: encryptionAlgorithm,\n      keyWrapMetadata: keyWrapMetadata,\n      wrappedDataEncryptionKey: wrappedDataEncryptionKey.toString(\"base64\")\n    };\n    return withDiagnostics(async diagnosticNode => {\n      const path = getPathFromLink(this.url, ResourceType.clientencryptionkey);\n      const databaseId = getIdFromLink(this.url);\n      const response = await this.clientContext.create({\n        body,\n        path: path,\n        resourceType: ResourceType.clientencryptionkey,\n        resourceId: databaseId,\n        diagnosticNode\n      });\n      const ref = {\n        id: response.result.id,\n        encryptionAlgorithm: response.result.encryptionAlgorithm,\n        etag: response.result._etag,\n        wrappedDataEncryptionKey: new Uint8Array(Buffer.from(response.result.wrappedDataEncryptionKey, \"base64\")),\n        encryptionKeyWrapMetadata: response.result.keyWrapMetadata\n      };\n      return new ClientEncryptionKeyResponse(response.result, response.headers, response.code, ref, getEmptyCosmosDiagnostics());\n    }, this.clientContext);\n  }\n  /**\n   * Read Encryption key for database account\n   */\n  async readClientEncryptionKey(clientEncryptionKeyId) {\n    if (clientEncryptionKeyId == null || !clientEncryptionKeyId.trim()) {\n      throw new ErrorResponse(\"encryption key id cannot be null or empty\");\n    }\n    return withDiagnostics(async diagnosticNode => {\n      if (!this._rid) {\n        const databaseResponse = await this.readInternal(diagnosticNode);\n        if (!databaseResponse || !databaseResponse.resource) {\n          throw new ErrorResponse(`Error reading database with id ${clientEncryptionKeyId}`);\n        }\n        this._rid = databaseResponse.resource._rid;\n      }\n      const path = getPathFromLink(this.url, ResourceType.clientencryptionkey);\n      const resourceid = getIdFromLink(this.url);\n      const response = await this.clientContext.read({\n        path: path + `/${clientEncryptionKeyId}`,\n        resourceType: ResourceType.clientencryptionkey,\n        resourceId: resourceid + `/${ResourceType.clientencryptionkey}/${clientEncryptionKeyId}`,\n        options: {\n          databaseRid: this._rid\n        },\n        diagnosticNode\n      });\n      if (!response || !response.result) {\n        throw new ErrorResponse(`Error reading client encryption key with id ${clientEncryptionKeyId}`);\n      }\n      const ref = {\n        id: response.result.id,\n        encryptionAlgorithm: response.result.encryptionAlgorithm,\n        etag: response.result._etag,\n        wrappedDataEncryptionKey: new Uint8Array(Buffer.from(response.result.wrappedDataEncryptionKey, \"base64\")),\n        encryptionKeyWrapMetadata: response.result.keyWrapMetadata\n      };\n      return new ClientEncryptionKeyResponse(response.result, response.headers, response.code, ref, getEmptyCosmosDiagnostics());\n    }, this.clientContext);\n  }\n  /**\n   * rewraps a client encryption key with new key encryption key\n   * @param id - client encryption key id\n   * @param newKeyWrapMetadata - new encryption key wrap metadata\n   * @returns rewrapped client encryption key with new customer managed key\n   */\n  async rewrapClientEncryptionKey(clientEncryptionKeyId, newKeyWrapMetadata) {\n    if (clientEncryptionKeyId == null || !clientEncryptionKeyId.trim()) {\n      throw new ErrorResponse(\"encryption key id cannot be null or empty\");\n    }\n    if (!newKeyWrapMetadata) {\n      throw new ErrorResponse(\"encryptionKeyWrapMetadata cannot be null.\");\n    }\n    if (newKeyWrapMetadata.algorithm !== KeyEncryptionAlgorithm.RSA_OAEP) {\n      throw new ErrorResponse(`Invalid key wrap algorithm '${newKeyWrapMetadata.algorithm}' passed.`);\n    }\n    if (!this.clientContext.enableEncryption) {\n      throw new ErrorResponse(\"Rewrapping a client encryption key requires the use of an encryption-enabled client.\");\n    }\n    const res = await this.readClientEncryptionKey(clientEncryptionKeyId);\n    if (!res || !res.clientEncryptionKeyProperties) {\n      throw new ErrorResponse(`Error reading client encryption key with id ${clientEncryptionKeyId}`);\n    }\n    let clientEncryptionKeyProperties = res.clientEncryptionKeyProperties;\n    let keyEncryptionKey = this.encryptionManager.keyEncryptionKeyCache.getOrCreate(clientEncryptionKeyProperties.encryptionKeyWrapMetadata.name, clientEncryptionKeyProperties.encryptionKeyWrapMetadata.value, this.encryptionManager.encryptionKeyStoreProvider);\n    const unwrappedKey = await keyEncryptionKey.unwrapEncryptionKey(Buffer.from(clientEncryptionKeyProperties.wrappedDataEncryptionKey));\n    keyEncryptionKey = this.encryptionManager.keyEncryptionKeyCache.getOrCreate(newKeyWrapMetadata.name, newKeyWrapMetadata.value, this.encryptionManager.encryptionKeyStoreProvider);\n    const rewrappedKey = await keyEncryptionKey.wrapEncryptionKey(unwrappedKey);\n    clientEncryptionKeyProperties = {\n      id: clientEncryptionKeyId,\n      encryptionAlgorithm: clientEncryptionKeyProperties.encryptionAlgorithm,\n      etag: clientEncryptionKeyProperties.etag,\n      wrappedDataEncryptionKey: rewrappedKey,\n      encryptionKeyWrapMetadata: newKeyWrapMetadata\n    };\n    const body = {\n      id: clientEncryptionKeyId,\n      encryptionAlgorithm: clientEncryptionKeyProperties.encryptionAlgorithm,\n      keyWrapMetadata: newKeyWrapMetadata,\n      wrappedDataEncryptionKey: rewrappedKey.toString(\"base64\")\n    };\n    return withDiagnostics(async diagnosticNode => {\n      const path = getPathFromLink(this.url, ResourceType.clientencryptionkey);\n      const resourceid = getIdFromLink(this.url);\n      const options = {\n        accessCondition: {\n          type: \"IfMatch\",\n          condition: clientEncryptionKeyProperties.etag\n        }\n      };\n      const response = await this.clientContext.replace({\n        body,\n        path: path + `/${clientEncryptionKeyId}`,\n        resourceType: ResourceType.clientencryptionkey,\n        resourceId: resourceid + `/${ResourceType.clientencryptionkey}/${clientEncryptionKeyId}`,\n        options,\n        diagnosticNode\n      });\n      if (!response || !response.result) {\n        throw new ErrorResponse(`Error rewrapping client encryption key with id ${clientEncryptionKeyId}`);\n      }\n      const ref = {\n        id: response.result.id,\n        encryptionAlgorithm: response.result.encryptionAlgorithm,\n        etag: response.result._etag,\n        wrappedDataEncryptionKey: new Uint8Array(Buffer.from(response.result.wrappedDataEncryptionKey, \"base64\")),\n        encryptionKeyWrapMetadata: response.result.keyWrapMetadata\n      };\n      return new ClientEncryptionKeyResponse(response.result, response.headers, response.code, ref, getEmptyCosmosDiagnostics());\n    }, this.clientContext);\n  }\n}","map":{"version":3,"names":["createDatabaseUri","getIdFromLink","getPathFromLink","ResourceType","ErrorResponse","Container","Containers","User","Users","DatabaseResponse","OfferResponse","Offer","getEmptyCosmosDiagnostics","withDiagnostics","withMetadataDiagnostics","MetadataLookUpType","ClientEncryptionKeyResponse","EncryptionAlgorithm","KeyEncryptionAlgorithm","Database","url","id","constructor","client","clientContext","encryptionManager","_rid","containers","users","container","user","read","options","diagnosticNode","readInternal","path","response","resourceType","database","resourceId","result","headers","code","delete","readOffer","resource","record","node","DatabaseLookUp","_self","queryFeed","offer","query","resultFn","Offers","undefined","createClientEncryptionKey","clientEncryptionKeyId","encryptionAlgorithm","keyWrapMetadata","trim","Error","AEAD_AES_256_CBC_HMAC_SHA256","algorithm","RSA_OAEP","enableEncryption","keyEncryptionKey","keyEncryptionKeyCache","getOrCreate","name","value","encryptionKeyStoreProvider","protectedDataEncryptionKey","protectedDataEncryptionKeyCache","wrappedDataEncryptionKey","encryptedValue","body","toString","clientencryptionkey","databaseId","create","ref","etag","_etag","Uint8Array","Buffer","from","encryptionKeyWrapMetadata","readClientEncryptionKey","databaseResponse","resourceid","databaseRid","rewrapClientEncryptionKey","newKeyWrapMetadata","res","clientEncryptionKeyProperties","unwrappedKey","unwrapEncryptionKey","rewrappedKey","wrapEncryptionKey","accessCondition","type","condition","replace"],"sources":["/Users/eimis/test-server/Azure Hackthons/azure-cloud-architecture-game /node_modules/@azure/cosmos/src/client/Database/Database.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { ClientContext } from \"../../ClientContext\";\nimport { createDatabaseUri, getIdFromLink, getPathFromLink, ResourceType } from \"../../common\";\nimport type { CosmosClient } from \"../../CosmosClient\";\nimport { ErrorResponse, type RequestOptions } from \"../../request\";\nimport { Container, Containers } from \"../Container\";\nimport { User, Users } from \"../User\";\nimport type { DatabaseDefinition } from \"./DatabaseDefinition\";\nimport { DatabaseResponse } from \"./DatabaseResponse\";\nimport type { OfferDefinition } from \"../Offer\";\nimport { OfferResponse, Offer } from \"../Offer\";\nimport type { Resource } from \"../Resource\";\nimport type { DiagnosticNodeInternal } from \"../../diagnostics/DiagnosticNodeInternal\";\nimport {\n  getEmptyCosmosDiagnostics,\n  withDiagnostics,\n  withMetadataDiagnostics,\n} from \"../../utils/diagnostics\";\nimport { MetadataLookUpType } from \"../../CosmosDiagnostics\";\nimport type {\n  ClientEncryptionKeyRequest,\n  KeyEncryptionKey,\n  EncryptionKeyWrapMetadata,\n} from \"../../encryption\";\nimport {\n  ClientEncryptionKeyResponse,\n  ClientEncryptionKeyProperties,\n  EncryptionAlgorithm,\n  KeyEncryptionAlgorithm,\n} from \"../../encryption\";\nimport type { EncryptionManager } from \"../../encryption/EncryptionManager\";\n/**\n * Operations for reading or deleting an existing database.\n *\n * @see {@link Databases} for creating new databases, and reading/querying all databases; use `client.databases`.\n *\n * Note: all these operations make calls against a fixed budget.\n * You should design your system such that these calls scale sublinearly with your application.\n * For instance, do not call `database.read()` before every single `item.read()` call, to ensure the database exists;\n * do this once on application start up.\n */\nexport class Database {\n  /**\n   * Used for creating new containers, or querying/reading all containers.\n   *\n   * Use `.database(id)` to read, replace, or delete a specific, existing {@link Database} by id.\n   *\n   * @example Create a new container\n   * ```typescript\n   * const {body: containerDefinition, container} = await client.database(\"<db id>\").containers.create({id: \"<container id>\"});\n   * ```\n   */\n  public readonly containers: Containers;\n  /**\n   * Used for creating new users, or querying/reading all users.\n   *\n   * Use `.user(id)` to read, replace, or delete a specific, existing {@link User} by id.\n   */\n  public readonly users: Users;\n\n  /**\n   * Returns a reference URL to the resource. Used for linking in Permissions.\n   */\n  public get url(): string {\n    return createDatabaseUri(this.id);\n  }\n\n  /**\n   * @internal\n   */\n  public _rid: string;\n\n  /** Returns a new {@link Database} instance.\n   *\n   * Note: the intention is to get this object from {@link CosmosClient} via `client.database(id)`, not to instantiate it yourself.\n   * @hidden\n   */\n  constructor(\n    public readonly client: CosmosClient,\n    public readonly id: string,\n    private clientContext: ClientContext,\n    private encryptionManager?: EncryptionManager,\n    _rid?: string,\n  ) {\n    this.containers = new Containers(this, this.clientContext, this.encryptionManager);\n    this.users = new Users(this, this.clientContext);\n    this._rid = _rid;\n  }\n\n  /**\n   * Used to read, replace, or delete a specific, existing {@link Database} by id.\n   *\n   * Use `.containers` creating new containers, or querying/reading all containers.\n   *\n   * @example Delete a container\n   * ```typescript\n   * await client.database(\"<db id>\").container(\"<container id>\").delete();\n   * ```\n   */\n  public container(id: string): Container {\n    return new Container(this, id, this.clientContext, this.encryptionManager);\n  }\n\n  /**\n   * Used to read, replace, or delete a specific, existing {@link User} by id.\n   *\n   * Use `.users` for creating new users, or querying/reading all users.\n   */\n  public user(id: string): User {\n    return new User(this, id, this.clientContext);\n  }\n\n  /** Read the definition of the given Database. */\n  public async read(options?: RequestOptions): Promise<DatabaseResponse> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      return this.readInternal(diagnosticNode, options);\n    }, this.clientContext);\n  }\n\n  /**\n   * @hidden\n   */\n  public async readInternal(\n    diagnosticNode: DiagnosticNodeInternal,\n    options?: RequestOptions,\n  ): Promise<DatabaseResponse> {\n    const path = getPathFromLink(this.url);\n    const id = getIdFromLink(this.url);\n    const response = await this.clientContext.read<DatabaseDefinition>({\n      path,\n      resourceType: ResourceType.database,\n      resourceId: id,\n      options,\n      diagnosticNode,\n    });\n    return new DatabaseResponse(\n      response.result,\n      response.headers,\n      response.code,\n      this,\n      getEmptyCosmosDiagnostics(),\n    );\n  }\n\n  /** Delete the given Database. */\n  public async delete(options?: RequestOptions): Promise<DatabaseResponse> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      const path = getPathFromLink(this.url);\n      const id = getIdFromLink(this.url);\n\n      const response = await this.clientContext.delete<DatabaseDefinition>({\n        path,\n        resourceType: ResourceType.database,\n        resourceId: id,\n        options,\n        diagnosticNode,\n      });\n      return new DatabaseResponse(\n        response.result,\n        response.headers,\n        response.code,\n        this,\n        getEmptyCosmosDiagnostics(),\n      );\n    }, this.clientContext);\n  }\n\n  /**\n   * Gets offer on database. If none exists, returns an OfferResponse with undefined.\n   */\n  public async readOffer(options: RequestOptions = {}): Promise<OfferResponse> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      const { resource: record } = await withMetadataDiagnostics(\n        async (node: DiagnosticNodeInternal) => {\n          return this.readInternal(node);\n        },\n        diagnosticNode,\n        MetadataLookUpType.DatabaseLookUp,\n      );\n\n      const path = \"/offers\";\n      const url = record._self;\n\n      const response = await this.clientContext.queryFeed<OfferDefinition & Resource[]>({\n        path,\n        resourceId: \"\",\n        resourceType: ResourceType.offer,\n        query: `SELECT * from root where root.resource = \"${url}\"`,\n        resultFn: (result) => result.Offers,\n        options,\n        diagnosticNode,\n      });\n      const offer = response.result[0]\n        ? new Offer(this.client, response.result[0].id, this.clientContext)\n        : undefined;\n      return new OfferResponse(\n        response.result[0],\n        response.headers,\n        response.code,\n        getEmptyCosmosDiagnostics(),\n        offer,\n      );\n    }, this.clientContext);\n  }\n\n  /**\n   * Create Encryption key for database account\n   */\n  public async createClientEncryptionKey(\n    clientEncryptionKeyId: string,\n    encryptionAlgorithm: EncryptionAlgorithm,\n    keyWrapMetadata: EncryptionKeyWrapMetadata,\n  ): Promise<ClientEncryptionKeyResponse> {\n    if (clientEncryptionKeyId == null || !clientEncryptionKeyId.trim()) {\n      throw new Error(\"encryption key id cannot be null or empty\");\n    }\n    if (encryptionAlgorithm !== EncryptionAlgorithm.AEAD_AES_256_CBC_HMAC_SHA256) {\n      throw new Error(`Invalid encryption algorithm '${encryptionAlgorithm}' passed.`);\n    }\n    if (!keyWrapMetadata) {\n      throw new Error(\"encryptionKeyWrapMetadata cannot be null.\");\n    }\n    if (keyWrapMetadata.algorithm !== KeyEncryptionAlgorithm.RSA_OAEP) {\n      throw new Error(`Invalid key wrap algorithm '${keyWrapMetadata.algorithm}' passed.`);\n    }\n    if (!this.clientContext.enableEncryption) {\n      throw new Error(\n        \"Creating a client encryption key requires the use of an encryption-enabled client.\",\n      );\n    }\n\n    const keyEncryptionKey: KeyEncryptionKey =\n      this.encryptionManager.keyEncryptionKeyCache.getOrCreate(\n        keyWrapMetadata.name,\n        keyWrapMetadata.value,\n        this.encryptionManager.encryptionKeyStoreProvider,\n      );\n\n    const protectedDataEncryptionKey =\n      await this.encryptionManager.protectedDataEncryptionKeyCache.getOrCreate(\n        clientEncryptionKeyId,\n        keyEncryptionKey,\n      );\n\n    const wrappedDataEncryptionKey = protectedDataEncryptionKey.encryptedValue;\n\n    const body: ClientEncryptionKeyRequest = {\n      id: clientEncryptionKeyId,\n      encryptionAlgorithm: encryptionAlgorithm,\n      keyWrapMetadata: keyWrapMetadata,\n      wrappedDataEncryptionKey: wrappedDataEncryptionKey.toString(\"base64\"),\n    };\n\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      const path = getPathFromLink(this.url, ResourceType.clientencryptionkey);\n      const databaseId = getIdFromLink(this.url);\n      const response = await this.clientContext.create<ClientEncryptionKeyRequest>({\n        body,\n        path: path,\n        resourceType: ResourceType.clientencryptionkey,\n        resourceId: databaseId,\n        diagnosticNode,\n      });\n      const ref: ClientEncryptionKeyProperties = {\n        id: response.result.id,\n        encryptionAlgorithm: response.result.encryptionAlgorithm,\n        etag: response.result._etag,\n        wrappedDataEncryptionKey: new Uint8Array(\n          Buffer.from(response.result.wrappedDataEncryptionKey, \"base64\"),\n        ),\n        encryptionKeyWrapMetadata: response.result.keyWrapMetadata,\n      };\n      return new ClientEncryptionKeyResponse(\n        response.result,\n        response.headers,\n        response.code,\n        ref,\n        getEmptyCosmosDiagnostics(),\n      );\n    }, this.clientContext);\n  }\n\n  /**\n   * Read Encryption key for database account\n   */\n  public async readClientEncryptionKey(\n    clientEncryptionKeyId: string,\n  ): Promise<ClientEncryptionKeyResponse> {\n    if (clientEncryptionKeyId == null || !clientEncryptionKeyId.trim()) {\n      throw new ErrorResponse(\"encryption key id cannot be null or empty\");\n    }\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      if (!this._rid) {\n        const databaseResponse = await this.readInternal(diagnosticNode);\n        if (!databaseResponse || !databaseResponse.resource) {\n          throw new ErrorResponse(`Error reading database with id ${clientEncryptionKeyId}`);\n        }\n        this._rid = databaseResponse.resource._rid;\n      }\n      const path = getPathFromLink(this.url, ResourceType.clientencryptionkey);\n      const resourceid = getIdFromLink(this.url);\n      const response = await this.clientContext.read<ClientEncryptionKeyRequest>({\n        path: path + `/${clientEncryptionKeyId}`,\n        resourceType: ResourceType.clientencryptionkey,\n        resourceId: resourceid + `/${ResourceType.clientencryptionkey}/${clientEncryptionKeyId}`,\n        options: { databaseRid: this._rid },\n        diagnosticNode,\n      });\n      if (!response || !response.result) {\n        throw new ErrorResponse(\n          `Error reading client encryption key with id ${clientEncryptionKeyId}`,\n        );\n      }\n      const ref: ClientEncryptionKeyProperties = {\n        id: response.result.id,\n        encryptionAlgorithm: response.result.encryptionAlgorithm,\n        etag: response.result._etag,\n        wrappedDataEncryptionKey: new Uint8Array(\n          Buffer.from(response.result.wrappedDataEncryptionKey, \"base64\"),\n        ),\n        encryptionKeyWrapMetadata: response.result.keyWrapMetadata,\n      };\n      return new ClientEncryptionKeyResponse(\n        response.result,\n        response.headers,\n        response.code,\n        ref,\n        getEmptyCosmosDiagnostics(),\n      );\n    }, this.clientContext);\n  }\n  /**\n   * rewraps a client encryption key with new key encryption key\n   * @param id - client encryption key id\n   * @param newKeyWrapMetadata - new encryption key wrap metadata\n   * @returns rewrapped client encryption key with new customer managed key\n   */\n  public async rewrapClientEncryptionKey(\n    clientEncryptionKeyId: string,\n    newKeyWrapMetadata: EncryptionKeyWrapMetadata,\n  ): Promise<ClientEncryptionKeyResponse> {\n    if (clientEncryptionKeyId == null || !clientEncryptionKeyId.trim()) {\n      throw new ErrorResponse(\"encryption key id cannot be null or empty\");\n    }\n    if (!newKeyWrapMetadata) {\n      throw new ErrorResponse(\"encryptionKeyWrapMetadata cannot be null.\");\n    }\n    if (newKeyWrapMetadata.algorithm !== KeyEncryptionAlgorithm.RSA_OAEP) {\n      throw new ErrorResponse(\n        `Invalid key wrap algorithm '${newKeyWrapMetadata.algorithm}' passed.`,\n      );\n    }\n    if (!this.clientContext.enableEncryption) {\n      throw new ErrorResponse(\n        \"Rewrapping a client encryption key requires the use of an encryption-enabled client.\",\n      );\n    }\n\n    const res = await this.readClientEncryptionKey(clientEncryptionKeyId);\n    if (!res || !res.clientEncryptionKeyProperties) {\n      throw new ErrorResponse(\n        `Error reading client encryption key with id ${clientEncryptionKeyId}`,\n      );\n    }\n    let clientEncryptionKeyProperties = res.clientEncryptionKeyProperties;\n\n    let keyEncryptionKey = this.encryptionManager.keyEncryptionKeyCache.getOrCreate(\n      clientEncryptionKeyProperties.encryptionKeyWrapMetadata.name,\n      clientEncryptionKeyProperties.encryptionKeyWrapMetadata.value,\n      this.encryptionManager.encryptionKeyStoreProvider,\n    );\n    const unwrappedKey = await keyEncryptionKey.unwrapEncryptionKey(\n      Buffer.from(clientEncryptionKeyProperties.wrappedDataEncryptionKey),\n    );\n\n    keyEncryptionKey = this.encryptionManager.keyEncryptionKeyCache.getOrCreate(\n      newKeyWrapMetadata.name,\n      newKeyWrapMetadata.value,\n      this.encryptionManager.encryptionKeyStoreProvider,\n    );\n    const rewrappedKey = await keyEncryptionKey.wrapEncryptionKey(unwrappedKey);\n    clientEncryptionKeyProperties = {\n      id: clientEncryptionKeyId,\n      encryptionAlgorithm: clientEncryptionKeyProperties.encryptionAlgorithm,\n      etag: clientEncryptionKeyProperties.etag,\n      wrappedDataEncryptionKey: rewrappedKey,\n      encryptionKeyWrapMetadata: newKeyWrapMetadata,\n    };\n    const body: ClientEncryptionKeyRequest = {\n      id: clientEncryptionKeyId,\n      encryptionAlgorithm: clientEncryptionKeyProperties.encryptionAlgorithm,\n      keyWrapMetadata: newKeyWrapMetadata,\n      wrappedDataEncryptionKey: rewrappedKey.toString(\"base64\"),\n    };\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      const path = getPathFromLink(this.url, ResourceType.clientencryptionkey);\n      const resourceid = getIdFromLink(this.url);\n      const options = {\n        accessCondition: { type: \"IfMatch\", condition: clientEncryptionKeyProperties.etag },\n      };\n      const response = await this.clientContext.replace<ClientEncryptionKeyRequest>({\n        body,\n        path: path + `/${clientEncryptionKeyId}`,\n        resourceType: ResourceType.clientencryptionkey,\n        resourceId: resourceid + `/${ResourceType.clientencryptionkey}/${clientEncryptionKeyId}`,\n        options,\n        diagnosticNode,\n      });\n\n      if (!response || !response.result) {\n        throw new ErrorResponse(\n          `Error rewrapping client encryption key with id ${clientEncryptionKeyId}`,\n        );\n      }\n\n      const ref: ClientEncryptionKeyProperties = {\n        id: response.result.id,\n        encryptionAlgorithm: response.result.encryptionAlgorithm,\n        etag: response.result._etag,\n        wrappedDataEncryptionKey: new Uint8Array(\n          Buffer.from(response.result.wrappedDataEncryptionKey, \"base64\"),\n        ),\n        encryptionKeyWrapMetadata: response.result.keyWrapMetadata,\n      };\n      return new ClientEncryptionKeyResponse(\n        response.result,\n        response.headers,\n        response.code,\n        ref,\n        getEmptyCosmosDiagnostics(),\n      );\n    }, this.clientContext);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}