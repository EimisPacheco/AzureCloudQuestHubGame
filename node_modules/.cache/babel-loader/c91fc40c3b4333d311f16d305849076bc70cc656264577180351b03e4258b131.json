{"ast":null,"code":"import { SERVICE_MAPPINGS } from '../services/IconResolver';\n\n// Use environment variables for the Azure function URL and key\nconst SERVICES_FUNCTION_URL = process.env.REACT_APP_SERVICES_FUNCTION_URL;\nconst FUNCTION_KEY = process.env.REACT_APP_SERVICES_AZURE_FUNCTION_KEY;\n\n// Replace the hardcoded SERVICE_DEFINITIONS with a function to fetch from Azure Function\nlet cachedDefinitions = null;\n\n// Add this new function to help resolve icon paths\nconst resolveIconPath = serviceName => {\n  console.log(`🔍 Trying to resolve icon for: ${serviceName}`);\n\n  // Convert the service name to a standardized format for path lookup\n  // Remove special characters and standardize spaces to hyphens\n  const normalizedName = serviceName.toLowerCase().replace(/[^\\w\\s-]/g, '') // Remove special chars\n  .replace(/\\s+/g, '-'); // Replace spaces with hyphens\n\n  // Start with base path from environment\n  const basePath = process.env.REACT_APP_ICONS_BASE_PATH || '/azure-icons';\n\n  // Try multiple potential paths as fallbacks\n  const potentialPaths = [`/azure-icons/services/${normalizedName}.svg`, `/azure-icons/services/${normalizedName}.png`, `${basePath}/services/${normalizedName}.svg`, `${basePath}/services/${normalizedName}.png`, `/azure-icons/${normalizedName}.svg`, `/azure-icons/${normalizedName}.png`];\n\n  // Check if we have a direct mapping in our icon resolver\n  // This handles cases where the API service name doesn't match icon filenames\n  if (SERVICE_MAPPINGS[serviceName]) {\n    const mappedPath = SERVICE_MAPPINGS[serviceName];\n    console.log(`✅ Found direct mapping for ${serviceName} -> ${mappedPath}`);\n    return mappedPath;\n  }\n\n  // For the potential generic paths\n  for (const path of potentialPaths) {\n    console.log(`🔍 Checking path: ${path}`);\n    // We can't easily check if the path is valid without loading the image\n    // So we'll return the first option and let the UI handle fallbacks\n  }\n\n  // Return the first potential path, UI should have a fallback for invalid paths\n  console.log(`⚠️ No direct mapping found, using default path: ${potentialPaths[0]}`);\n  return potentialPaths[0];\n};\nexport const getServiceDefinitions = async () => {\n  console.log('🔄 Fetching service definitions...');\n\n  // Use cached data if available to prevent unnecessary API calls\n  if (cachedDefinitions) {\n    console.log('📋 Using cached definitions:', cachedDefinitions.length, 'items');\n    return cachedDefinitions;\n  }\n  try {\n    if (!SERVICES_FUNCTION_URL || !FUNCTION_KEY) {\n      throw new Error('Azure Function URL or key is not configured');\n    }\n    console.log('🌐 Calling Azure Function:', SERVICES_FUNCTION_URL);\n    const response = await fetch(SERVICES_FUNCTION_URL, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'x-functions-key': FUNCTION_KEY\n      },\n      body: JSON.stringify({/* Add any necessary payload here */})\n    });\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n    console.log('📊 Raw Azure Function response:', data);\n    console.log('📊 Response type:', typeof data);\n    console.log('📊 Response is array:', Array.isArray(data));\n    if (Array.isArray(data)) {\n      console.log('📊 First few items:', data.slice(0, 3));\n    }\n\n    // Format the data to match your expected structure\n    const formattedData = data.map(item => {\n      const iconPath = resolveIconPath(item.service);\n      return {\n        name: item.service,\n        definition: item.description,\n        path: iconPath\n      };\n    });\n    console.log('🔄 Formatted data examples:', formattedData.slice(0, 3));\n    console.log('✅ Total service definitions:', formattedData.length);\n\n    // Cache the data\n    cachedDefinitions = formattedData;\n    return formattedData;\n  } catch (error) {\n    console.error('❌ Error fetching service definitions:', error);\n    console.error('❌ Error details:', {\n      message: error.message,\n      response: error.response ? {\n        status: error.response.status,\n        data: error.response.data\n      } : 'No response',\n      request: error.request ? 'Request was made but no response received' : 'No request was made'\n    });\n\n    // Fallback to hardcoded data in case of error\n    console.log('⚠️ Using fallback data instead');\n    return [{\n      name: \"Kubernetes Services\",\n      definition: \"Simplifies deploying, managing, and scaling containerized applications\",\n      path: \"/azure-icons/services/kubernetes-services.svg\"\n    }, {\n      name: \"Cognitive Services\",\n      definition: \"Adds AI capabilities to applications through pre-built APIs\",\n      path: \"/azure-icons/services/cognitive-services.svg\"\n    },\n    // Add a few more fallback items...\n    {\n      name: \"Azure Functions\",\n      definition: \"Event-driven, serverless compute service\",\n      path: \"/azure-icons/services/azure-functions.svg\"\n    }];\n  }\n};\n\n// Update the getRandomServices function to work with async data\nexport const getRandomServices = async (count = 10) => {\n  const allServices = await getServiceDefinitions();\n  const shuffled = [...allServices].sort(() => 0.5 - Math.random());\n  return shuffled.slice(0, count);\n};\n\n// Update other functions that use SERVICE_DEFINITIONS\nexport const getRandomDefinition = async () => {\n  const services = await getServiceDefinitions();\n  const randomIndex = Math.floor(Math.random() * services.length);\n  return {\n    name: services[randomIndex].name,\n    definition: services[randomIndex].definition\n  };\n};\n\n// Check if the game is complete (all definitions matched)\nexport const isGameComplete = (matchedServices, totalServices) => {\n  return matchedServices.length === totalServices;\n};\n\n// Format time as MM:SS\nexport const formatTime = seconds => {\n  const mins = Math.floor(seconds / 60);\n  const secs = seconds % 60;\n  return `${mins < 10 ? '0' : ''}${mins}:${secs < 10 ? '0' : ''}${secs}`;\n};","map":{"version":3,"names":["SERVICE_MAPPINGS","SERVICES_FUNCTION_URL","process","env","REACT_APP_SERVICES_FUNCTION_URL","FUNCTION_KEY","REACT_APP_SERVICES_AZURE_FUNCTION_KEY","cachedDefinitions","resolveIconPath","serviceName","console","log","normalizedName","toLowerCase","replace","basePath","REACT_APP_ICONS_BASE_PATH","potentialPaths","mappedPath","path","getServiceDefinitions","length","Error","response","fetch","method","headers","body","JSON","stringify","ok","status","data","json","Array","isArray","slice","formattedData","map","item","iconPath","service","name","definition","description","error","message","request","getRandomServices","count","allServices","shuffled","sort","Math","random","getRandomDefinition","services","randomIndex","floor","isGameComplete","matchedServices","totalServices","formatTime","seconds","mins","secs"],"sources":["/Users/eimis/test-server/Azure Hackthons/azure-cloud-architecture-game /src/utils/definitionMatchingUtils.js"],"sourcesContent":["import { SERVICE_MAPPINGS } from '../services/IconResolver';\n\n// Use environment variables for the Azure function URL and key\nconst SERVICES_FUNCTION_URL = process.env.REACT_APP_SERVICES_FUNCTION_URL;\nconst FUNCTION_KEY = process.env.REACT_APP_SERVICES_AZURE_FUNCTION_KEY;\n\n// Replace the hardcoded SERVICE_DEFINITIONS with a function to fetch from Azure Function\nlet cachedDefinitions = null;\n\n// Add this new function to help resolve icon paths\nconst resolveIconPath = (serviceName) => {\n  console.log(`🔍 Trying to resolve icon for: ${serviceName}`);\n  \n  // Convert the service name to a standardized format for path lookup\n  // Remove special characters and standardize spaces to hyphens\n  const normalizedName = serviceName\n    .toLowerCase()\n    .replace(/[^\\w\\s-]/g, '')  // Remove special chars\n    .replace(/\\s+/g, '-');     // Replace spaces with hyphens\n  \n  // Start with base path from environment\n  const basePath = process.env.REACT_APP_ICONS_BASE_PATH || '/azure-icons';\n  \n  // Try multiple potential paths as fallbacks\n  const potentialPaths = [\n    `/azure-icons/services/${normalizedName}.svg`,\n    `/azure-icons/services/${normalizedName}.png`,\n    `${basePath}/services/${normalizedName}.svg`,\n    `${basePath}/services/${normalizedName}.png`,\n    `/azure-icons/${normalizedName}.svg`,\n    `/azure-icons/${normalizedName}.png`\n  ];\n  \n  // Check if we have a direct mapping in our icon resolver\n  // This handles cases where the API service name doesn't match icon filenames\n  if (SERVICE_MAPPINGS[serviceName]) {\n    const mappedPath = SERVICE_MAPPINGS[serviceName];\n    console.log(`✅ Found direct mapping for ${serviceName} -> ${mappedPath}`);\n    return mappedPath;\n  }\n  \n  // For the potential generic paths\n  for (const path of potentialPaths) {\n    console.log(`🔍 Checking path: ${path}`);\n    // We can't easily check if the path is valid without loading the image\n    // So we'll return the first option and let the UI handle fallbacks\n  }\n  \n  // Return the first potential path, UI should have a fallback for invalid paths\n  console.log(`⚠️ No direct mapping found, using default path: ${potentialPaths[0]}`);\n  return potentialPaths[0];\n};\n\nexport const getServiceDefinitions = async () => {\n  console.log('🔄 Fetching service definitions...');\n  \n  // Use cached data if available to prevent unnecessary API calls\n  if (cachedDefinitions) {\n    console.log('📋 Using cached definitions:', cachedDefinitions.length, 'items');\n    return cachedDefinitions;\n  }\n\n  try {\n    if (!SERVICES_FUNCTION_URL || !FUNCTION_KEY) {\n      throw new Error('Azure Function URL or key is not configured');\n    }\n\n    console.log('🌐 Calling Azure Function:', SERVICES_FUNCTION_URL);\n    const response = await fetch(SERVICES_FUNCTION_URL, {\n      method: 'POST',\n      headers: { \n        'Content-Type': 'application/json',\n        'x-functions-key': FUNCTION_KEY\n      },\n      body: JSON.stringify({ /* Add any necessary payload here */ })\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    const data = await response.json();\n    \n    console.log('📊 Raw Azure Function response:', data);\n    console.log('📊 Response type:', typeof data);\n    console.log('📊 Response is array:', Array.isArray(data));\n    \n    if (Array.isArray(data)) {\n      console.log('📊 First few items:', data.slice(0, 3));\n    }\n    \n    // Format the data to match your expected structure\n    const formattedData = data.map(item => {\n      const iconPath = resolveIconPath(item.service);\n      return {\n        name: item.service,\n        definition: item.description,\n        path: iconPath\n      };\n    });\n    \n    console.log('🔄 Formatted data examples:', formattedData.slice(0, 3));\n    console.log('✅ Total service definitions:', formattedData.length);\n    \n    // Cache the data\n    cachedDefinitions = formattedData;\n    return formattedData;\n  } catch (error) {\n    console.error('❌ Error fetching service definitions:', error);\n    console.error('❌ Error details:', {\n      message: error.message,\n      response: error.response ? {\n        status: error.response.status,\n        data: error.response.data\n      } : 'No response',\n      request: error.request ? 'Request was made but no response received' : 'No request was made'\n    });\n    \n    // Fallback to hardcoded data in case of error\n    console.log('⚠️ Using fallback data instead');\n    return [\n      {\n        name: \"Kubernetes Services\",\n        definition: \"Simplifies deploying, managing, and scaling containerized applications\",\n        path: \"/azure-icons/services/kubernetes-services.svg\"\n      },\n      {\n        name: \"Cognitive Services\",\n        definition: \"Adds AI capabilities to applications through pre-built APIs\",\n        path: \"/azure-icons/services/cognitive-services.svg\"\n      },\n      // Add a few more fallback items...\n      {\n        name: \"Azure Functions\",\n        definition: \"Event-driven, serverless compute service\",\n        path: \"/azure-icons/services/azure-functions.svg\"\n      }\n    ];\n  }\n};\n\n// Update the getRandomServices function to work with async data\nexport const getRandomServices = async (count = 10) => {\n  const allServices = await getServiceDefinitions();\n  const shuffled = [...allServices].sort(() => 0.5 - Math.random());\n  return shuffled.slice(0, count);\n};\n\n// Update other functions that use SERVICE_DEFINITIONS\nexport const getRandomDefinition = async () => {\n  const services = await getServiceDefinitions();\n  const randomIndex = Math.floor(Math.random() * services.length);\n  return {\n    name: services[randomIndex].name,\n    definition: services[randomIndex].definition\n  };\n};\n\n// Check if the game is complete (all definitions matched)\nexport const isGameComplete = (matchedServices, totalServices) => {\n  return matchedServices.length === totalServices;\n};\n\n// Format time as MM:SS\nexport const formatTime = (seconds) => {\n  const mins = Math.floor(seconds / 60);\n  const secs = seconds % 60;\n  return `${mins < 10 ? '0' : ''}${mins}:${secs < 10 ? '0' : ''}${secs}`;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}