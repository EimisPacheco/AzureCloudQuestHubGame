{"ast":null,"code":"\"use strict\";\n\nvar _objectWithoutProperties = require(\"/Users/eimis/test-server/react_projects/legendary-lines-game/node_modules/@babel/runtime/helpers/objectWithoutProperties.js\").default;\nvar _objectSpread = require(\"/Users/eimis/test-server/react_projects/legendary-lines-game/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nconst _excluded = [\"function_call\", \"stream\"],\n  _excluded2 = [\"tool_choice\", \"stream\"],\n  _excluded3 = [\"function_call\"];\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _AbstractChatCompletionRunner_instances, _AbstractChatCompletionRunner_getFinalContent, _AbstractChatCompletionRunner_getFinalMessage, _AbstractChatCompletionRunner_getFinalFunctionCall, _AbstractChatCompletionRunner_getFinalFunctionCallResult, _AbstractChatCompletionRunner_calculateTotalUsage, _AbstractChatCompletionRunner_validateParams, _AbstractChatCompletionRunner_stringifyFunctionCallResult;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbstractChatCompletionRunner = void 0;\nconst error_1 = require(\"../error.js\");\nconst RunnableFunction_1 = require(\"./RunnableFunction.js\");\nconst chatCompletionUtils_1 = require(\"./chatCompletionUtils.js\");\nconst EventStream_1 = require(\"./EventStream.js\");\nconst parser_1 = require(\"../lib/parser.js\");\nconst DEFAULT_MAX_CHAT_COMPLETIONS = 10;\nclass AbstractChatCompletionRunner extends EventStream_1.EventStream {\n  constructor() {\n    super(...arguments);\n    _AbstractChatCompletionRunner_instances.add(this);\n    this._chatCompletions = [];\n    this.messages = [];\n  }\n  _addChatCompletion(chatCompletion) {\n    var _chatCompletion$choic;\n    this._chatCompletions.push(chatCompletion);\n    this._emit('chatCompletion', chatCompletion);\n    const message = (_chatCompletion$choic = chatCompletion.choices[0]) === null || _chatCompletion$choic === void 0 ? void 0 : _chatCompletion$choic.message;\n    if (message) this._addMessage(message);\n    return chatCompletion;\n  }\n  _addMessage(message) {\n    let emit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (!('content' in message)) message.content = null;\n    this.messages.push(message);\n    if (emit) {\n      this._emit('message', message);\n      if (((0, chatCompletionUtils_1.isFunctionMessage)(message) || (0, chatCompletionUtils_1.isToolMessage)(message)) && message.content) {\n        // Note, this assumes that {role: 'tool', content: …} is always the result of a call of tool of type=function.\n        this._emit('functionCallResult', message.content);\n      } else if ((0, chatCompletionUtils_1.isAssistantMessage)(message) && message.function_call) {\n        this._emit('functionCall', message.function_call);\n      } else if ((0, chatCompletionUtils_1.isAssistantMessage)(message) && message.tool_calls) {\n        for (const tool_call of message.tool_calls) {\n          if (tool_call.type === 'function') {\n            this._emit('functionCall', tool_call.function);\n          }\n        }\n      }\n    }\n  }\n  /**\n   * @returns a promise that resolves with the final ChatCompletion, or rejects\n   * if an error occurred or the stream ended prematurely without producing a ChatCompletion.\n   */\n  async finalChatCompletion() {\n    await this.done();\n    const completion = this._chatCompletions[this._chatCompletions.length - 1];\n    if (!completion) throw new error_1.OpenAIError('stream ended without producing a ChatCompletion');\n    return completion;\n  }\n  /**\n   * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects\n   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n   */\n  async finalContent() {\n    await this.done();\n    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalContent).call(this);\n  }\n  /**\n   * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,\n   * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n   */\n  async finalMessage() {\n    await this.done();\n    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalMessage).call(this);\n  }\n  /**\n   * @returns a promise that resolves with the content of the final FunctionCall, or rejects\n   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n   */\n  async finalFunctionCall() {\n    await this.done();\n    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);\n  }\n  async finalFunctionCallResult() {\n    await this.done();\n    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);\n  }\n  async totalUsage() {\n    await this.done();\n    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);\n  }\n  allChatCompletions() {\n    return [...this._chatCompletions];\n  }\n  _emitFinal() {\n    const completion = this._chatCompletions[this._chatCompletions.length - 1];\n    if (completion) this._emit('finalChatCompletion', completion);\n    const finalMessage = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalMessage).call(this);\n    if (finalMessage) this._emit('finalMessage', finalMessage);\n    const finalContent = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalContent).call(this);\n    if (finalContent) this._emit('finalContent', finalContent);\n    const finalFunctionCall = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);\n    if (finalFunctionCall) this._emit('finalFunctionCall', finalFunctionCall);\n    const finalFunctionCallResult = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);\n    if (finalFunctionCallResult != null) this._emit('finalFunctionCallResult', finalFunctionCallResult);\n    if (this._chatCompletions.some(c => c.usage)) {\n      this._emit('totalUsage', __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));\n    }\n  }\n  async _createChatCompletion(client, params, options) {\n    const signal = options === null || options === void 0 ? void 0 : options.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_validateParams).call(this, params);\n    const chatCompletion = await client.chat.completions.create(_objectSpread(_objectSpread({}, params), {}, {\n      stream: false\n    }), _objectSpread(_objectSpread({}, options), {}, {\n      signal: this.controller.signal\n    }));\n    this._connected();\n    return this._addChatCompletion((0, parser_1.parseChatCompletion)(chatCompletion, params));\n  }\n  async _runChatCompletion(client, params, options) {\n    for (const message of params.messages) {\n      this._addMessage(message, false);\n    }\n    return await this._createChatCompletion(client, params, options);\n  }\n  async _runFunctions(client, params, options) {\n    const role = 'function';\n    const {\n        function_call = 'auto',\n        stream\n      } = params,\n      restParams = _objectWithoutProperties(params, _excluded);\n    const singleFunctionToCall = typeof function_call !== 'string' && (function_call === null || function_call === void 0 ? void 0 : function_call.name);\n    const {\n      maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS\n    } = options || {};\n    const functionsByName = {};\n    for (const f of params.functions) {\n      functionsByName[f.name || f.function.name] = f;\n    }\n    const functions = params.functions.map(f => ({\n      name: f.name || f.function.name,\n      parameters: f.parameters,\n      description: f.description\n    }));\n    for (const message of params.messages) {\n      this._addMessage(message, false);\n    }\n    for (let i = 0; i < maxChatCompletions; ++i) {\n      var _chatCompletion$choic2;\n      const chatCompletion = await this._createChatCompletion(client, _objectSpread(_objectSpread({}, restParams), {}, {\n        function_call,\n        functions,\n        messages: [...this.messages]\n      }), options);\n      const message = (_chatCompletion$choic2 = chatCompletion.choices[0]) === null || _chatCompletion$choic2 === void 0 ? void 0 : _chatCompletion$choic2.message;\n      if (!message) {\n        throw new error_1.OpenAIError(\"missing message in ChatCompletion response\");\n      }\n      if (!message.function_call) return;\n      const {\n        name,\n        arguments: args\n      } = message.function_call;\n      const fn = functionsByName[name];\n      if (!fn) {\n        const content = \"Invalid function_call: \".concat(JSON.stringify(name), \". Available options are: \").concat(functions.map(f => JSON.stringify(f.name)).join(', '), \". Please try again\");\n        this._addMessage({\n          role,\n          name,\n          content\n        });\n        continue;\n      } else if (singleFunctionToCall && singleFunctionToCall !== name) {\n        const content = \"Invalid function_call: \".concat(JSON.stringify(name), \". \").concat(JSON.stringify(singleFunctionToCall), \" requested. Please try again\");\n        this._addMessage({\n          role,\n          name,\n          content\n        });\n        continue;\n      }\n      let parsed;\n      try {\n        parsed = (0, RunnableFunction_1.isRunnableFunctionWithParse)(fn) ? await fn.parse(args) : args;\n      } catch (error) {\n        this._addMessage({\n          role,\n          name,\n          content: error instanceof Error ? error.message : String(error)\n        });\n        continue;\n      }\n      // @ts-expect-error it can't rule out `never` type.\n      const rawContent = await fn.function(parsed, this);\n      const content = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);\n      this._addMessage({\n        role,\n        name,\n        content\n      });\n      if (singleFunctionToCall) return;\n    }\n  }\n  async _runTools(client, params, options) {\n    var _tool_choice$function;\n    const role = 'tool';\n    const {\n        tool_choice = 'auto',\n        stream\n      } = params,\n      restParams = _objectWithoutProperties(params, _excluded2);\n    const singleFunctionToCall = typeof tool_choice !== 'string' && (tool_choice === null || tool_choice === void 0 || (_tool_choice$function = tool_choice.function) === null || _tool_choice$function === void 0 ? void 0 : _tool_choice$function.name);\n    const {\n      maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS\n    } = options || {};\n    // TODO(someday): clean this logic up\n    const inputTools = params.tools.map(tool => {\n      if ((0, parser_1.isAutoParsableTool)(tool)) {\n        if (!tool.$callback) {\n          throw new error_1.OpenAIError('Tool given to `.runTools()` that does not have an associated function');\n        }\n        return {\n          type: 'function',\n          function: {\n            function: tool.$callback,\n            name: tool.function.name,\n            description: tool.function.description || '',\n            parameters: tool.function.parameters,\n            parse: tool.$parseRaw,\n            strict: true\n          }\n        };\n      }\n      return tool;\n    });\n    const functionsByName = {};\n    for (const f of inputTools) {\n      if (f.type === 'function') {\n        functionsByName[f.function.name || f.function.function.name] = f.function;\n      }\n    }\n    const tools = 'tools' in params ? inputTools.map(t => t.type === 'function' ? {\n      type: 'function',\n      function: {\n        name: t.function.name || t.function.function.name,\n        parameters: t.function.parameters,\n        description: t.function.description,\n        strict: t.function.strict\n      }\n    } : t) : undefined;\n    for (const message of params.messages) {\n      this._addMessage(message, false);\n    }\n    for (let i = 0; i < maxChatCompletions; ++i) {\n      var _chatCompletion$choic3, _message$tool_calls;\n      const chatCompletion = await this._createChatCompletion(client, _objectSpread(_objectSpread({}, restParams), {}, {\n        tool_choice,\n        tools,\n        messages: [...this.messages]\n      }), options);\n      const message = (_chatCompletion$choic3 = chatCompletion.choices[0]) === null || _chatCompletion$choic3 === void 0 ? void 0 : _chatCompletion$choic3.message;\n      if (!message) {\n        throw new error_1.OpenAIError(\"missing message in ChatCompletion response\");\n      }\n      if (!((_message$tool_calls = message.tool_calls) !== null && _message$tool_calls !== void 0 && _message$tool_calls.length)) {\n        return;\n      }\n      for (const tool_call of message.tool_calls) {\n        if (tool_call.type !== 'function') continue;\n        const tool_call_id = tool_call.id;\n        const {\n          name,\n          arguments: args\n        } = tool_call.function;\n        const fn = functionsByName[name];\n        if (!fn) {\n          const content = \"Invalid tool_call: \".concat(JSON.stringify(name), \". Available options are: \").concat(Object.keys(functionsByName).map(name => JSON.stringify(name)).join(', '), \". Please try again\");\n          this._addMessage({\n            role,\n            tool_call_id,\n            content\n          });\n          continue;\n        } else if (singleFunctionToCall && singleFunctionToCall !== name) {\n          const content = \"Invalid tool_call: \".concat(JSON.stringify(name), \". \").concat(JSON.stringify(singleFunctionToCall), \" requested. Please try again\");\n          this._addMessage({\n            role,\n            tool_call_id,\n            content\n          });\n          continue;\n        }\n        let parsed;\n        try {\n          parsed = (0, RunnableFunction_1.isRunnableFunctionWithParse)(fn) ? await fn.parse(args) : args;\n        } catch (error) {\n          const content = error instanceof Error ? error.message : String(error);\n          this._addMessage({\n            role,\n            tool_call_id,\n            content\n          });\n          continue;\n        }\n        // @ts-expect-error it can't rule out `never` type.\n        const rawContent = await fn.function(parsed, this);\n        const content = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);\n        this._addMessage({\n          role,\n          tool_call_id,\n          content\n        });\n        if (singleFunctionToCall) {\n          return;\n        }\n      }\n    }\n    return;\n  }\n}\nexports.AbstractChatCompletionRunner = AbstractChatCompletionRunner;\n_AbstractChatCompletionRunner_instances = new WeakSet(), _AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent() {\n  var _classPrivateFieldGe;\n  return (_classPrivateFieldGe = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, \"m\", _AbstractChatCompletionRunner_getFinalMessage).call(this).content) !== null && _classPrivateFieldGe !== void 0 ? _classPrivateFieldGe : null;\n}, _AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage() {\n  let i = this.messages.length;\n  while (i-- > 0) {\n    const message = this.messages[i];\n    if ((0, chatCompletionUtils_1.isAssistantMessage)(message)) {\n      var _message$content, _message$refusal;\n      const {\n          function_call\n        } = message,\n        rest = _objectWithoutProperties(message, _excluded3);\n      // TODO: support audio here\n      const ret = _objectSpread(_objectSpread({}, rest), {}, {\n        content: (_message$content = message.content) !== null && _message$content !== void 0 ? _message$content : null,\n        refusal: (_message$refusal = message.refusal) !== null && _message$refusal !== void 0 ? _message$refusal : null\n      });\n      if (function_call) {\n        ret.function_call = function_call;\n      }\n      return ret;\n    }\n  }\n  throw new error_1.OpenAIError('stream ended without producing a ChatCompletionMessage with role=assistant');\n}, _AbstractChatCompletionRunner_getFinalFunctionCall = function _AbstractChatCompletionRunner_getFinalFunctionCall() {\n  for (let i = this.messages.length - 1; i >= 0; i--) {\n    var _message$tool_calls2;\n    const message = this.messages[i];\n    if ((0, chatCompletionUtils_1.isAssistantMessage)(message) && message !== null && message !== void 0 && message.function_call) {\n      return message.function_call;\n    }\n    if ((0, chatCompletionUtils_1.isAssistantMessage)(message) && message !== null && message !== void 0 && (_message$tool_calls2 = message.tool_calls) !== null && _message$tool_calls2 !== void 0 && _message$tool_calls2.length) {\n      var _message$tool_calls$a;\n      return (_message$tool_calls$a = message.tool_calls.at(-1)) === null || _message$tool_calls$a === void 0 ? void 0 : _message$tool_calls$a.function;\n    }\n  }\n  return;\n}, _AbstractChatCompletionRunner_getFinalFunctionCallResult = function _AbstractChatCompletionRunner_getFinalFunctionCallResult() {\n  for (let i = this.messages.length - 1; i >= 0; i--) {\n    const message = this.messages[i];\n    if ((0, chatCompletionUtils_1.isFunctionMessage)(message) && message.content != null) {\n      return message.content;\n    }\n    if ((0, chatCompletionUtils_1.isToolMessage)(message) && message.content != null && typeof message.content === 'string' && this.messages.some(x => {\n      var _x$tool_calls;\n      return x.role === 'assistant' && ((_x$tool_calls = x.tool_calls) === null || _x$tool_calls === void 0 ? void 0 : _x$tool_calls.some(y => y.type === 'function' && y.id === message.tool_call_id));\n    })) {\n      return message.content;\n    }\n  }\n  return;\n}, _AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage() {\n  const total = {\n    completion_tokens: 0,\n    prompt_tokens: 0,\n    total_tokens: 0\n  };\n  for (const {\n    usage\n  } of this._chatCompletions) {\n    if (usage) {\n      total.completion_tokens += usage.completion_tokens;\n      total.prompt_tokens += usage.prompt_tokens;\n      total.total_tokens += usage.total_tokens;\n    }\n  }\n  return total;\n}, _AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams(params) {\n  if (params.n != null && params.n > 1) {\n    throw new error_1.OpenAIError('ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.');\n  }\n}, _AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult(rawContent) {\n  return typeof rawContent === 'string' ? rawContent : rawContent === undefined ? 'undefined' : JSON.stringify(rawContent);\n};","map":{"version":3,"names":["error_1","require","RunnableFunction_1","chatCompletionUtils_1","EventStream_1","parser_1","DEFAULT_MAX_CHAT_COMPLETIONS","AbstractChatCompletionRunner","EventStream","constructor","_chatCompletions","messages","_addChatCompletion","chatCompletion","_chatCompletion$choic","push","_emit","message","choices","_addMessage","emit","arguments","length","undefined","content","isFunctionMessage","isToolMessage","isAssistantMessage","function_call","tool_calls","tool_call","type","function","finalChatCompletion","done","completion","OpenAIError","finalContent","__classPrivateFieldGet","_AbstractChatCompletionRunner_instances","_AbstractChatCompletionRunner_getFinalContent","call","finalMessage","_AbstractChatCompletionRunner_getFinalMessage","finalFunctionCall","_AbstractChatCompletionRunner_getFinalFunctionCall","finalFunctionCallResult","_AbstractChatCompletionRunner_getFinalFunctionCallResult","totalUsage","_AbstractChatCompletionRunner_calculateTotalUsage","allChatCompletions","_emitFinal","some","c","usage","_createChatCompletion","client","params","options","signal","aborted","controller","abort","addEventListener","_AbstractChatCompletionRunner_validateParams","chat","completions","create","_objectSpread","stream","_connected","parseChatCompletion","_runChatCompletion","_runFunctions","role","restParams","_objectWithoutProperties","_excluded","singleFunctionToCall","name","maxChatCompletions","functionsByName","f","functions","map","parameters","description","i","_chatCompletion$choic2","args","fn","concat","JSON","stringify","join","parsed","isRunnableFunctionWithParse","parse","error","Error","String","rawContent","_AbstractChatCompletionRunner_stringifyFunctionCallResult","_runTools","_tool_choice$function","tool_choice","_excluded2","inputTools","tools","tool","isAutoParsableTool","$callback","$parseRaw","strict","t","_chatCompletion$choic3","_message$tool_calls","tool_call_id","id","Object","keys","exports","_classPrivateFieldGe","_message$content","_message$refusal","rest","_excluded3","ret","refusal","_message$tool_calls2","_message$tool_calls$a","at","x","_x$tool_calls","y","total","completion_tokens","prompt_tokens","total_tokens","n"],"sources":["/Users/eimis/test-server/react_projects/legendary-lines-game/node_modules/openai/src/lib/AbstractChatCompletionRunner.ts"],"sourcesContent":["import * as Core from '../core';\nimport { type CompletionUsage } from '../resources/completions';\nimport {\n  type ChatCompletion,\n  type ChatCompletionMessage,\n  type ChatCompletionMessageParam,\n  type ChatCompletionCreateParams,\n  type ChatCompletionTool,\n} from '../resources/chat/completions';\nimport { OpenAIError } from '../error';\nimport {\n  type RunnableFunction,\n  isRunnableFunctionWithParse,\n  type BaseFunctionsArgs,\n  RunnableToolFunction,\n} from './RunnableFunction';\nimport { ChatCompletionFunctionRunnerParams, ChatCompletionToolRunnerParams } from './ChatCompletionRunner';\nimport {\n  ChatCompletionStreamingFunctionRunnerParams,\n  ChatCompletionStreamingToolRunnerParams,\n} from './ChatCompletionStreamingRunner';\nimport { isAssistantMessage, isFunctionMessage, isToolMessage } from './chatCompletionUtils';\nimport { BaseEvents, EventStream } from './EventStream';\nimport { ParsedChatCompletion } from '../resources/beta/chat/completions';\nimport OpenAI from '../index';\nimport { isAutoParsableTool, parseChatCompletion } from '../lib/parser';\n\nconst DEFAULT_MAX_CHAT_COMPLETIONS = 10;\nexport interface RunnerOptions extends Core.RequestOptions {\n  /** How many requests to make before canceling. Default 10. */\n  maxChatCompletions?: number;\n}\n\nexport class AbstractChatCompletionRunner<\n  EventTypes extends AbstractChatCompletionRunnerEvents,\n  ParsedT,\n> extends EventStream<EventTypes> {\n  protected _chatCompletions: ParsedChatCompletion<ParsedT>[] = [];\n  messages: ChatCompletionMessageParam[] = [];\n\n  protected _addChatCompletion(\n    this: AbstractChatCompletionRunner<AbstractChatCompletionRunnerEvents, ParsedT>,\n    chatCompletion: ParsedChatCompletion<ParsedT>,\n  ): ParsedChatCompletion<ParsedT> {\n    this._chatCompletions.push(chatCompletion);\n    this._emit('chatCompletion', chatCompletion);\n    const message = chatCompletion.choices[0]?.message;\n    if (message) this._addMessage(message as ChatCompletionMessageParam);\n    return chatCompletion;\n  }\n\n  protected _addMessage(\n    this: AbstractChatCompletionRunner<AbstractChatCompletionRunnerEvents, ParsedT>,\n    message: ChatCompletionMessageParam,\n    emit = true,\n  ) {\n    if (!('content' in message)) message.content = null;\n\n    this.messages.push(message);\n\n    if (emit) {\n      this._emit('message', message);\n      if ((isFunctionMessage(message) || isToolMessage(message)) && message.content) {\n        // Note, this assumes that {role: 'tool', content: …} is always the result of a call of tool of type=function.\n        this._emit('functionCallResult', message.content as string);\n      } else if (isAssistantMessage(message) && message.function_call) {\n        this._emit('functionCall', message.function_call);\n      } else if (isAssistantMessage(message) && message.tool_calls) {\n        for (const tool_call of message.tool_calls) {\n          if (tool_call.type === 'function') {\n            this._emit('functionCall', tool_call.function);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @returns a promise that resolves with the final ChatCompletion, or rejects\n   * if an error occurred or the stream ended prematurely without producing a ChatCompletion.\n   */\n  async finalChatCompletion(): Promise<ParsedChatCompletion<ParsedT>> {\n    await this.done();\n    const completion = this._chatCompletions[this._chatCompletions.length - 1];\n    if (!completion) throw new OpenAIError('stream ended without producing a ChatCompletion');\n    return completion;\n  }\n\n  #getFinalContent(): string | null {\n    return this.#getFinalMessage().content ?? null;\n  }\n\n  /**\n   * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects\n   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n   */\n  async finalContent(): Promise<string | null> {\n    await this.done();\n    return this.#getFinalContent();\n  }\n\n  #getFinalMessage(): ChatCompletionMessage {\n    let i = this.messages.length;\n    while (i-- > 0) {\n      const message = this.messages[i];\n      if (isAssistantMessage(message)) {\n        const { function_call, ...rest } = message;\n\n        // TODO: support audio here\n        const ret: Omit<ChatCompletionMessage, 'audio'> = {\n          ...rest,\n          content: (message as ChatCompletionMessage).content ?? null,\n          refusal: (message as ChatCompletionMessage).refusal ?? null,\n        };\n        if (function_call) {\n          ret.function_call = function_call;\n        }\n        return ret;\n      }\n    }\n    throw new OpenAIError('stream ended without producing a ChatCompletionMessage with role=assistant');\n  }\n\n  /**\n   * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,\n   * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n   */\n  async finalMessage(): Promise<ChatCompletionMessage> {\n    await this.done();\n    return this.#getFinalMessage();\n  }\n\n  #getFinalFunctionCall(): ChatCompletionMessage.FunctionCall | undefined {\n    for (let i = this.messages.length - 1; i >= 0; i--) {\n      const message = this.messages[i];\n      if (isAssistantMessage(message) && message?.function_call) {\n        return message.function_call;\n      }\n      if (isAssistantMessage(message) && message?.tool_calls?.length) {\n        return message.tool_calls.at(-1)?.function;\n      }\n    }\n\n    return;\n  }\n\n  /**\n   * @returns a promise that resolves with the content of the final FunctionCall, or rejects\n   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.\n   */\n  async finalFunctionCall(): Promise<ChatCompletionMessage.FunctionCall | undefined> {\n    await this.done();\n    return this.#getFinalFunctionCall();\n  }\n\n  #getFinalFunctionCallResult(): string | undefined {\n    for (let i = this.messages.length - 1; i >= 0; i--) {\n      const message = this.messages[i];\n      if (isFunctionMessage(message) && message.content != null) {\n        return message.content;\n      }\n      if (\n        isToolMessage(message) &&\n        message.content != null &&\n        typeof message.content === 'string' &&\n        this.messages.some(\n          (x) =>\n            x.role === 'assistant' &&\n            x.tool_calls?.some((y) => y.type === 'function' && y.id === message.tool_call_id),\n        )\n      ) {\n        return message.content;\n      }\n    }\n\n    return;\n  }\n\n  async finalFunctionCallResult(): Promise<string | undefined> {\n    await this.done();\n    return this.#getFinalFunctionCallResult();\n  }\n\n  #calculateTotalUsage(): CompletionUsage {\n    const total: CompletionUsage = {\n      completion_tokens: 0,\n      prompt_tokens: 0,\n      total_tokens: 0,\n    };\n    for (const { usage } of this._chatCompletions) {\n      if (usage) {\n        total.completion_tokens += usage.completion_tokens;\n        total.prompt_tokens += usage.prompt_tokens;\n        total.total_tokens += usage.total_tokens;\n      }\n    }\n    return total;\n  }\n\n  async totalUsage(): Promise<CompletionUsage> {\n    await this.done();\n    return this.#calculateTotalUsage();\n  }\n\n  allChatCompletions(): ChatCompletion[] {\n    return [...this._chatCompletions];\n  }\n\n  protected override _emitFinal(\n    this: AbstractChatCompletionRunner<AbstractChatCompletionRunnerEvents, ParsedT>,\n  ) {\n    const completion = this._chatCompletions[this._chatCompletions.length - 1];\n    if (completion) this._emit('finalChatCompletion', completion);\n    const finalMessage = this.#getFinalMessage();\n    if (finalMessage) this._emit('finalMessage', finalMessage);\n    const finalContent = this.#getFinalContent();\n    if (finalContent) this._emit('finalContent', finalContent);\n\n    const finalFunctionCall = this.#getFinalFunctionCall();\n    if (finalFunctionCall) this._emit('finalFunctionCall', finalFunctionCall);\n\n    const finalFunctionCallResult = this.#getFinalFunctionCallResult();\n    if (finalFunctionCallResult != null) this._emit('finalFunctionCallResult', finalFunctionCallResult);\n\n    if (this._chatCompletions.some((c) => c.usage)) {\n      this._emit('totalUsage', this.#calculateTotalUsage());\n    }\n  }\n\n  #validateParams(params: ChatCompletionCreateParams): void {\n    if (params.n != null && params.n > 1) {\n      throw new OpenAIError(\n        'ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.',\n      );\n    }\n  }\n\n  protected async _createChatCompletion(\n    client: OpenAI,\n    params: ChatCompletionCreateParams,\n    options?: Core.RequestOptions,\n  ): Promise<ParsedChatCompletion<ParsedT>> {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    this.#validateParams(params);\n\n    const chatCompletion = await client.chat.completions.create(\n      { ...params, stream: false },\n      { ...options, signal: this.controller.signal },\n    );\n    this._connected();\n    return this._addChatCompletion(parseChatCompletion(chatCompletion, params));\n  }\n\n  protected async _runChatCompletion(\n    client: OpenAI,\n    params: ChatCompletionCreateParams,\n    options?: Core.RequestOptions,\n  ): Promise<ChatCompletion> {\n    for (const message of params.messages) {\n      this._addMessage(message, false);\n    }\n    return await this._createChatCompletion(client, params, options);\n  }\n\n  protected async _runFunctions<FunctionsArgs extends BaseFunctionsArgs>(\n    client: OpenAI,\n    params:\n      | ChatCompletionFunctionRunnerParams<FunctionsArgs>\n      | ChatCompletionStreamingFunctionRunnerParams<FunctionsArgs>,\n    options?: RunnerOptions,\n  ) {\n    const role = 'function' as const;\n    const { function_call = 'auto', stream, ...restParams } = params;\n    const singleFunctionToCall = typeof function_call !== 'string' && function_call?.name;\n    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};\n\n    const functionsByName: Record<string, RunnableFunction<any>> = {};\n    for (const f of params.functions) {\n      functionsByName[f.name || f.function.name] = f;\n    }\n\n    const functions: ChatCompletionCreateParams.Function[] = params.functions.map(\n      (f): ChatCompletionCreateParams.Function => ({\n        name: f.name || f.function.name,\n        parameters: f.parameters as Record<string, unknown>,\n        description: f.description,\n      }),\n    );\n\n    for (const message of params.messages) {\n      this._addMessage(message, false);\n    }\n\n    for (let i = 0; i < maxChatCompletions; ++i) {\n      const chatCompletion: ChatCompletion = await this._createChatCompletion(\n        client,\n        {\n          ...restParams,\n          function_call,\n          functions,\n          messages: [...this.messages],\n        },\n        options,\n      );\n      const message = chatCompletion.choices[0]?.message;\n      if (!message) {\n        throw new OpenAIError(`missing message in ChatCompletion response`);\n      }\n      if (!message.function_call) return;\n      const { name, arguments: args } = message.function_call;\n      const fn = functionsByName[name];\n      if (!fn) {\n        const content = `Invalid function_call: ${JSON.stringify(name)}. Available options are: ${functions\n          .map((f) => JSON.stringify(f.name))\n          .join(', ')}. Please try again`;\n\n        this._addMessage({ role, name, content });\n        continue;\n      } else if (singleFunctionToCall && singleFunctionToCall !== name) {\n        const content = `Invalid function_call: ${JSON.stringify(name)}. ${JSON.stringify(\n          singleFunctionToCall,\n        )} requested. Please try again`;\n\n        this._addMessage({ role, name, content });\n        continue;\n      }\n\n      let parsed;\n      try {\n        parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;\n      } catch (error) {\n        this._addMessage({\n          role,\n          name,\n          content: error instanceof Error ? error.message : String(error),\n        });\n        continue;\n      }\n\n      // @ts-expect-error it can't rule out `never` type.\n      const rawContent = await fn.function(parsed, this);\n      const content = this.#stringifyFunctionCallResult(rawContent);\n\n      this._addMessage({ role, name, content });\n\n      if (singleFunctionToCall) return;\n    }\n  }\n\n  protected async _runTools<FunctionsArgs extends BaseFunctionsArgs>(\n    client: OpenAI,\n    params:\n      | ChatCompletionToolRunnerParams<FunctionsArgs>\n      | ChatCompletionStreamingToolRunnerParams<FunctionsArgs>,\n    options?: RunnerOptions,\n  ) {\n    const role = 'tool' as const;\n    const { tool_choice = 'auto', stream, ...restParams } = params;\n    const singleFunctionToCall = typeof tool_choice !== 'string' && tool_choice?.function?.name;\n    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};\n\n    // TODO(someday): clean this logic up\n    const inputTools = params.tools.map((tool): RunnableToolFunction<any> => {\n      if (isAutoParsableTool(tool)) {\n        if (!tool.$callback) {\n          throw new OpenAIError('Tool given to `.runTools()` that does not have an associated function');\n        }\n\n        return {\n          type: 'function',\n          function: {\n            function: tool.$callback,\n            name: tool.function.name,\n            description: tool.function.description || '',\n            parameters: tool.function.parameters as any,\n            parse: tool.$parseRaw,\n            strict: true,\n          },\n        };\n      }\n\n      return tool as any as RunnableToolFunction<any>;\n    });\n\n    const functionsByName: Record<string, RunnableFunction<any>> = {};\n    for (const f of inputTools) {\n      if (f.type === 'function') {\n        functionsByName[f.function.name || f.function.function.name] = f.function;\n      }\n    }\n\n    const tools: ChatCompletionTool[] =\n      'tools' in params ?\n        inputTools.map((t) =>\n          t.type === 'function' ?\n            {\n              type: 'function',\n              function: {\n                name: t.function.name || t.function.function.name,\n                parameters: t.function.parameters as Record<string, unknown>,\n                description: t.function.description,\n                strict: t.function.strict,\n              },\n            }\n          : (t as unknown as ChatCompletionTool),\n        )\n      : (undefined as any);\n\n    for (const message of params.messages) {\n      this._addMessage(message, false);\n    }\n\n    for (let i = 0; i < maxChatCompletions; ++i) {\n      const chatCompletion: ChatCompletion = await this._createChatCompletion(\n        client,\n        {\n          ...restParams,\n          tool_choice,\n          tools,\n          messages: [...this.messages],\n        },\n        options,\n      );\n      const message = chatCompletion.choices[0]?.message;\n      if (!message) {\n        throw new OpenAIError(`missing message in ChatCompletion response`);\n      }\n      if (!message.tool_calls?.length) {\n        return;\n      }\n\n      for (const tool_call of message.tool_calls) {\n        if (tool_call.type !== 'function') continue;\n        const tool_call_id = tool_call.id;\n        const { name, arguments: args } = tool_call.function;\n        const fn = functionsByName[name];\n\n        if (!fn) {\n          const content = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${Object.keys(\n            functionsByName,\n          )\n            .map((name) => JSON.stringify(name))\n            .join(', ')}. Please try again`;\n\n          this._addMessage({ role, tool_call_id, content });\n          continue;\n        } else if (singleFunctionToCall && singleFunctionToCall !== name) {\n          const content = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(\n            singleFunctionToCall,\n          )} requested. Please try again`;\n\n          this._addMessage({ role, tool_call_id, content });\n          continue;\n        }\n\n        let parsed;\n        try {\n          parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;\n        } catch (error) {\n          const content = error instanceof Error ? error.message : String(error);\n          this._addMessage({ role, tool_call_id, content });\n          continue;\n        }\n\n        // @ts-expect-error it can't rule out `never` type.\n        const rawContent = await fn.function(parsed, this);\n        const content = this.#stringifyFunctionCallResult(rawContent);\n        this._addMessage({ role, tool_call_id, content });\n\n        if (singleFunctionToCall) {\n          return;\n        }\n      }\n    }\n\n    return;\n  }\n\n  #stringifyFunctionCallResult(rawContent: unknown): string {\n    return (\n      typeof rawContent === 'string' ? rawContent\n      : rawContent === undefined ? 'undefined'\n      : JSON.stringify(rawContent)\n    );\n  }\n}\n\nexport interface AbstractChatCompletionRunnerEvents extends BaseEvents {\n  functionCall: (functionCall: ChatCompletionMessage.FunctionCall) => void;\n  message: (message: ChatCompletionMessageParam) => void;\n  chatCompletion: (completion: ChatCompletion) => void;\n  finalContent: (contentSnapshot: string) => void;\n  finalMessage: (message: ChatCompletionMessageParam) => void;\n  finalChatCompletion: (completion: ChatCompletion) => void;\n  finalFunctionCall: (functionCall: ChatCompletionMessage.FunctionCall) => void;\n  functionCallResult: (content: string) => void;\n  finalFunctionCallResult: (content: string) => void;\n  totalUsage: (usage: CompletionUsage) => void;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}