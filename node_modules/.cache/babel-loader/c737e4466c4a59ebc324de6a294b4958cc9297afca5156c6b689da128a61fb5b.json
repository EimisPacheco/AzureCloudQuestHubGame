{"ast":null,"code":"import { __asyncGenerator, __await } from \"tslib\";\nimport { ChangeFeedIteratorResponse } from \"./ChangeFeedIteratorResponse\";\nimport { Constants, copyObject, ResourceType, StatusCodes } from \"../../common\";\nimport { ErrorResponse } from \"../../request\";\nimport { ContinuationTokenForPartitionKey } from \"./ContinuationTokenForPartitionKey\";\nimport { convertToInternalPartitionKey } from \"../../documents\";\nimport { getEmptyCosmosDiagnostics, withDiagnostics } from \"../../utils/diagnostics\";\nimport { ChangeFeedMode } from \"./ChangeFeedMode\";\nimport { decryptChangeFeedResponse } from \"./changeFeedUtils\";\n/**\n * @hidden\n * Provides iterator for change feed for one partition key.\n *\n * Use `Items.getChangeFeedIterator()` to get an instance of the iterator.\n */\nexport class ChangeFeedForPartitionKey {\n  /**\n   * @internal\n   */\n  constructor(clientContext, container, resourceId, resourceLink, partitionKey, changeFeedOptions) {\n    this.clientContext = clientContext;\n    this.container = container;\n    this.resourceId = resourceId;\n    this.resourceLink = resourceLink;\n    this.partitionKey = partitionKey;\n    this.changeFeedOptions = changeFeedOptions;\n    this.continuationToken = changeFeedOptions.continuationToken ? JSON.parse(changeFeedOptions.continuationToken) : undefined;\n    this.isInstantiated = false;\n    // startTime is used to store and specify time from which change feed should start reading new changes. StartFromNow flag is used to indicate fetching changes from now.\n    if (changeFeedOptions.startFromNow) {\n      this.startFromNow = true;\n    } else if (changeFeedOptions.startTime) {\n      this.startTime = changeFeedOptions.startTime.toUTCString();\n    }\n  }\n  async instantiateIterator(diagnosticNode) {\n    await this.setIteratorRid(diagnosticNode);\n    if (this.clientContext.enableEncryption) {\n      await this.container.checkAndInitializeEncryption();\n      // returns copy of object to avoid encryption of original partition key passed\n      this.partitionKey = copyObject(this.partitionKey);\n      diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsEncryptOperation);\n      const {\n        partitionKeyList,\n        encryptedCount\n      } = await this.container.encryptionProcessor.getEncryptedPartitionKeyValue(convertToInternalPartitionKey(this.partitionKey));\n      this.partitionKey = partitionKeyList;\n      diagnosticNode.endEncryptionDiagnostics(Constants.Encryption.DiagnosticsEncryptOperation, encryptedCount);\n    }\n    if (this.continuationToken) {\n      if (!this.continuationTokenRidMatchContainerRid()) {\n        throw new ErrorResponse(\"The continuation is not for the current container definition.\");\n      }\n    } else {\n      this.continuationToken = new ContinuationTokenForPartitionKey(this.rId, this.partitionKey, \"\");\n    }\n    this.isInstantiated = true;\n  }\n  continuationTokenRidMatchContainerRid() {\n    if (this.continuationToken.rid !== this.rId) {\n      return false;\n    }\n    return true;\n  }\n  async setIteratorRid(diagnosticNode) {\n    const {\n      resource\n    } = await this.container.readInternal(diagnosticNode);\n    this.rId = resource._rid;\n  }\n  /**\n   * Change feed is an infinite feed. hasMoreResults is always true.\n   */\n  get hasMoreResults() {\n    return true;\n  }\n  /**\n   * Gets an async iterator which will yield change feed results.\n   */\n  getAsyncIterator() {\n    return __asyncGenerator(this, arguments, function* getAsyncIterator_1() {\n      do {\n        const result = yield __await(this.readNext());\n        yield yield __await(result);\n      } while (this.hasMoreResults);\n    });\n  }\n  /**\n   * Returns the result of change feed from Azure Cosmos DB.\n   */\n  async readNext() {\n    return withDiagnostics(async diagnosticNode => {\n      if (!this.isInstantiated) {\n        await this.instantiateIterator(diagnosticNode);\n      }\n      const result = await this.fetchNext(diagnosticNode);\n      if (result.statusCode === StatusCodes.Ok) {\n        if (this.clientContext.enableEncryption) {\n          await decryptChangeFeedResponse(result, diagnosticNode, this.changeFeedOptions.changeFeedMode, this.container.encryptionProcessor);\n        }\n      }\n      return result;\n    }, this.clientContext);\n  }\n  /**\n   * Read feed and retrieves the next set of results in Azure Cosmos DB.\n   */\n  async fetchNext(diagnosticNode) {\n    const response = await this.getFeedResponse(diagnosticNode);\n    this.continuationToken.Continuation = response.headers[Constants.HttpHeaders.ETag];\n    response.headers[Constants.HttpHeaders.ContinuationToken] = JSON.stringify(this.continuationToken);\n    return response;\n  }\n  async getFeedResponse(diagnosticNode) {\n    const feedOptions = {\n      initialHeaders: {},\n      useLatestVersionFeed: true,\n      useAllVersionsAndDeletesFeed: false\n    };\n    if (typeof this.changeFeedOptions.maxItemCount === \"number\") {\n      feedOptions.maxItemCount = this.changeFeedOptions.maxItemCount;\n    }\n    if (this.changeFeedOptions.sessionToken) {\n      feedOptions.sessionToken = this.changeFeedOptions.sessionToken;\n    }\n    const continuation = this.continuationToken.Continuation;\n    if (continuation) {\n      feedOptions.accessCondition = {\n        type: Constants.HttpHeaders.IfNoneMatch,\n        condition: continuation\n      };\n    } else if (this.startFromNow) {\n      feedOptions.initialHeaders[Constants.HttpHeaders.IfNoneMatch] = Constants.ChangeFeedIfNoneMatchStartFromNowHeader;\n    }\n    if (this.startTime) {\n      feedOptions.initialHeaders[Constants.HttpHeaders.IfModifiedSince] = this.startTime;\n    }\n    if (this.changeFeedOptions.changeFeedMode && this.changeFeedOptions.changeFeedMode === ChangeFeedMode.AllVersionsAndDeletes) {\n      feedOptions.useAllVersionsAndDeletesFeed = true;\n      feedOptions.useLatestVersionFeed = false;\n    }\n    if (this.clientContext.enableEncryption) {\n      feedOptions.containerRid = this.container._rid;\n    }\n    try {\n      const response = await this.clientContext.queryFeed({\n        path: this.resourceLink,\n        resourceType: ResourceType.item,\n        resourceId: this.resourceId,\n        resultFn: result => result ? result.Documents : [],\n        diagnosticNode,\n        query: undefined,\n        options: feedOptions,\n        partitionKey: this.partitionKey\n      });\n      return new ChangeFeedIteratorResponse(response.result, response.result ? response.result.length : 0, response.code, response.headers, getEmptyCosmosDiagnostics());\n    } catch (err) {\n      // If any errors are encountered, throw the error.\n      const errorResponse = new ErrorResponse(err.message);\n      errorResponse.code = err.code;\n      errorResponse.headers = err.headers;\n      throw errorResponse;\n    }\n  }\n}","map":{"version":3,"names":["ChangeFeedIteratorResponse","Constants","copyObject","ResourceType","StatusCodes","ErrorResponse","ContinuationTokenForPartitionKey","convertToInternalPartitionKey","getEmptyCosmosDiagnostics","withDiagnostics","ChangeFeedMode","decryptChangeFeedResponse","ChangeFeedForPartitionKey","constructor","clientContext","container","resourceId","resourceLink","partitionKey","changeFeedOptions","continuationToken","JSON","parse","undefined","isInstantiated","startFromNow","startTime","toUTCString","instantiateIterator","diagnosticNode","setIteratorRid","enableEncryption","checkAndInitializeEncryption","beginEncryptionDiagnostics","Encryption","DiagnosticsEncryptOperation","partitionKeyList","encryptedCount","encryptionProcessor","getEncryptedPartitionKeyValue","endEncryptionDiagnostics","continuationTokenRidMatchContainerRid","rId","rid","resource","readInternal","_rid","hasMoreResults","getAsyncIterator","result","__await","readNext","fetchNext","statusCode","Ok","changeFeedMode","response","getFeedResponse","Continuation","headers","HttpHeaders","ETag","ContinuationToken","stringify","feedOptions","initialHeaders","useLatestVersionFeed","useAllVersionsAndDeletesFeed","maxItemCount","sessionToken","continuation","accessCondition","type","IfNoneMatch","condition","ChangeFeedIfNoneMatchStartFromNowHeader","IfModifiedSince","AllVersionsAndDeletes","containerRid","queryFeed","path","resourceType","item","resultFn","Documents","query","options","length","code","err","errorResponse","message"],"sources":["/Users/eimis/test-server/Azure Hackthons/azure-cloud-architecture-game /node_modules/@azure/cosmos/src/client/ChangeFeed/ChangeFeedForPartitionKey.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { InternalChangeFeedIteratorOptions } from \"./InternalChangeFeedOptions\";\nimport { ChangeFeedIteratorResponse } from \"./ChangeFeedIteratorResponse\";\nimport { Container, Resource } from \"../../client\";\nimport { ClientContext } from \"../../ClientContext\";\nimport { Constants, copyObject, ResourceType, StatusCodes } from \"../../common\";\nimport { FeedOptions, Response, ErrorResponse } from \"../../request\";\nimport { ContinuationTokenForPartitionKey } from \"./ContinuationTokenForPartitionKey\";\nimport { ChangeFeedPullModelIterator } from \"./ChangeFeedPullModelIterator\";\nimport { PartitionKey, convertToInternalPartitionKey } from \"../../documents\";\nimport { DiagnosticNodeInternal } from \"../../diagnostics/DiagnosticNodeInternal\";\nimport { getEmptyCosmosDiagnostics, withDiagnostics } from \"../../utils/diagnostics\";\nimport { ChangeFeedMode } from \"./ChangeFeedMode\";\nimport { decryptChangeFeedResponse } from \"./changeFeedUtils\";\n/**\n * @hidden\n * Provides iterator for change feed for one partition key.\n *\n * Use `Items.getChangeFeedIterator()` to get an instance of the iterator.\n */\nexport class ChangeFeedForPartitionKey<T> implements ChangeFeedPullModelIterator<T> {\n  private continuationToken: ContinuationTokenForPartitionKey;\n  private startTime: string;\n  private rId: string;\n  private isInstantiated: boolean;\n  private startFromNow: boolean;\n  /**\n   * @internal\n   */\n  constructor(\n    private clientContext: ClientContext,\n    private container: Container,\n    private resourceId: string,\n    private resourceLink: string,\n    private partitionKey: PartitionKey,\n    private changeFeedOptions: InternalChangeFeedIteratorOptions,\n  ) {\n    this.continuationToken = changeFeedOptions.continuationToken\n      ? JSON.parse(changeFeedOptions.continuationToken)\n      : undefined;\n    this.isInstantiated = false;\n    // startTime is used to store and specify time from which change feed should start reading new changes. StartFromNow flag is used to indicate fetching changes from now.\n    if (changeFeedOptions.startFromNow) {\n      this.startFromNow = true;\n    } else if (changeFeedOptions.startTime) {\n      this.startTime = changeFeedOptions.startTime.toUTCString();\n    }\n  }\n\n  private async instantiateIterator(diagnosticNode: DiagnosticNodeInternal): Promise<void> {\n    await this.setIteratorRid(diagnosticNode);\n    if (this.clientContext.enableEncryption) {\n      await this.container.checkAndInitializeEncryption();\n      // returns copy of object to avoid encryption of original partition key passed\n      this.partitionKey = copyObject(this.partitionKey);\n      diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsEncryptOperation);\n      const { partitionKeyList, encryptedCount } =\n        await this.container.encryptionProcessor.getEncryptedPartitionKeyValue(\n          convertToInternalPartitionKey(this.partitionKey),\n        );\n      this.partitionKey = partitionKeyList;\n      diagnosticNode.endEncryptionDiagnostics(\n        Constants.Encryption.DiagnosticsEncryptOperation,\n        encryptedCount,\n      );\n    }\n    if (this.continuationToken) {\n      if (!this.continuationTokenRidMatchContainerRid()) {\n        throw new ErrorResponse(\"The continuation is not for the current container definition.\");\n      }\n    } else {\n      this.continuationToken = new ContinuationTokenForPartitionKey(\n        this.rId,\n        this.partitionKey,\n        \"\",\n      );\n    }\n\n    this.isInstantiated = true;\n  }\n\n  private continuationTokenRidMatchContainerRid(): boolean {\n    if (this.continuationToken.rid !== this.rId) {\n      return false;\n    }\n    return true;\n  }\n\n  private async setIteratorRid(diagnosticNode: DiagnosticNodeInternal): Promise<void> {\n    const { resource } = await this.container.readInternal(diagnosticNode);\n    this.rId = resource._rid;\n  }\n\n  /**\n   * Change feed is an infinite feed. hasMoreResults is always true.\n   */\n  get hasMoreResults(): boolean {\n    return true;\n  }\n\n  /**\n   * Gets an async iterator which will yield change feed results.\n   */\n  public async *getAsyncIterator(): AsyncIterable<ChangeFeedIteratorResponse<Array<T & Resource>>> {\n    do {\n      const result = await this.readNext();\n      yield result;\n    } while (this.hasMoreResults);\n  }\n\n  /**\n   * Returns the result of change feed from Azure Cosmos DB.\n   */\n  public async readNext(): Promise<ChangeFeedIteratorResponse<Array<T & Resource>>> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      if (!this.isInstantiated) {\n        await this.instantiateIterator(diagnosticNode);\n      }\n      const result = await this.fetchNext(diagnosticNode);\n      if (result.statusCode === StatusCodes.Ok) {\n        if (this.clientContext.enableEncryption) {\n          await decryptChangeFeedResponse(\n            result,\n            diagnosticNode,\n            this.changeFeedOptions.changeFeedMode,\n            this.container.encryptionProcessor,\n          );\n        }\n      }\n      return result;\n    }, this.clientContext);\n  }\n\n  /**\n   * Read feed and retrieves the next set of results in Azure Cosmos DB.\n   */\n  private async fetchNext(\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<ChangeFeedIteratorResponse<Array<T & Resource>>> {\n    const response = await this.getFeedResponse(diagnosticNode);\n    this.continuationToken.Continuation = response.headers[Constants.HttpHeaders.ETag];\n    response.headers[Constants.HttpHeaders.ContinuationToken] = JSON.stringify(\n      this.continuationToken,\n    );\n    return response;\n  }\n\n  private async getFeedResponse(\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<ChangeFeedIteratorResponse<Array<T & Resource>>> {\n    const feedOptions: FeedOptions = {\n      initialHeaders: {},\n      useLatestVersionFeed: true,\n      useAllVersionsAndDeletesFeed: false,\n    };\n    if (typeof this.changeFeedOptions.maxItemCount === \"number\") {\n      feedOptions.maxItemCount = this.changeFeedOptions.maxItemCount;\n    }\n\n    if (this.changeFeedOptions.sessionToken) {\n      feedOptions.sessionToken = this.changeFeedOptions.sessionToken;\n    }\n\n    const continuation = this.continuationToken.Continuation;\n    if (continuation) {\n      feedOptions.accessCondition = {\n        type: Constants.HttpHeaders.IfNoneMatch,\n        condition: continuation,\n      };\n    } else if (this.startFromNow) {\n      feedOptions.initialHeaders[Constants.HttpHeaders.IfNoneMatch] =\n        Constants.ChangeFeedIfNoneMatchStartFromNowHeader;\n    }\n\n    if (this.startTime) {\n      feedOptions.initialHeaders[Constants.HttpHeaders.IfModifiedSince] = this.startTime;\n    }\n    if (\n      this.changeFeedOptions.changeFeedMode &&\n      this.changeFeedOptions.changeFeedMode === ChangeFeedMode.AllVersionsAndDeletes\n    ) {\n      feedOptions.useAllVersionsAndDeletesFeed = true;\n      feedOptions.useLatestVersionFeed = false;\n    }\n    if (this.clientContext.enableEncryption) {\n      feedOptions.containerRid = this.container._rid;\n    }\n    try {\n      const response: Response<Array<T & Resource>> = await (this.clientContext.queryFeed<T>({\n        path: this.resourceLink,\n        resourceType: ResourceType.item,\n        resourceId: this.resourceId,\n        resultFn: (result) => (result ? result.Documents : []),\n        diagnosticNode,\n        query: undefined,\n        options: feedOptions,\n        partitionKey: this.partitionKey,\n      }) as Promise<any>);\n      return new ChangeFeedIteratorResponse(\n        response.result,\n        response.result ? response.result.length : 0,\n        response.code,\n        response.headers,\n        getEmptyCosmosDiagnostics(),\n      );\n    } catch (err) {\n      // If any errors are encountered, throw the error.\n      const errorResponse = new ErrorResponse(err.message);\n      errorResponse.code = err.code;\n      errorResponse.headers = err.headers;\n      throw errorResponse;\n    }\n  }\n}\n"],"mappings":";AAGA,SAASA,0BAA0B,QAAQ,8BAA8B;AAGzE,SAASC,SAAS,EAAEC,UAAU,EAAEC,YAAY,EAAEC,WAAW,QAAQ,cAAc;AAC/E,SAAgCC,aAAa,QAAQ,eAAe;AACpE,SAASC,gCAAgC,QAAQ,oCAAoC;AAErF,SAAuBC,6BAA6B,QAAQ,iBAAiB;AAE7E,SAASC,yBAAyB,EAAEC,eAAe,QAAQ,yBAAyB;AACpF,SAASC,cAAc,QAAQ,kBAAkB;AACjD,SAASC,yBAAyB,QAAQ,mBAAmB;AAC7D;;;;;;AAMA,OAAM,MAAOC,yBAAyB;EAMpC;;;EAGAC,YACUC,aAA4B,EAC5BC,SAAoB,EACpBC,UAAkB,EAClBC,YAAoB,EACpBC,YAA0B,EAC1BC,iBAAoD;IALpD,KAAAL,aAAa,GAAbA,aAAa;IACb,KAAAC,SAAS,GAATA,SAAS;IACT,KAAAC,UAAU,GAAVA,UAAU;IACV,KAAAC,YAAY,GAAZA,YAAY;IACZ,KAAAC,YAAY,GAAZA,YAAY;IACZ,KAAAC,iBAAiB,GAAjBA,iBAAiB;IAEzB,IAAI,CAACC,iBAAiB,GAAGD,iBAAiB,CAACC,iBAAiB,GACxDC,IAAI,CAACC,KAAK,CAACH,iBAAiB,CAACC,iBAAiB,CAAC,GAC/CG,SAAS;IACb,IAAI,CAACC,cAAc,GAAG,KAAK;IAC3B;IACA,IAAIL,iBAAiB,CAACM,YAAY,EAAE;MAClC,IAAI,CAACA,YAAY,GAAG,IAAI;IAC1B,CAAC,MAAM,IAAIN,iBAAiB,CAACO,SAAS,EAAE;MACtC,IAAI,CAACA,SAAS,GAAGP,iBAAiB,CAACO,SAAS,CAACC,WAAW,EAAE;IAC5D;EACF;EAEQ,MAAMC,mBAAmBA,CAACC,cAAsC;IACtE,MAAM,IAAI,CAACC,cAAc,CAACD,cAAc,CAAC;IACzC,IAAI,IAAI,CAACf,aAAa,CAACiB,gBAAgB,EAAE;MACvC,MAAM,IAAI,CAAChB,SAAS,CAACiB,4BAA4B,EAAE;MACnD;MACA,IAAI,CAACd,YAAY,GAAGhB,UAAU,CAAC,IAAI,CAACgB,YAAY,CAAC;MACjDW,cAAc,CAACI,0BAA0B,CAAChC,SAAS,CAACiC,UAAU,CAACC,2BAA2B,CAAC;MAC3F,MAAM;QAAEC,gBAAgB;QAAEC;MAAc,CAAE,GACxC,MAAM,IAAI,CAACtB,SAAS,CAACuB,mBAAmB,CAACC,6BAA6B,CACpEhC,6BAA6B,CAAC,IAAI,CAACW,YAAY,CAAC,CACjD;MACH,IAAI,CAACA,YAAY,GAAGkB,gBAAgB;MACpCP,cAAc,CAACW,wBAAwB,CACrCvC,SAAS,CAACiC,UAAU,CAACC,2BAA2B,EAChDE,cAAc,CACf;IACH;IACA,IAAI,IAAI,CAACjB,iBAAiB,EAAE;MAC1B,IAAI,CAAC,IAAI,CAACqB,qCAAqC,EAAE,EAAE;QACjD,MAAM,IAAIpC,aAAa,CAAC,+DAA+D,CAAC;MAC1F;IACF,CAAC,MAAM;MACL,IAAI,CAACe,iBAAiB,GAAG,IAAId,gCAAgC,CAC3D,IAAI,CAACoC,GAAG,EACR,IAAI,CAACxB,YAAY,EACjB,EAAE,CACH;IACH;IAEA,IAAI,CAACM,cAAc,GAAG,IAAI;EAC5B;EAEQiB,qCAAqCA,CAAA;IAC3C,IAAI,IAAI,CAACrB,iBAAiB,CAACuB,GAAG,KAAK,IAAI,CAACD,GAAG,EAAE;MAC3C,OAAO,KAAK;IACd;IACA,OAAO,IAAI;EACb;EAEQ,MAAMZ,cAAcA,CAACD,cAAsC;IACjE,MAAM;MAAEe;IAAQ,CAAE,GAAG,MAAM,IAAI,CAAC7B,SAAS,CAAC8B,YAAY,CAAChB,cAAc,CAAC;IACtE,IAAI,CAACa,GAAG,GAAGE,QAAQ,CAACE,IAAI;EAC1B;EAEA;;;EAGA,IAAIC,cAAcA,CAAA;IAChB,OAAO,IAAI;EACb;EAEA;;;EAGcC,gBAAgBA,CAAA;;MAC5B,GAAG;QACD,MAAMC,MAAM,GAAG,MAAAC,OAAA,CAAM,IAAI,CAACC,QAAQ,EAAE;QACpC,YAAAD,OAAA,CAAMD,MAAM;MACd,CAAC,QAAQ,IAAI,CAACF,cAAc;IAC9B,CAAC;;EAED;;;EAGO,MAAMI,QAAQA,CAAA;IACnB,OAAO1C,eAAe,CAAC,MAAOoB,cAAsC,IAAI;MACtE,IAAI,CAAC,IAAI,CAACL,cAAc,EAAE;QACxB,MAAM,IAAI,CAACI,mBAAmB,CAACC,cAAc,CAAC;MAChD;MACA,MAAMoB,MAAM,GAAG,MAAM,IAAI,CAACG,SAAS,CAACvB,cAAc,CAAC;MACnD,IAAIoB,MAAM,CAACI,UAAU,KAAKjD,WAAW,CAACkD,EAAE,EAAE;QACxC,IAAI,IAAI,CAACxC,aAAa,CAACiB,gBAAgB,EAAE;UACvC,MAAMpB,yBAAyB,CAC7BsC,MAAM,EACNpB,cAAc,EACd,IAAI,CAACV,iBAAiB,CAACoC,cAAc,EACrC,IAAI,CAACxC,SAAS,CAACuB,mBAAmB,CACnC;QACH;MACF;MACA,OAAOW,MAAM;IACf,CAAC,EAAE,IAAI,CAACnC,aAAa,CAAC;EACxB;EAEA;;;EAGQ,MAAMsC,SAASA,CACrBvB,cAAsC;IAEtC,MAAM2B,QAAQ,GAAG,MAAM,IAAI,CAACC,eAAe,CAAC5B,cAAc,CAAC;IAC3D,IAAI,CAACT,iBAAiB,CAACsC,YAAY,GAAGF,QAAQ,CAACG,OAAO,CAAC1D,SAAS,CAAC2D,WAAW,CAACC,IAAI,CAAC;IAClFL,QAAQ,CAACG,OAAO,CAAC1D,SAAS,CAAC2D,WAAW,CAACE,iBAAiB,CAAC,GAAGzC,IAAI,CAAC0C,SAAS,CACxE,IAAI,CAAC3C,iBAAiB,CACvB;IACD,OAAOoC,QAAQ;EACjB;EAEQ,MAAMC,eAAeA,CAC3B5B,cAAsC;IAEtC,MAAMmC,WAAW,GAAgB;MAC/BC,cAAc,EAAE,EAAE;MAClBC,oBAAoB,EAAE,IAAI;MAC1BC,4BAA4B,EAAE;KAC/B;IACD,IAAI,OAAO,IAAI,CAAChD,iBAAiB,CAACiD,YAAY,KAAK,QAAQ,EAAE;MAC3DJ,WAAW,CAACI,YAAY,GAAG,IAAI,CAACjD,iBAAiB,CAACiD,YAAY;IAChE;IAEA,IAAI,IAAI,CAACjD,iBAAiB,CAACkD,YAAY,EAAE;MACvCL,WAAW,CAACK,YAAY,GAAG,IAAI,CAAClD,iBAAiB,CAACkD,YAAY;IAChE;IAEA,MAAMC,YAAY,GAAG,IAAI,CAAClD,iBAAiB,CAACsC,YAAY;IACxD,IAAIY,YAAY,EAAE;MAChBN,WAAW,CAACO,eAAe,GAAG;QAC5BC,IAAI,EAAEvE,SAAS,CAAC2D,WAAW,CAACa,WAAW;QACvCC,SAAS,EAAEJ;OACZ;IACH,CAAC,MAAM,IAAI,IAAI,CAAC7C,YAAY,EAAE;MAC5BuC,WAAW,CAACC,cAAc,CAAChE,SAAS,CAAC2D,WAAW,CAACa,WAAW,CAAC,GAC3DxE,SAAS,CAAC0E,uCAAuC;IACrD;IAEA,IAAI,IAAI,CAACjD,SAAS,EAAE;MAClBsC,WAAW,CAACC,cAAc,CAAChE,SAAS,CAAC2D,WAAW,CAACgB,eAAe,CAAC,GAAG,IAAI,CAAClD,SAAS;IACpF;IACA,IACE,IAAI,CAACP,iBAAiB,CAACoC,cAAc,IACrC,IAAI,CAACpC,iBAAiB,CAACoC,cAAc,KAAK7C,cAAc,CAACmE,qBAAqB,EAC9E;MACAb,WAAW,CAACG,4BAA4B,GAAG,IAAI;MAC/CH,WAAW,CAACE,oBAAoB,GAAG,KAAK;IAC1C;IACA,IAAI,IAAI,CAACpD,aAAa,CAACiB,gBAAgB,EAAE;MACvCiC,WAAW,CAACc,YAAY,GAAG,IAAI,CAAC/D,SAAS,CAAC+B,IAAI;IAChD;IACA,IAAI;MACF,MAAMU,QAAQ,GAAkC,MAAO,IAAI,CAAC1C,aAAa,CAACiE,SAAS,CAAI;QACrFC,IAAI,EAAE,IAAI,CAAC/D,YAAY;QACvBgE,YAAY,EAAE9E,YAAY,CAAC+E,IAAI;QAC/BlE,UAAU,EAAE,IAAI,CAACA,UAAU;QAC3BmE,QAAQ,EAAGlC,MAAM,IAAMA,MAAM,GAAGA,MAAM,CAACmC,SAAS,GAAG,EAAG;QACtDvD,cAAc;QACdwD,KAAK,EAAE9D,SAAS;QAChB+D,OAAO,EAAEtB,WAAW;QACpB9C,YAAY,EAAE,IAAI,CAACA;OACpB,CAAkB;MACnB,OAAO,IAAIlB,0BAA0B,CACnCwD,QAAQ,CAACP,MAAM,EACfO,QAAQ,CAACP,MAAM,GAAGO,QAAQ,CAACP,MAAM,CAACsC,MAAM,GAAG,CAAC,EAC5C/B,QAAQ,CAACgC,IAAI,EACbhC,QAAQ,CAACG,OAAO,EAChBnD,yBAAyB,EAAE,CAC5B;IACH,CAAC,CAAC,OAAOiF,GAAG,EAAE;MACZ;MACA,MAAMC,aAAa,GAAG,IAAIrF,aAAa,CAACoF,GAAG,CAACE,OAAO,CAAC;MACpDD,aAAa,CAACF,IAAI,GAAGC,GAAG,CAACD,IAAI;MAC7BE,aAAa,CAAC/B,OAAO,GAAG8B,GAAG,CAAC9B,OAAO;MACnC,MAAM+B,aAAa;IACrB;EACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}