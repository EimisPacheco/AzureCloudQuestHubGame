{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { tracingClient } from \"../../tracing.js\";\nimport { getKeyFromKeyBundle } from \"../../transformations.js\";\nimport { KeyVaultKeyPollOperation } from \"../keyVaultKeyPoller.js\";\nexport class RecoverDeletedKeyPollOperation extends KeyVaultKeyPollOperation {\n  constructor(state, vaultUrl, client, operationOptions = {}) {\n    super(state, {\n      cancelMessage: \"Canceling the recovery of a deleted key is not supported.\"\n    });\n    this.state = state;\n    this.vaultUrl = vaultUrl;\n    this.client = client;\n    this.operationOptions = operationOptions;\n  }\n  /**\n   * The getKey method gets a specified key and is applicable to any key stored in Azure Key Vault.\n   * This operation requires the keys/get permission.\n   */\n  getKey(name, options = {}) {\n    return tracingClient.withSpan(\"RecoverDeleteKeyPoller.getKey\", options, async updatedOptions => {\n      const response = await this.client.getKey(this.vaultUrl, name, (updatedOptions === null || updatedOptions === void 0 ? void 0 : updatedOptions.version) || \"\", updatedOptions);\n      return getKeyFromKeyBundle(response);\n    });\n  }\n  /**\n   * Sends a request to recover a deleted Key Vault Key based on the given name.\n   * Since the Key Vault Key won't be immediately recover the deleted key, we have {@link beginRecoverDeletedKey}.\n   */\n  async recoverDeletedKey(name, options = {}) {\n    return tracingClient.withSpan(\"RecoverDeletedKeyPoller.recoverDeleteKey\", options, async updatedOptions => {\n      const response = await this.client.recoverDeletedKey(this.vaultUrl, name, updatedOptions);\n      return getKeyFromKeyBundle(response);\n    });\n  }\n  /**\n   * Reaches to the service and updates the delete key's poll operation.\n   */\n  async update(options = {}) {\n    const state = this.state;\n    const {\n      name\n    } = state;\n    const operationOptions = this.operationOptions;\n    if (options.abortSignal) {\n      operationOptions.abortSignal = options.abortSignal;\n    }\n    if (!state.isStarted) {\n      try {\n        state.result = await this.getKey(name, operationOptions);\n        state.isCompleted = true;\n      } catch (_a) {\n        // Nothing to do here.\n      }\n      if (!state.isCompleted) {\n        state.result = await this.recoverDeletedKey(name, operationOptions);\n        state.isStarted = true;\n      }\n    }\n    if (!state.isCompleted) {\n      try {\n        state.result = await this.getKey(name, operationOptions);\n        state.isCompleted = true;\n      } catch (error) {\n        if (error.statusCode === 403) {\n          // At this point, the resource exists but the user doesn't have access to it.\n          state.isCompleted = true;\n        } else if (error.statusCode !== 404) {\n          state.error = error;\n          state.isCompleted = true;\n          throw error;\n        }\n      }\n    }\n    return this;\n  }\n}","map":{"version":3,"names":["tracingClient","getKeyFromKeyBundle","KeyVaultKeyPollOperation","RecoverDeletedKeyPollOperation","constructor","state","vaultUrl","client","operationOptions","cancelMessage","getKey","name","options","withSpan","updatedOptions","response","version","recoverDeletedKey","update","abortSignal","isStarted","result","isCompleted","_a","error","statusCode"],"sources":["/Users/eimis/test-server/Azure Hackthons/azure-cloud-architecture-game /node_modules/@azure/keyvault-keys/src/lro/recover/operation.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { OperationOptions } from \"@azure/core-client\";\nimport { KeyVaultClient } from \"../../generated/keyVaultClient.js\";\nimport { GetKeyOptions, KeyVaultKey, RecoverDeletedKeyOptions } from \"../../keysModels.js\";\nimport { tracingClient } from \"../../tracing.js\";\nimport { getKeyFromKeyBundle } from \"../../transformations.js\";\nimport { KeyVaultKeyPollOperation, KeyVaultKeyPollOperationState } from \"../keyVaultKeyPoller.js\";\n\n/**\n * An interface representing the state of a delete key's poll operation\n */\nexport interface RecoverDeletedKeyPollOperationState\n  extends KeyVaultKeyPollOperationState<KeyVaultKey> {}\n\nexport class RecoverDeletedKeyPollOperation extends KeyVaultKeyPollOperation<\n  RecoverDeletedKeyPollOperationState,\n  KeyVaultKey\n> {\n  constructor(\n    public state: RecoverDeletedKeyPollOperationState,\n    private vaultUrl: string,\n    private client: KeyVaultClient,\n    private operationOptions: OperationOptions = {},\n  ) {\n    super(state, { cancelMessage: \"Canceling the recovery of a deleted key is not supported.\" });\n  }\n\n  /**\n   * The getKey method gets a specified key and is applicable to any key stored in Azure Key Vault.\n   * This operation requires the keys/get permission.\n   */\n  private getKey(name: string, options: GetKeyOptions = {}): Promise<KeyVaultKey> {\n    return tracingClient.withSpan(\n      \"RecoverDeleteKeyPoller.getKey\",\n      options,\n      async (updatedOptions) => {\n        const response = await this.client.getKey(\n          this.vaultUrl,\n          name,\n          updatedOptions?.version || \"\",\n          updatedOptions,\n        );\n        return getKeyFromKeyBundle(response);\n      },\n    );\n  }\n\n  /**\n   * Sends a request to recover a deleted Key Vault Key based on the given name.\n   * Since the Key Vault Key won't be immediately recover the deleted key, we have {@link beginRecoverDeletedKey}.\n   */\n  private async recoverDeletedKey(\n    name: string,\n    options: RecoverDeletedKeyOptions = {},\n  ): Promise<KeyVaultKey> {\n    return tracingClient.withSpan(\n      \"RecoverDeletedKeyPoller.recoverDeleteKey\",\n      options,\n      async (updatedOptions) => {\n        const response = await this.client.recoverDeletedKey(this.vaultUrl, name, updatedOptions);\n        return getKeyFromKeyBundle(response);\n      },\n    );\n  }\n\n  /**\n   * Reaches to the service and updates the delete key's poll operation.\n   */\n  public async update(\n    options: {\n      abortSignal?: AbortSignalLike;\n      fireProgress?: (state: RecoverDeletedKeyPollOperationState) => void;\n    } = {},\n  ): Promise<RecoverDeletedKeyPollOperation> {\n    const state = this.state;\n    const { name } = state;\n\n    const operationOptions = this.operationOptions;\n    if (options.abortSignal) {\n      operationOptions.abortSignal = options.abortSignal;\n    }\n\n    if (!state.isStarted) {\n      try {\n        state.result = await this.getKey(name, operationOptions);\n        state.isCompleted = true;\n      } catch {\n        // Nothing to do here.\n      }\n      if (!state.isCompleted) {\n        state.result = await this.recoverDeletedKey(name, operationOptions);\n        state.isStarted = true;\n      }\n    }\n\n    if (!state.isCompleted) {\n      try {\n        state.result = await this.getKey(name, operationOptions);\n        state.isCompleted = true;\n      } catch (error: any) {\n        if (error.statusCode === 403) {\n          // At this point, the resource exists but the user doesn't have access to it.\n          state.isCompleted = true;\n        } else if (error.statusCode !== 404) {\n          state.error = error;\n          state.isCompleted = true;\n          throw error;\n        }\n      }\n    }\n\n    return this;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}