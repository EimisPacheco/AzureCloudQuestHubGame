{"ast":null,"code":"import { QueryRange } from \"../../routing\";\nimport { ChangeFeedStartFrom } from \"./ChangeFeedStartFrom\";\nimport { ChangeFeedStartFromBeginning } from \"./ChangeFeedStartFromBeginning\";\nimport { ChangeFeedStartFromContinuation } from \"./ChangeFeedStartFromContinuation\";\nimport { ChangeFeedStartFromNow } from \"./ChangeFeedStartFromNow\";\nimport { ChangeFeedStartFromTime } from \"./ChangeFeedStartFromTime\";\nimport { ChangeFeedResourceType } from \"./ChangeFeedEnums\";\nimport { ChangeFeedForPartitionKey } from \"./ChangeFeedForPartitionKey\";\nimport { ErrorResponse } from \"../../request\";\nimport { ChangeFeedForEpkRange } from \"./ChangeFeedForEpkRange\";\nimport { getIdFromLink, getPathFromLink, ResourceType, Constants } from \"../../common\";\nimport { buildInternalChangeFeedOptions, fetchStartTime, isEpkRange, getEPKRangeForPrefixPartitionKey } from \"./changeFeedUtils\";\nimport { isPrefixPartitionKey, isPartitionKey } from \"../../utils/typeChecks\";\nexport async function buildChangeFeedIterator(cfOptions, clientContext, container, partitionKeyRangeCache) {\n  const url = container.url;\n  const path = getPathFromLink(url, ResourceType.item);\n  const id = getIdFromLink(url);\n  let changeFeedStartFrom = cfOptions.changeFeedStartFrom;\n  if (changeFeedStartFrom === undefined) {\n    changeFeedStartFrom = ChangeFeedStartFrom.Now();\n  }\n  if (changeFeedStartFrom instanceof ChangeFeedStartFromContinuation) {\n    const continuationToken = changeFeedStartFrom.getCfResourceJson();\n    const resourceType = changeFeedStartFrom.getResourceType();\n    const internalCfOptions = buildInternalChangeFeedOptions(cfOptions, changeFeedStartFrom.getCfResource());\n    if (resourceType === ChangeFeedResourceType.PartitionKey && isPartitionKey(continuationToken.partitionKey)) {\n      return new ChangeFeedForPartitionKey(clientContext, container, id, path, continuationToken.partitionKey, internalCfOptions);\n    } else if (resourceType === ChangeFeedResourceType.FeedRange) {\n      return new ChangeFeedForEpkRange(clientContext, container, partitionKeyRangeCache, id, path, url, internalCfOptions, undefined);\n    } else {\n      throw new ErrorResponse(\"Invalid continuation token.\");\n    }\n  } else if (changeFeedStartFrom instanceof ChangeFeedStartFromNow || changeFeedStartFrom instanceof ChangeFeedStartFromTime || changeFeedStartFrom instanceof ChangeFeedStartFromBeginning) {\n    const startFromNow = changeFeedStartFrom instanceof ChangeFeedStartFromNow ? true : false;\n    const startTime = startFromNow ? undefined : fetchStartTime(changeFeedStartFrom);\n    const internalCfOptions = buildInternalChangeFeedOptions(cfOptions, undefined, startTime, startFromNow);\n    const cfResource = changeFeedStartFrom.getCfResource();\n    if (isPartitionKey(cfResource)) {\n      const partitionKey = cfResource;\n      const partitionKeyDefinition = await container.getPartitionKeyDefinition();\n      if (partitionKeyDefinition !== undefined && isPrefixPartitionKey(partitionKey, partitionKeyDefinition.resource)) {\n        const effectiveEPKRange = await getEPKRangeForPrefixPartitionKey(partitionKey);\n        return new ChangeFeedForEpkRange(clientContext, container, partitionKeyRangeCache, id, path, url, internalCfOptions, effectiveEPKRange);\n      }\n      return new ChangeFeedForPartitionKey(clientContext, container, id, path, cfResource, internalCfOptions);\n    } else {\n      let internalCfResource;\n      if (cfResource === undefined) {\n        internalCfResource = new QueryRange(Constants.EffectivePartitionKeyConstants.MinimumInclusiveEffectivePartitionKey, Constants.EffectivePartitionKeyConstants.MaximumExclusiveEffectivePartitionKey, true, false);\n      } else if (isEpkRange(cfResource)) {\n        internalCfResource = new QueryRange(cfResource.minInclusive, cfResource.maxExclusive, true, false);\n      } else {\n        throw new ErrorResponse(\"Invalid feed range.\");\n      }\n      return new ChangeFeedForEpkRange(clientContext, container, partitionKeyRangeCache, id, path, url, internalCfOptions, internalCfResource);\n    }\n  } else {\n    throw new ErrorResponse(\"Invalid change feed start location.\");\n  }\n}","map":{"version":3,"names":["QueryRange","ChangeFeedStartFrom","ChangeFeedStartFromBeginning","ChangeFeedStartFromContinuation","ChangeFeedStartFromNow","ChangeFeedStartFromTime","ChangeFeedResourceType","ChangeFeedForPartitionKey","ErrorResponse","ChangeFeedForEpkRange","getIdFromLink","getPathFromLink","ResourceType","Constants","buildInternalChangeFeedOptions","fetchStartTime","isEpkRange","getEPKRangeForPrefixPartitionKey","isPrefixPartitionKey","isPartitionKey","buildChangeFeedIterator","cfOptions","clientContext","container","partitionKeyRangeCache","url","path","item","id","changeFeedStartFrom","undefined","Now","continuationToken","getCfResourceJson","resourceType","getResourceType","internalCfOptions","getCfResource","PartitionKey","partitionKey","FeedRange","startFromNow","startTime","cfResource","partitionKeyDefinition","getPartitionKeyDefinition","resource","effectiveEPKRange","internalCfResource","EffectivePartitionKeyConstants","MinimumInclusiveEffectivePartitionKey","MaximumExclusiveEffectivePartitionKey","minInclusive","maxExclusive"],"sources":["/Users/eimis/test-server/Azure Hackthons/azure-cloud-architecture-game /node_modules/@azure/cosmos/src/client/ChangeFeed/buildChangeFeedIterator.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { ClientContext } from \"../../ClientContext\";\nimport type { PartitionKey } from \"../../documents\";\nimport type { PartitionKeyRangeCache } from \"../../routing\";\nimport { QueryRange } from \"../../routing\";\nimport type { ChangeFeedIteratorOptions } from \"./ChangeFeedIteratorOptions\";\nimport { ChangeFeedStartFrom } from \"./ChangeFeedStartFrom\";\nimport { ChangeFeedStartFromBeginning } from \"./ChangeFeedStartFromBeginning\";\nimport { ChangeFeedStartFromContinuation } from \"./ChangeFeedStartFromContinuation\";\nimport { ChangeFeedStartFromNow } from \"./ChangeFeedStartFromNow\";\nimport { ChangeFeedStartFromTime } from \"./ChangeFeedStartFromTime\";\nimport { ChangeFeedResourceType } from \"./ChangeFeedEnums\";\nimport { ChangeFeedForPartitionKey } from \"./ChangeFeedForPartitionKey\";\nimport { ErrorResponse } from \"../../request\";\nimport { ChangeFeedForEpkRange } from \"./ChangeFeedForEpkRange\";\nimport { getIdFromLink, getPathFromLink, ResourceType, Constants } from \"../../common\";\nimport {\n  buildInternalChangeFeedOptions,\n  fetchStartTime,\n  isEpkRange,\n  getEPKRangeForPrefixPartitionKey,\n} from \"./changeFeedUtils\";\nimport { isPrefixPartitionKey, isPartitionKey } from \"../../utils/typeChecks\";\nimport type { Container } from \"../Container\";\nimport type { FeedRangeInternal } from \"./FeedRange\";\nimport { PartitionKeyInternal } from \"../../documents/PartitionKeyInternal\";\n\nexport async function buildChangeFeedIterator(\n  cfOptions: ChangeFeedIteratorOptions,\n  clientContext: ClientContext,\n  container: Container,\n  partitionKeyRangeCache: PartitionKeyRangeCache,\n): Promise<any> {\n  const url = container.url;\n  const path = getPathFromLink(url, ResourceType.item);\n  const id = getIdFromLink(url);\n\n  let changeFeedStartFrom = cfOptions.changeFeedStartFrom;\n\n  if (changeFeedStartFrom === undefined) {\n    changeFeedStartFrom = ChangeFeedStartFrom.Now();\n  }\n\n  if (changeFeedStartFrom instanceof ChangeFeedStartFromContinuation) {\n    const continuationToken = changeFeedStartFrom.getCfResourceJson();\n    const resourceType = changeFeedStartFrom.getResourceType();\n    const internalCfOptions = buildInternalChangeFeedOptions(\n      cfOptions,\n      changeFeedStartFrom.getCfResource(),\n    );\n\n    if (\n      resourceType === ChangeFeedResourceType.PartitionKey &&\n      isPartitionKey(continuationToken.partitionKey)\n    ) {\n      return new ChangeFeedForPartitionKey(\n        clientContext,\n        container,\n        id,\n        path,\n        continuationToken.partitionKey,\n        internalCfOptions,\n      );\n    } else if (resourceType === ChangeFeedResourceType.FeedRange) {\n      return new ChangeFeedForEpkRange(\n        clientContext,\n        container,\n        partitionKeyRangeCache,\n        id,\n        path,\n        url,\n        internalCfOptions,\n        undefined,\n      );\n    } else {\n      throw new ErrorResponse(\"Invalid continuation token.\");\n    }\n  } else if (\n    changeFeedStartFrom instanceof ChangeFeedStartFromNow ||\n    changeFeedStartFrom instanceof ChangeFeedStartFromTime ||\n    changeFeedStartFrom instanceof ChangeFeedStartFromBeginning\n  ) {\n    const startFromNow = changeFeedStartFrom instanceof ChangeFeedStartFromNow ? true : false;\n    const startTime = startFromNow ? undefined : fetchStartTime(changeFeedStartFrom);\n\n    const internalCfOptions = buildInternalChangeFeedOptions(\n      cfOptions,\n      undefined,\n      startTime,\n      startFromNow,\n    );\n    const cfResource = changeFeedStartFrom.getCfResource();\n    if (isPartitionKey(cfResource)) {\n      const partitionKey = cfResource as PartitionKey;\n      const partitionKeyDefinition = await container.getPartitionKeyDefinition();\n\n      if (\n        partitionKeyDefinition !== undefined &&\n        isPrefixPartitionKey(partitionKey, partitionKeyDefinition.resource)\n      ) {\n        const effectiveEPKRange = await getEPKRangeForPrefixPartitionKey(\n          partitionKey as PartitionKeyInternal,\n        );\n        return new ChangeFeedForEpkRange(\n          clientContext,\n          container,\n          partitionKeyRangeCache,\n          id,\n          path,\n          url,\n          internalCfOptions,\n          effectiveEPKRange,\n        );\n      }\n\n      return new ChangeFeedForPartitionKey(\n        clientContext,\n        container,\n        id,\n        path,\n        cfResource as PartitionKey,\n        internalCfOptions,\n      );\n    } else {\n      let internalCfResource: QueryRange;\n      if (cfResource === undefined) {\n        internalCfResource = new QueryRange(\n          Constants.EffectivePartitionKeyConstants.MinimumInclusiveEffectivePartitionKey,\n          Constants.EffectivePartitionKeyConstants.MaximumExclusiveEffectivePartitionKey,\n          true,\n          false,\n        );\n      } else if (isEpkRange(cfResource)) {\n        internalCfResource = new QueryRange(\n          (cfResource as FeedRangeInternal).minInclusive,\n          (cfResource as FeedRangeInternal).maxExclusive,\n          true,\n          false,\n        );\n      } else {\n        throw new ErrorResponse(\"Invalid feed range.\");\n      }\n      return new ChangeFeedForEpkRange(\n        clientContext,\n        container,\n        partitionKeyRangeCache,\n        id,\n        path,\n        url,\n        internalCfOptions,\n        internalCfResource,\n      );\n    }\n  } else {\n    throw new ErrorResponse(\"Invalid change feed start location.\");\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}