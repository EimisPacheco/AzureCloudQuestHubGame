{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { __rest } from \"tslib\";\nimport { SDK_VERSION } from \"../constants.js\";\nimport { KeyVaultClient } from \"../generated/index.js\";\nimport { parseKeyVaultKeyIdentifier } from \"../identifier.js\";\nimport { LATEST_API_VERSION } from \"../keysModels.js\";\nimport { getKeyFromKeyBundle } from \"../transformations.js\";\nimport { createHash } from \"./crypto.js\";\nimport { logger } from \"../log.js\";\nimport { keyVaultAuthenticationPolicy } from \"@azure/keyvault-common\";\nimport { tracingClient } from \"../tracing.js\";\n/**\n * The remote cryptography provider is used to run crypto operations against KeyVault.\n * @internal\n */\nexport class RemoteCryptographyProvider {\n  constructor(key, credential, pipelineOptions = {}) {\n    var _a;\n    this.client = getOrInitializeClient(credential, pipelineOptions);\n    this.key = key;\n    let keyId;\n    if (typeof key === \"string\") {\n      keyId = key;\n    } else {\n      keyId = key.id;\n    }\n    try {\n      const parsed = parseKeyVaultKeyIdentifier(keyId);\n      if (parsed.name === \"\") {\n        throw new Error(\"Could not find 'name' of key in key URL\");\n      }\n      if (!parsed.vaultUrl || parsed.vaultUrl === \"\") {\n        throw new Error(\"Could not find 'vaultUrl' of key in key URL\");\n      }\n      this.vaultUrl = parsed.vaultUrl;\n      this.name = parsed.name;\n      this.version = (_a = parsed.version) !== null && _a !== void 0 ? _a : \"\";\n    } catch (err) {\n      logger.error(err);\n      throw new Error(`${keyId} is not a valid Key Vault key ID`);\n    }\n  }\n  // The remote client supports all algorithms and all operations.\n  isSupported(_algorithm, _operation) {\n    return true;\n  }\n  encrypt(encryptParameters, options = {}) {\n    const {\n        algorithm,\n        plaintext\n      } = encryptParameters,\n      params = __rest(encryptParameters, [\"algorithm\", \"plaintext\"]);\n    const requestOptions = Object.assign(Object.assign({}, options), params);\n    return tracingClient.withSpan(\"RemoteCryptographyProvider.encrypt\", requestOptions, async updatedOptions => {\n      const result = await this.client.encrypt(this.vaultUrl, this.name, this.version, algorithm, plaintext, updatedOptions);\n      return {\n        algorithm: encryptParameters.algorithm,\n        result: result.result,\n        keyID: this.getKeyID(),\n        additionalAuthenticatedData: result.additionalAuthenticatedData,\n        authenticationTag: result.authenticationTag,\n        iv: result.iv\n      };\n    });\n  }\n  decrypt(decryptParameters, options = {}) {\n    const {\n        algorithm,\n        ciphertext\n      } = decryptParameters,\n      params = __rest(decryptParameters, [\"algorithm\", \"ciphertext\"]);\n    const requestOptions = Object.assign(Object.assign({}, options), params);\n    return tracingClient.withSpan(\"RemoteCryptographyProvider.decrypt\", requestOptions, async updatedOptions => {\n      const result = await this.client.decrypt(this.vaultUrl, this.name, this.version, algorithm, ciphertext, updatedOptions);\n      return {\n        result: result.result,\n        keyID: this.getKeyID(),\n        algorithm\n      };\n    });\n  }\n  wrapKey(algorithm, keyToWrap, options = {}) {\n    return tracingClient.withSpan(\"RemoteCryptographyProvider.wrapKey\", options, async updatedOptions => {\n      const result = await this.client.wrapKey(this.vaultUrl, this.name, this.version, algorithm, keyToWrap, updatedOptions);\n      return {\n        result: result.result,\n        algorithm,\n        keyID: this.getKeyID()\n      };\n    });\n  }\n  unwrapKey(algorithm, encryptedKey, options = {}) {\n    return tracingClient.withSpan(\"RemoteCryptographyProvider.unwrapKey\", options, async updatedOptions => {\n      const result = await this.client.unwrapKey(this.vaultUrl, this.name, this.version, algorithm, encryptedKey, updatedOptions);\n      return {\n        result: result.result,\n        algorithm,\n        keyID: this.getKeyID()\n      };\n    });\n  }\n  sign(algorithm, digest, options = {}) {\n    return tracingClient.withSpan(\"RemoteCryptographyProvider.sign\", options, async updatedOptions => {\n      const result = await this.client.sign(this.vaultUrl, this.name, this.version, algorithm, digest, updatedOptions);\n      return {\n        result: result.result,\n        algorithm,\n        keyID: this.getKeyID()\n      };\n    });\n  }\n  verifyData(algorithm, data, signature, options = {}) {\n    return tracingClient.withSpan(\"RemoteCryptographyProvider.verifyData\", options, async updatedOptions => {\n      const hash = await createHash(algorithm, data);\n      return this.verify(algorithm, hash, signature, updatedOptions);\n    });\n  }\n  verify(algorithm, digest, signature, options = {}) {\n    return tracingClient.withSpan(\"RemoteCryptographyProvider.verify\", options, async updatedOptions => {\n      const response = await this.client.verify(this.vaultUrl, this.name, this.version, algorithm, digest, signature, updatedOptions);\n      return {\n        result: response.value ? response.value : false,\n        keyID: this.getKeyID()\n      };\n    });\n  }\n  signData(algorithm, data, options = {}) {\n    return tracingClient.withSpan(\"RemoteCryptographyProvider.signData\", options, async updatedOptions => {\n      const digest = await createHash(algorithm, data);\n      const result = await this.client.sign(this.vaultUrl, this.name, this.version, algorithm, digest, updatedOptions);\n      return {\n        result: result.result,\n        algorithm,\n        keyID: this.getKeyID()\n      };\n    });\n  }\n  /**\n   * The ID of the key used to perform cryptographic operations for the client.\n   */\n  get keyId() {\n    return this.getKeyID();\n  }\n  /**\n   * Gets the {@link KeyVaultKey} used for cryptography operations, fetching it\n   * from KeyVault if necessary.\n   * @param options - Additional options.\n   */\n  getKey(options = {}) {\n    return tracingClient.withSpan(\"RemoteCryptographyProvider.getKey\", options, async updatedOptions => {\n      if (typeof this.key === \"string\") {\n        if (!this.name || this.name === \"\") {\n          throw new Error(\"getKey requires a key with a name\");\n        }\n        const response = await this.client.getKey(this.vaultUrl, this.name, options && options.version ? options.version : this.version ? this.version : \"\", updatedOptions);\n        this.key = getKeyFromKeyBundle(response);\n      }\n      return this.key;\n    });\n  }\n  /**\n   * Attempts to retrieve the ID of the key.\n   */\n  getKeyID() {\n    let kid;\n    if (typeof this.key !== \"string\") {\n      kid = this.key.id;\n    } else {\n      kid = this.key;\n    }\n    return kid;\n  }\n}\n/**\n * A helper method to either get the passed down generated client or initialize a new one.\n * An already constructed generated client may be passed down from {@link KeyClient} in which case we should reuse it.\n *\n * @internal\n * @param credential - The credential to use when initializing a new client.\n * @param options - The options for constructing a client or the underlying client if one already exists.\n * @returns - A generated client instance\n */\nfunction getOrInitializeClient(credential, options) {\n  if (options.generatedClient) {\n    return options.generatedClient;\n  }\n  const libInfo = `azsdk-js-keyvault-keys/${SDK_VERSION}`;\n  const userAgentOptions = options.userAgentOptions;\n  options.userAgentOptions = {\n    userAgentPrefix: userAgentOptions && userAgentOptions.userAgentPrefix ? `${userAgentOptions.userAgentPrefix} ${libInfo}` : libInfo\n  };\n  const internalPipelineOptions = Object.assign(Object.assign({}, options), {\n    loggingOptions: {\n      logger: logger.info,\n      allowedHeaderNames: [\"x-ms-keyvault-region\", \"x-ms-keyvault-network-info\", \"x-ms-keyvault-service-version\"]\n    }\n  });\n  const client = new KeyVaultClient(options.serviceVersion || LATEST_API_VERSION, internalPipelineOptions);\n  // The authentication policy must come after the deserialization policy since the deserialization policy\n  // converts 401 responses to an Error, and we don't want to deal with that.\n  client.pipeline.addPolicy(keyVaultAuthenticationPolicy(credential, options), {\n    afterPolicies: [\"deserializationPolicy\"]\n  });\n  return client;\n}","map":{"version":3,"names":["SDK_VERSION","KeyVaultClient","parseKeyVaultKeyIdentifier","LATEST_API_VERSION","getKeyFromKeyBundle","createHash","logger","keyVaultAuthenticationPolicy","tracingClient","RemoteCryptographyProvider","constructor","key","credential","pipelineOptions","client","getOrInitializeClient","keyId","id","parsed","name","Error","vaultUrl","version","_a","err","error","isSupported","_algorithm","_operation","encrypt","encryptParameters","options","algorithm","plaintext","params","__rest","requestOptions","Object","assign","withSpan","updatedOptions","result","keyID","getKeyID","additionalAuthenticatedData","authenticationTag","iv","decrypt","decryptParameters","ciphertext","wrapKey","keyToWrap","unwrapKey","encryptedKey","sign","digest","verifyData","data","signature","hash","verify","response","value","signData","getKey","kid","generatedClient","libInfo","userAgentOptions","userAgentPrefix","internalPipelineOptions","loggingOptions","info","allowedHeaderNames","serviceVersion","pipeline","addPolicy","afterPolicies"],"sources":["/Users/eimis/test-server/Azure Hackthons/azure-cloud-architecture-game /node_modules/@azure/keyvault-keys/src/cryptography/remoteCryptographyProvider.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { TokenCredential } from \"@azure/core-auth\";\n\nimport {\n  DecryptOptions,\n  DecryptParameters,\n  DecryptResult,\n  EncryptOptions,\n  EncryptParameters,\n  EncryptResult,\n  KeyWrapAlgorithm,\n  SignOptions,\n  SignResult,\n  UnwrapKeyOptions,\n  VerifyOptions,\n  VerifyResult,\n  WrapKeyOptions,\n  WrapResult,\n} from \"../cryptographyClientModels.js\";\nimport { SDK_VERSION } from \"../constants.js\";\nimport { UnwrapResult } from \"../cryptographyClientModels.js\";\nimport { KeyVaultClient } from \"../generated/index.js\";\nimport { parseKeyVaultKeyIdentifier } from \"../identifier.js\";\nimport {\n  CryptographyClientOptions,\n  GetKeyOptions,\n  KeyVaultKey,\n  LATEST_API_VERSION,\n} from \"../keysModels.js\";\nimport { getKeyFromKeyBundle } from \"../transformations.js\";\nimport { createHash } from \"./crypto.js\";\nimport { CryptographyProvider, CryptographyProviderOperation } from \"./models.js\";\nimport { logger } from \"../log.js\";\nimport { keyVaultAuthenticationPolicy } from \"@azure/keyvault-common\";\nimport { tracingClient } from \"../tracing.js\";\n\n/**\n * The remote cryptography provider is used to run crypto operations against KeyVault.\n * @internal\n */\nexport class RemoteCryptographyProvider implements CryptographyProvider {\n  constructor(\n    key: string | KeyVaultKey,\n    credential: TokenCredential,\n    pipelineOptions: CryptographyClientOptions = {},\n  ) {\n    this.client = getOrInitializeClient(credential, pipelineOptions);\n\n    this.key = key;\n\n    let keyId: string;\n    if (typeof key === \"string\") {\n      keyId = key;\n    } else {\n      keyId = key.id!;\n    }\n\n    try {\n      const parsed = parseKeyVaultKeyIdentifier(keyId);\n      if (parsed.name === \"\") {\n        throw new Error(\"Could not find 'name' of key in key URL\");\n      }\n\n      if (!parsed.vaultUrl || parsed.vaultUrl === \"\") {\n        throw new Error(\"Could not find 'vaultUrl' of key in key URL\");\n      }\n\n      this.vaultUrl = parsed.vaultUrl;\n      this.name = parsed.name;\n      this.version = parsed.version ?? \"\";\n    } catch (err: any) {\n      logger.error(err);\n\n      throw new Error(`${keyId} is not a valid Key Vault key ID`);\n    }\n  }\n\n  // The remote client supports all algorithms and all operations.\n  isSupported(_algorithm: string, _operation: CryptographyProviderOperation): boolean {\n    return true;\n  }\n\n  encrypt(\n    encryptParameters: EncryptParameters,\n    options: EncryptOptions = {},\n  ): Promise<EncryptResult> {\n    const { algorithm, plaintext, ...params } = encryptParameters;\n    const requestOptions = { ...options, ...params };\n\n    return tracingClient.withSpan(\n      \"RemoteCryptographyProvider.encrypt\",\n      requestOptions,\n      async (updatedOptions) => {\n        const result = await this.client.encrypt(\n          this.vaultUrl,\n          this.name,\n          this.version,\n          algorithm,\n          plaintext,\n          updatedOptions,\n        );\n\n        return {\n          algorithm: encryptParameters.algorithm,\n          result: result.result!,\n          keyID: this.getKeyID(),\n          additionalAuthenticatedData: result.additionalAuthenticatedData,\n          authenticationTag: result.authenticationTag,\n          iv: result.iv,\n        };\n      },\n    );\n  }\n\n  decrypt(\n    decryptParameters: DecryptParameters,\n    options: DecryptOptions = {},\n  ): Promise<DecryptResult> {\n    const { algorithm, ciphertext, ...params } = decryptParameters;\n    const requestOptions = { ...options, ...params };\n\n    return tracingClient.withSpan(\n      \"RemoteCryptographyProvider.decrypt\",\n      requestOptions,\n      async (updatedOptions) => {\n        const result = await this.client.decrypt(\n          this.vaultUrl,\n          this.name,\n          this.version,\n          algorithm,\n          ciphertext,\n          updatedOptions,\n        );\n        return {\n          result: result.result!,\n          keyID: this.getKeyID(),\n          algorithm,\n        };\n      },\n    );\n  }\n\n  wrapKey(\n    algorithm: KeyWrapAlgorithm,\n    keyToWrap: Uint8Array,\n    options: WrapKeyOptions = {},\n  ): Promise<WrapResult> {\n    return tracingClient.withSpan(\n      \"RemoteCryptographyProvider.wrapKey\",\n      options,\n      async (updatedOptions) => {\n        const result = await this.client.wrapKey(\n          this.vaultUrl,\n          this.name,\n          this.version,\n          algorithm,\n          keyToWrap,\n          updatedOptions,\n        );\n\n        return {\n          result: result.result!,\n          algorithm,\n          keyID: this.getKeyID(),\n        };\n      },\n    );\n  }\n\n  unwrapKey(\n    algorithm: KeyWrapAlgorithm,\n    encryptedKey: Uint8Array,\n    options: UnwrapKeyOptions = {},\n  ): Promise<UnwrapResult> {\n    return tracingClient.withSpan(\n      \"RemoteCryptographyProvider.unwrapKey\",\n      options,\n      async (updatedOptions) => {\n        const result = await this.client.unwrapKey(\n          this.vaultUrl,\n          this.name,\n          this.version,\n          algorithm,\n          encryptedKey,\n          updatedOptions,\n        );\n\n        return {\n          result: result.result!,\n          algorithm,\n          keyID: this.getKeyID(),\n        };\n      },\n    );\n  }\n\n  sign(algorithm: string, digest: Uint8Array, options: SignOptions = {}): Promise<SignResult> {\n    return tracingClient.withSpan(\n      \"RemoteCryptographyProvider.sign\",\n      options,\n      async (updatedOptions) => {\n        const result = await this.client.sign(\n          this.vaultUrl,\n          this.name,\n          this.version,\n          algorithm,\n          digest,\n          updatedOptions,\n        );\n\n        return { result: result.result!, algorithm, keyID: this.getKeyID() };\n      },\n    );\n  }\n\n  verifyData(\n    algorithm: string,\n    data: Uint8Array,\n    signature: Uint8Array,\n    options: VerifyOptions = {},\n  ): Promise<VerifyResult> {\n    return tracingClient.withSpan(\n      \"RemoteCryptographyProvider.verifyData\",\n      options,\n      async (updatedOptions) => {\n        const hash = await createHash(algorithm, data);\n        return this.verify(algorithm, hash, signature, updatedOptions);\n      },\n    );\n  }\n\n  verify(\n    algorithm: string,\n    digest: Uint8Array,\n    signature: Uint8Array,\n    options: VerifyOptions = {},\n  ): Promise<VerifyResult> {\n    return tracingClient.withSpan(\n      \"RemoteCryptographyProvider.verify\",\n      options,\n      async (updatedOptions) => {\n        const response = await this.client.verify(\n          this.vaultUrl,\n          this.name,\n          this.version,\n          algorithm,\n          digest,\n          signature,\n          updatedOptions,\n        );\n        return {\n          result: response.value ? response.value : false,\n          keyID: this.getKeyID(),\n        };\n      },\n    );\n  }\n\n  signData(algorithm: string, data: Uint8Array, options: SignOptions = {}): Promise<SignResult> {\n    return tracingClient.withSpan(\n      \"RemoteCryptographyProvider.signData\",\n      options,\n      async (updatedOptions) => {\n        const digest = await createHash(algorithm, data);\n        const result = await this.client.sign(\n          this.vaultUrl,\n          this.name,\n          this.version,\n          algorithm,\n          digest,\n          updatedOptions,\n        );\n        return { result: result.result!, algorithm, keyID: this.getKeyID() };\n      },\n    );\n  }\n\n  /**\n   * The base URL to the vault.\n   */\n  readonly vaultUrl: string;\n\n  /**\n   * The ID of the key used to perform cryptographic operations for the client.\n   */\n  get keyId(): string | undefined {\n    return this.getKeyID();\n  }\n\n  /**\n   * Gets the {@link KeyVaultKey} used for cryptography operations, fetching it\n   * from KeyVault if necessary.\n   * @param options - Additional options.\n   */\n  getKey(options: GetKeyOptions = {}): Promise<KeyVaultKey> {\n    return tracingClient.withSpan(\n      \"RemoteCryptographyProvider.getKey\",\n      options,\n      async (updatedOptions) => {\n        if (typeof this.key === \"string\") {\n          if (!this.name || this.name === \"\") {\n            throw new Error(\"getKey requires a key with a name\");\n          }\n          const response = await this.client.getKey(\n            this.vaultUrl,\n            this.name,\n            options && options.version ? options.version : this.version ? this.version : \"\",\n            updatedOptions,\n          );\n          this.key = getKeyFromKeyBundle(response);\n        }\n        return this.key;\n      },\n    );\n  }\n\n  /**\n   * A reference to the auto-generated KeyVault HTTP client.\n   */\n  private client: KeyVaultClient;\n\n  /**\n   * A reference to the key used for the cryptographic operations.\n   * Based on what was provided to the CryptographyClient constructor,\n   * it can be either a string with the URL of a Key Vault Key, or an already parsed {@link KeyVaultKey}.\n   */\n  private key: string | KeyVaultKey;\n\n  /**\n   * Name of the key the client represents\n   */\n  private name: string;\n\n  /**\n   * Version of the key the client represents\n   */\n  private version: string;\n\n  /**\n   * Attempts to retrieve the ID of the key.\n   */\n  private getKeyID(): string | undefined {\n    let kid;\n    if (typeof this.key !== \"string\") {\n      kid = this.key.id;\n    } else {\n      kid = this.key;\n    }\n\n    return kid;\n  }\n}\n\n/**\n * A helper method to either get the passed down generated client or initialize a new one.\n * An already constructed generated client may be passed down from {@link KeyClient} in which case we should reuse it.\n *\n * @internal\n * @param credential - The credential to use when initializing a new client.\n * @param options - The options for constructing a client or the underlying client if one already exists.\n * @returns - A generated client instance\n */\nfunction getOrInitializeClient(\n  credential: TokenCredential,\n  options: CryptographyClientOptions & { generatedClient?: KeyVaultClient },\n): KeyVaultClient {\n  if (options.generatedClient) {\n    return options.generatedClient;\n  }\n\n  const libInfo = `azsdk-js-keyvault-keys/${SDK_VERSION}`;\n\n  const userAgentOptions = options.userAgentOptions;\n\n  options.userAgentOptions = {\n    userAgentPrefix:\n      userAgentOptions && userAgentOptions.userAgentPrefix\n        ? `${userAgentOptions.userAgentPrefix} ${libInfo}`\n        : libInfo,\n  };\n\n  const internalPipelineOptions = {\n    ...options,\n    loggingOptions: {\n      logger: logger.info,\n      allowedHeaderNames: [\n        \"x-ms-keyvault-region\",\n        \"x-ms-keyvault-network-info\",\n        \"x-ms-keyvault-service-version\",\n      ],\n    },\n  };\n\n  const client = new KeyVaultClient(\n    options.serviceVersion || LATEST_API_VERSION,\n    internalPipelineOptions,\n  );\n\n  // The authentication policy must come after the deserialization policy since the deserialization policy\n  // converts 401 responses to an Error, and we don't want to deal with that.\n  client.pipeline.addPolicy(keyVaultAuthenticationPolicy(credential, options), {\n    afterPolicies: [\"deserializationPolicy\"],\n  });\n\n  return client;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}