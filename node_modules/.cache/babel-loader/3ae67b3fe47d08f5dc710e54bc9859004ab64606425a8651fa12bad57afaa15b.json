{"ast":null,"code":"// Add a translation cache and rate limiting\nconst translationCache = new Map();\nlet lastRequestTime = 0;\nconst minRequestInterval = 300; // milliseconds between requests\n\nexport const translateText = async (text, targetLanguage) => {\n  try {\n    // Make sure we have text to translate\n    if (!text) return '';\n\n    // Check cache first\n    const cacheKey = `${text}:${targetLanguage}`;\n    if (translationCache.has(cacheKey)) {\n      return translationCache.get(cacheKey);\n    }\n\n    // Use the correct Azure Translator endpoint\n    const endpoint = process.env.REACT_APP_TRANSLATOR_ENDPOINT || 'https://api.cognitive.microsofttranslator.com';\n    const apiKey = process.env.REACT_APP_TRANSLATOR_KEY;\n\n    // If no API key is configured, return the original text\n    if (!apiKey) {\n      console.warn('Translation API key not configured');\n      return text;\n    }\n\n    // Implement rate limiting\n    const now = Date.now();\n    const timeElapsed = now - lastRequestTime;\n    if (timeElapsed < minRequestInterval) {\n      await new Promise(resolve => setTimeout(resolve, minRequestInterval - timeElapsed));\n    }\n    lastRequestTime = Date.now();\n    const url = `${endpoint}/translate?api-version=3.0&to=${targetLanguage}`;\n\n    // Try up to 3 times with increasing backoff\n    let retries = 0;\n    const maxRetries = 3;\n    while (retries < maxRetries) {\n      try {\n        var _data$, _data$$translations$;\n        const response = await fetch(url, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'Ocp-Apim-Subscription-Key': apiKey,\n            'Ocp-Apim-Subscription-Region': process.env.REACT_APP_TRANSLATOR_LOCATION || 'global'\n          },\n          body: JSON.stringify([{\n            text\n          }])\n        });\n        if (response.status === 429) {\n          // If rate limited, wait and retry\n          const retryAfter = response.headers.get('Retry-After') || 2 ** retries;\n          console.warn(`Rate limited, retrying after ${retryAfter} seconds...`);\n          await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));\n          retries++;\n          continue;\n        }\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        const result = ((_data$ = data[0]) === null || _data$ === void 0 ? void 0 : (_data$$translations$ = _data$.translations[0]) === null || _data$$translations$ === void 0 ? void 0 : _data$$translations$.text) || text;\n\n        // Cache the result\n        translationCache.set(cacheKey, result);\n        return result;\n      } catch (error) {\n        if (retries < maxRetries - 1) {\n          // Exponential backoff\n          const backoffTime = 1000 * 2 ** retries;\n          await new Promise(resolve => setTimeout(resolve, backoffTime));\n          retries++;\n        } else {\n          throw error;\n        }\n      }\n    }\n\n    // If all retries fail, return original text\n    return text;\n  } catch (error) {\n    console.error('Translation error:', error);\n    // Return original text if translation fails\n    return text;\n  }\n};\n\n// Add a batch translation function for multiple texts\nexport const translateBatch = async (texts, targetLanguage) => {\n  if (!texts || texts.length === 0) return [];\n\n  // For English, skip translation\n  if (targetLanguage === 'en') {\n    return texts;\n  }\n\n  // Check cache first and collect only texts that need translation\n  const results = [];\n  const textsToTranslate = [];\n  const indices = [];\n  for (let i = 0; i < texts.length; i++) {\n    const text = texts[i];\n    const cacheKey = `${text}:${targetLanguage}`;\n    if (translationCache.has(cacheKey)) {\n      results[i] = translationCache.get(cacheKey);\n    } else {\n      textsToTranslate.push(text);\n      indices.push(i);\n      // Initialize with original text in case translation fails\n      results[i] = text;\n    }\n  }\n\n  // If all translations are cached, return immediately\n  if (textsToTranslate.length === 0) {\n    return results;\n  }\n  try {\n    // Implement rate limiting\n    const now = Date.now();\n    const timeElapsed = now - lastRequestTime;\n    if (timeElapsed < minRequestInterval) {\n      await new Promise(resolve => setTimeout(resolve, minRequestInterval - timeElapsed));\n    }\n    lastRequestTime = Date.now();\n    const endpoint = process.env.REACT_APP_TRANSLATOR_ENDPOINT || 'https://api.cognitive.microsofttranslator.com';\n    const apiKey = process.env.REACT_APP_TRANSLATOR_KEY;\n    if (!apiKey) {\n      console.warn('Translation API key not configured');\n      return texts;\n    }\n    const url = `${endpoint}/translate?api-version=3.0&to=${targetLanguage}`;\n\n    // Try up to 3 times with increasing backoff\n    let retries = 0;\n    const maxRetries = 3;\n    while (retries < maxRetries) {\n      try {\n        const response = await fetch(url, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'Ocp-Apim-Subscription-Key': apiKey,\n            'Ocp-Apim-Subscription-Region': process.env.REACT_APP_TRANSLATOR_LOCATION || 'global'\n          },\n          body: JSON.stringify(textsToTranslate.map(text => ({\n            text\n          })))\n        });\n        if (response.status === 429) {\n          // If rate limited, wait and retry\n          const retryAfter = response.headers.get('Retry-After') || 2 ** retries;\n          console.warn(`Rate limited, retrying after ${retryAfter} seconds...`);\n          await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));\n          retries++;\n          continue;\n        }\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n\n        // Update results and cache\n        for (let i = 0; i < data.length; i++) {\n          var _data$i, _data$i$translations$;\n          const translatedText = ((_data$i = data[i]) === null || _data$i === void 0 ? void 0 : (_data$i$translations$ = _data$i.translations[0]) === null || _data$i$translations$ === void 0 ? void 0 : _data$i$translations$.text) || textsToTranslate[i];\n          const originalIndex = indices[i];\n          results[originalIndex] = translatedText;\n\n          // Cache the result\n          const cacheKey = `${textsToTranslate[i]}:${targetLanguage}`;\n          translationCache.set(cacheKey, translatedText);\n        }\n        return results;\n      } catch (error) {\n        if (retries < maxRetries - 1) {\n          // Exponential backoff\n          const backoffTime = 1000 * 2 ** retries;\n          await new Promise(resolve => setTimeout(resolve, backoffTime));\n          retries++;\n        } else {\n          throw error;\n        }\n      }\n    }\n\n    // If all retries fail, return original texts\n    return texts;\n  } catch (error) {\n    console.error('Batch translation error:', error);\n    return texts;\n  }\n};","map":{"version":3,"names":["translationCache","Map","lastRequestTime","minRequestInterval","translateText","text","targetLanguage","cacheKey","has","get","endpoint","process","env","REACT_APP_TRANSLATOR_ENDPOINT","apiKey","REACT_APP_TRANSLATOR_KEY","console","warn","now","Date","timeElapsed","Promise","resolve","setTimeout","url","retries","maxRetries","_data$","_data$$translations$","response","fetch","method","headers","REACT_APP_TRANSLATOR_LOCATION","body","JSON","stringify","status","retryAfter","ok","Error","data","json","result","translations","set","error","backoffTime","translateBatch","texts","length","results","textsToTranslate","indices","i","push","map","_data$i","_data$i$translations$","translatedText","originalIndex"],"sources":["/Users/eimis/test-server/Azure Hackthons/azure-cloud-architecture-game /src/services/TranslationService.js"],"sourcesContent":["// Add a translation cache and rate limiting\nconst translationCache = new Map();\nlet lastRequestTime = 0;\nconst minRequestInterval = 300; // milliseconds between requests\n\nexport const translateText = async (text, targetLanguage) => {\n  try {\n    // Make sure we have text to translate\n    if (!text) return '';\n    \n    // Check cache first\n    const cacheKey = `${text}:${targetLanguage}`;\n    if (translationCache.has(cacheKey)) {\n      return translationCache.get(cacheKey);\n    }\n    \n    // Use the correct Azure Translator endpoint\n    const endpoint = process.env.REACT_APP_TRANSLATOR_ENDPOINT || 'https://api.cognitive.microsofttranslator.com';\n    const apiKey = process.env.REACT_APP_TRANSLATOR_KEY;\n    \n    // If no API key is configured, return the original text\n    if (!apiKey) {\n      console.warn('Translation API key not configured');\n      return text;\n    }\n\n    // Implement rate limiting\n    const now = Date.now();\n    const timeElapsed = now - lastRequestTime;\n    if (timeElapsed < minRequestInterval) {\n      await new Promise(resolve => setTimeout(resolve, minRequestInterval - timeElapsed));\n    }\n    \n    lastRequestTime = Date.now();\n    \n    const url = `${endpoint}/translate?api-version=3.0&to=${targetLanguage}`;\n    \n    // Try up to 3 times with increasing backoff\n    let retries = 0;\n    const maxRetries = 3;\n    \n    while (retries < maxRetries) {\n      try {\n        const response = await fetch(url, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'Ocp-Apim-Subscription-Key': apiKey,\n            'Ocp-Apim-Subscription-Region': process.env.REACT_APP_TRANSLATOR_LOCATION || 'global'\n          },\n          body: JSON.stringify([{ text }])\n        });\n\n        if (response.status === 429) {\n          // If rate limited, wait and retry\n          const retryAfter = response.headers.get('Retry-After') || (2 ** retries);\n          console.warn(`Rate limited, retrying after ${retryAfter} seconds...`);\n          await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));\n          retries++;\n          continue;\n        }\n        \n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n\n        const data = await response.json();\n        const result = data[0]?.translations[0]?.text || text;\n        \n        // Cache the result\n        translationCache.set(cacheKey, result);\n        \n        return result;\n      } catch (error) {\n        if (retries < maxRetries - 1) {\n          // Exponential backoff\n          const backoffTime = 1000 * (2 ** retries);\n          await new Promise(resolve => setTimeout(resolve, backoffTime));\n          retries++;\n        } else {\n          throw error;\n        }\n      }\n    }\n    \n    // If all retries fail, return original text\n    return text;\n  } catch (error) {\n    console.error('Translation error:', error);\n    // Return original text if translation fails\n    return text;\n  }\n};\n\n// Add a batch translation function for multiple texts\nexport const translateBatch = async (texts, targetLanguage) => {\n  if (!texts || texts.length === 0) return [];\n  \n  // For English, skip translation\n  if (targetLanguage === 'en') {\n    return texts;\n  }\n  \n  // Check cache first and collect only texts that need translation\n  const results = [];\n  const textsToTranslate = [];\n  const indices = [];\n  \n  for (let i = 0; i < texts.length; i++) {\n    const text = texts[i];\n    const cacheKey = `${text}:${targetLanguage}`;\n    \n    if (translationCache.has(cacheKey)) {\n      results[i] = translationCache.get(cacheKey);\n    } else {\n      textsToTranslate.push(text);\n      indices.push(i);\n      // Initialize with original text in case translation fails\n      results[i] = text;\n    }\n  }\n  \n  // If all translations are cached, return immediately\n  if (textsToTranslate.length === 0) {\n    return results;\n  }\n  \n  try {\n    // Implement rate limiting\n    const now = Date.now();\n    const timeElapsed = now - lastRequestTime;\n    if (timeElapsed < minRequestInterval) {\n      await new Promise(resolve => setTimeout(resolve, minRequestInterval - timeElapsed));\n    }\n    \n    lastRequestTime = Date.now();\n    \n    const endpoint = process.env.REACT_APP_TRANSLATOR_ENDPOINT || 'https://api.cognitive.microsofttranslator.com';\n    const apiKey = process.env.REACT_APP_TRANSLATOR_KEY;\n    \n    if (!apiKey) {\n      console.warn('Translation API key not configured');\n      return texts;\n    }\n    \n    const url = `${endpoint}/translate?api-version=3.0&to=${targetLanguage}`;\n    \n    // Try up to 3 times with increasing backoff\n    let retries = 0;\n    const maxRetries = 3;\n    \n    while (retries < maxRetries) {\n      try {\n        const response = await fetch(url, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'Ocp-Apim-Subscription-Key': apiKey,\n            'Ocp-Apim-Subscription-Region': process.env.REACT_APP_TRANSLATOR_LOCATION || 'global'\n          },\n          body: JSON.stringify(textsToTranslate.map(text => ({ text })))\n        });\n        \n        if (response.status === 429) {\n          // If rate limited, wait and retry\n          const retryAfter = response.headers.get('Retry-After') || (2 ** retries);\n          console.warn(`Rate limited, retrying after ${retryAfter} seconds...`);\n          await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));\n          retries++;\n          continue;\n        }\n        \n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        // Update results and cache\n        for (let i = 0; i < data.length; i++) {\n          const translatedText = data[i]?.translations[0]?.text || textsToTranslate[i];\n          const originalIndex = indices[i];\n          results[originalIndex] = translatedText;\n          \n          // Cache the result\n          const cacheKey = `${textsToTranslate[i]}:${targetLanguage}`;\n          translationCache.set(cacheKey, translatedText);\n        }\n        \n        return results;\n      } catch (error) {\n        if (retries < maxRetries - 1) {\n          // Exponential backoff\n          const backoffTime = 1000 * (2 ** retries);\n          await new Promise(resolve => setTimeout(resolve, backoffTime));\n          retries++;\n        } else {\n          throw error;\n        }\n      }\n    }\n    \n    // If all retries fail, return original texts\n    return texts;\n  } catch (error) {\n    console.error('Batch translation error:', error);\n    return texts;\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}