{"ast":null,"code":"import { hashObject } from \"../../utils/hashObject\";\nimport { createAggregator } from \"../Aggregators\";\nimport { getInitialHeader, mergeHeaders } from \"../headerUtils\";\nimport { emptyGroup, extractAggregateResult } from \"./emptyGroup\";\n/** @hidden */\nexport class GroupByValueEndpointComponent {\n  constructor(executionContext, queryInfo) {\n    this.executionContext = executionContext;\n    this.queryInfo = queryInfo;\n    this.aggregators = new Map();\n    this.aggregateResultArray = [];\n    this.completed = false;\n    // VALUE queries will only every have a single grouping\n    this.aggregateType = this.queryInfo.aggregates[0];\n  }\n  hasMoreResults() {\n    return this.executionContext.hasMoreResults();\n  }\n  async fetchMore(diagnosticNode) {\n    if (this.completed) {\n      return {\n        result: undefined,\n        headers: getInitialHeader()\n      };\n    }\n    const aggregateHeaders = getInitialHeader();\n    const response = await this.executionContext.fetchMore(diagnosticNode);\n    mergeHeaders(aggregateHeaders, response.headers);\n    if (response === undefined || response.result === undefined) {\n      if (this.aggregators.size > 0) {\n        return this.generateAggregateResponse(aggregateHeaders);\n      }\n      return {\n        result: undefined,\n        headers: aggregateHeaders\n      };\n    }\n    for (const item of response.result) {\n      if (item) {\n        let grouping = emptyGroup;\n        let payload = item;\n        if (item.groupByItems) {\n          // If the query contains a GROUP BY clause, it will have a payload property and groupByItems\n          payload = item.payload;\n          grouping = await hashObject(item.groupByItems);\n        }\n        const aggregator = this.aggregators.get(grouping);\n        if (!aggregator) {\n          // This is the first time we have seen a grouping so create a new aggregator\n          this.aggregators.set(grouping, createAggregator(this.aggregateType));\n        }\n        if (this.aggregateType) {\n          const aggregateResult = extractAggregateResult(payload[0]);\n          // if aggregate result is null, we need to short circuit aggregation and return undefined\n          if (aggregateResult === null) {\n            this.completed = true;\n          }\n          this.aggregators.get(grouping).aggregate(aggregateResult);\n        } else {\n          // Queries with no aggregates pass the payload directly to the aggregator\n          // Example: SELECT VALUE c.team FROM c GROUP BY c.team\n          this.aggregators.get(grouping).aggregate(payload);\n        }\n      }\n    }\n    // We bail early since we got an undefined result back `[{}]`\n    if (this.completed) {\n      return {\n        result: undefined,\n        headers: aggregateHeaders\n      };\n    }\n    if (this.executionContext.hasMoreResults()) {\n      return {\n        result: [],\n        headers: aggregateHeaders\n      };\n    } else {\n      // If no results are left in the underlying execution context, convert our aggregate results to an array\n      return this.generateAggregateResponse(aggregateHeaders);\n    }\n  }\n  generateAggregateResponse(aggregateHeaders) {\n    for (const aggregator of this.aggregators.values()) {\n      const result = aggregator.getResult();\n      if (result !== undefined) {\n        this.aggregateResultArray.push(result);\n      }\n    }\n    this.completed = true;\n    return {\n      result: this.aggregateResultArray,\n      headers: aggregateHeaders\n    };\n  }\n}","map":{"version":3,"names":["hashObject","createAggregator","getInitialHeader","mergeHeaders","emptyGroup","extractAggregateResult","GroupByValueEndpointComponent","constructor","executionContext","queryInfo","aggregators","Map","aggregateResultArray","completed","aggregateType","aggregates","hasMoreResults","fetchMore","diagnosticNode","result","undefined","headers","aggregateHeaders","response","size","generateAggregateResponse","item","grouping","payload","groupByItems","aggregator","get","set","aggregateResult","aggregate","values","getResult","push"],"sources":["/Users/eimis/test-server/Azure Hackthons/azure-cloud-architecture-game /node_modules/@azure/cosmos/src/queryExecutionContext/EndpointComponent/GroupByValueEndpointComponent.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { Response } from \"../../request\";\nimport type { ExecutionContext } from \"../ExecutionContext\";\nimport type { CosmosHeaders } from \"../CosmosHeaders\";\nimport type { AggregateType, QueryInfo } from \"../../request/ErrorResponse\";\nimport { hashObject } from \"../../utils/hashObject\";\nimport type { Aggregator } from \"../Aggregators\";\nimport { createAggregator } from \"../Aggregators\";\nimport { getInitialHeader, mergeHeaders } from \"../headerUtils\";\nimport { emptyGroup, extractAggregateResult } from \"./emptyGroup\";\nimport type { DiagnosticNodeInternal } from \"../../diagnostics/DiagnosticNodeInternal\";\n\ninterface GroupByResult {\n  groupByItems: any[];\n  payload: any;\n}\n\n/** @hidden */\nexport class GroupByValueEndpointComponent implements ExecutionContext {\n  private readonly aggregators: Map<string, Aggregator> = new Map();\n  private readonly aggregateResultArray: any[] = [];\n  private aggregateType: AggregateType;\n  private completed: boolean = false;\n\n  constructor(\n    private executionContext: ExecutionContext,\n    private queryInfo: QueryInfo,\n  ) {\n    // VALUE queries will only every have a single grouping\n    this.aggregateType = this.queryInfo.aggregates[0];\n  }\n\n  public hasMoreResults(): boolean {\n    return this.executionContext.hasMoreResults();\n  }\n\n  public async fetchMore(diagnosticNode: DiagnosticNodeInternal): Promise<Response<any>> {\n    if (this.completed) {\n      return {\n        result: undefined,\n        headers: getInitialHeader(),\n      };\n    }\n    const aggregateHeaders = getInitialHeader();\n    const response = await this.executionContext.fetchMore(diagnosticNode);\n    mergeHeaders(aggregateHeaders, response.headers);\n\n    if (response === undefined || response.result === undefined) {\n      if (this.aggregators.size > 0) {\n        return this.generateAggregateResponse(aggregateHeaders);\n      }\n      return { result: undefined, headers: aggregateHeaders };\n    }\n\n    for (const item of response.result as GroupByResult[]) {\n      if (item) {\n        let grouping: string = emptyGroup;\n        let payload: any = item;\n        if (item.groupByItems) {\n          // If the query contains a GROUP BY clause, it will have a payload property and groupByItems\n          payload = item.payload;\n          grouping = await hashObject(item.groupByItems);\n        }\n\n        const aggregator = this.aggregators.get(grouping);\n        if (!aggregator) {\n          // This is the first time we have seen a grouping so create a new aggregator\n          this.aggregators.set(grouping, createAggregator(this.aggregateType));\n        }\n\n        if (this.aggregateType) {\n          const aggregateResult = extractAggregateResult(payload[0]);\n          // if aggregate result is null, we need to short circuit aggregation and return undefined\n          if (aggregateResult === null) {\n            this.completed = true;\n          }\n          this.aggregators.get(grouping).aggregate(aggregateResult);\n        } else {\n          // Queries with no aggregates pass the payload directly to the aggregator\n          // Example: SELECT VALUE c.team FROM c GROUP BY c.team\n          this.aggregators.get(grouping).aggregate(payload);\n        }\n      }\n    }\n\n    // We bail early since we got an undefined result back `[{}]`\n    if (this.completed) {\n      return {\n        result: undefined,\n        headers: aggregateHeaders,\n      };\n    }\n\n    if (this.executionContext.hasMoreResults()) {\n      return { result: [], headers: aggregateHeaders };\n    } else {\n      // If no results are left in the underlying execution context, convert our aggregate results to an array\n      return this.generateAggregateResponse(aggregateHeaders);\n    }\n  }\n\n  private generateAggregateResponse(aggregateHeaders: CosmosHeaders): Response<any> {\n    for (const aggregator of this.aggregators.values()) {\n      const result = aggregator.getResult();\n      if (result !== undefined) {\n        this.aggregateResultArray.push(result);\n      }\n    }\n    this.completed = true;\n    return {\n      result: this.aggregateResultArray,\n      headers: aggregateHeaders,\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}