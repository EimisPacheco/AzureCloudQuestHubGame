{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/// <reference lib=\"esnext.asynciterable\" />\nimport { __asyncGenerator, __asyncValues, __await, __rest } from \"tslib\";\nimport { logger } from \"./log.js\";\nimport { KnownDeletionRecoveryLevel, KnownJsonWebKeyType } from \"./generated/models/index.js\";\nimport { KeyVaultClient } from \"./generated/keyVaultClient.js\";\nimport { SDK_VERSION } from \"./constants.js\";\nimport { keyVaultAuthenticationPolicy } from \"@azure/keyvault-common\";\nimport { DeleteKeyPoller } from \"./lro/delete/poller.js\";\nimport { RecoverDeletedKeyPoller } from \"./lro/recover/poller.js\";\nimport { KnownKeyExportEncryptionAlgorithm, KnownKeyOperations, KnownKeyTypes, LATEST_API_VERSION } from \"./keysModels.js\";\nimport { CryptographyClient } from \"./cryptographyClient.js\";\nimport { KnownEncryptionAlgorithms, KnownKeyCurveNames, KnownSignatureAlgorithms } from \"./cryptographyClientModels.js\";\nimport { parseKeyVaultKeyIdentifier } from \"./identifier.js\";\nimport { getDeletedKeyFromDeletedKeyItem, getKeyFromKeyBundle, getKeyPropertiesFromKeyItem, keyRotationTransformations } from \"./transformations.js\";\nimport { tracingClient } from \"./tracing.js\";\nexport { CryptographyClient, KnownDeletionRecoveryLevel, KnownKeyCurveNames, KnownKeyExportEncryptionAlgorithm, KnownEncryptionAlgorithms, KnownKeyOperations, KnownKeyTypes, KnownSignatureAlgorithms, parseKeyVaultKeyIdentifier, logger };\n/**\n * The KeyClient provides methods to manage {@link KeyVaultKey} in the\n * Azure Key Vault. The client supports creating, retrieving, updating,\n * deleting, purging, backing up, restoring and listing KeyVaultKeys. The\n * client also supports listing {@link DeletedKey} for a soft-delete enabled Azure Key\n * Vault.\n */\nexport class KeyClient {\n  /**\n   * Creates an instance of KeyClient.\n   *\n   * Example usage:\n   * ```ts\n   * import { KeyClient } from \"@azure/keyvault-keys\";\n   * import { DefaultAzureCredential } from \"@azure/identity\";\n   *\n   * let vaultUrl = `https://<MY KEYVAULT HERE>.vault.azure.net`;\n   * let credentials = new DefaultAzureCredential();\n   *\n   * let client = new KeyClient(vaultUrl, credentials);\n   * ```\n   * @param vaultUrl - the URL of the Key Vault. It should have this shape: `https://${your-key-vault-name}.vault.azure.net`. You should validate that this URL references a valid Key Vault or Managed HSM resource. See https://aka.ms/azsdk/blog/vault-uri for details.\n   * @param credential - An object that implements the `TokenCredential` interface used to authenticate requests to the service. Use the \\@azure/identity package to create a credential that suits your needs.\n   * @param pipelineOptions - Pipeline options used to configure Key Vault API requests. Omit this parameter to use the default pipeline configuration.\n   */\n  constructor(vaultUrl, credential, pipelineOptions = {}) {\n    this.vaultUrl = vaultUrl;\n    const libInfo = `azsdk-js-keyvault-keys/${SDK_VERSION}`;\n    const userAgentOptions = pipelineOptions.userAgentOptions;\n    pipelineOptions.userAgentOptions = {\n      userAgentPrefix: userAgentOptions && userAgentOptions.userAgentPrefix ? `${userAgentOptions.userAgentPrefix} ${libInfo}` : libInfo\n    };\n    const internalPipelineOptions = Object.assign(Object.assign({}, pipelineOptions), {\n      loggingOptions: {\n        logger: logger.info,\n        allowedHeaderNames: [\"x-ms-keyvault-region\", \"x-ms-keyvault-network-info\", \"x-ms-keyvault-service-version\"]\n      }\n    });\n    this.credential = credential;\n    this.client = new KeyVaultClient(pipelineOptions.serviceVersion || LATEST_API_VERSION, internalPipelineOptions);\n    // The authentication policy must come after the deserialization policy since the deserialization policy\n    // converts 401 responses to an Error, and we don't want to deal with that.\n    this.client.pipeline.addPolicy(keyVaultAuthenticationPolicy(credential, pipelineOptions), {\n      afterPolicies: [\"deserializationPolicy\"]\n    });\n  }\n  /**\n   * The create key operation can be used to create any key type in Azure Key Vault. If the named key\n   * already exists, Azure Key Vault creates a new version of the key. It requires the keys/create\n   * permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * // Create an elliptic-curve key:\n   * let result = await client.createKey(\"MyKey\", \"EC\");\n   * ```\n   * Creates a new key, stores it, then returns key parameters and properties to the client.\n   * @param name - The name of the key.\n   * @param keyType - The type of the key. One of the following: 'EC', 'EC-HSM', 'RSA', 'RSA-HSM', 'oct'.\n   * @param options - The optional parameters.\n   */\n  createKey(name, keyType, options) {\n    let unflattenedOptions = {};\n    if (options) {\n      const {\n          enabled,\n          notBefore,\n          expiresOn: expires,\n          exportable\n        } = options,\n        remainingOptions = __rest(options, [\"enabled\", \"notBefore\", \"expiresOn\", \"exportable\"]);\n      unflattenedOptions = Object.assign(Object.assign({}, remainingOptions), {\n        keyAttributes: {\n          enabled,\n          notBefore,\n          expires,\n          exportable\n        }\n      });\n    }\n    return tracingClient.withSpan(\"KeyClient.createKey\", unflattenedOptions, async updatedOptions => {\n      const response = await this.client.createKey(this.vaultUrl, name, keyType, updatedOptions);\n      return getKeyFromKeyBundle(response);\n    });\n  }\n  /**\n   * The createEcKey method creates a new elliptic curve key in Azure Key Vault. If the named key\n   * already exists, Azure Key Vault creates a new version of the key. It requires the keys/create\n   * permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * let result = await client.createEcKey(\"MyKey\", { curve: \"P-256\" });\n   * ```\n   * Creates a new key, stores it, then returns key parameters and properties to the client.\n   * @param name - The name of the key.\n   * @param options - The optional parameters.\n   */\n  async createEcKey(name, options) {\n    const keyType = (options === null || options === void 0 ? void 0 : options.hsm) ? KnownJsonWebKeyType.ECHSM : KnownJsonWebKeyType.EC;\n    return this.createKey(name, keyType, options);\n  }\n  /**\n   * The createRSAKey method creates a new RSA key in Azure Key Vault. If the named key\n   * already exists, Azure Key Vault creates a new version of the key. It requires the keys/create\n   * permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * let result = await client.createRsaKey(\"MyKey\", { keySize: 2048 });\n   * ```\n   * Creates a new key, stores it, then returns key parameters and properties to the client.\n   * @param name - The name of the key.\n   * @param options - The optional parameters.\n   */\n  async createRsaKey(name, options) {\n    const keyType = (options === null || options === void 0 ? void 0 : options.hsm) ? KnownJsonWebKeyType.RSAHSM : KnownJsonWebKeyType.RSA;\n    return this.createKey(name, keyType, options);\n  }\n  /**\n   * The createOctKey method creates a new OCT key in Azure Key Vault. If the named key\n   * already exists, Azure Key Vault creates a new version of the key. It requires the keys/create\n   * permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * let result = await client.createOctKey(\"MyKey\", { hsm: true });\n   * ```\n   * Creates a new key, stores it, then returns key parameters and properties to the client.\n   * @param name - The name of the key.\n   * @param options - The optional parameters.\n   */\n  async createOctKey(name, options) {\n    const keyType = (options === null || options === void 0 ? void 0 : options.hsm) ? KnownJsonWebKeyType.OctHSM : KnownJsonWebKeyType.Oct;\n    return this.createKey(name, keyType, options);\n  }\n  /**\n   * The import key operation may be used to import any key type into an Azure Key Vault. If the\n   * named key already exists, Azure Key Vault creates a new version of the key. This operation\n   * requires the keys/import permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * // Key contents in myKeyContents\n   * let result = await client.importKey(\"MyKey\", myKeyContents);\n   * ```\n   * Imports an externally created key, stores it, and returns key parameters and properties\n   * to the client.\n   * @param name - Name for the imported key.\n   * @param key - The JSON web key.\n   * @param options - The optional parameters.\n   */\n  importKey(name, key, options) {\n    let unflattenedOptions = {};\n    if (options) {\n      const {\n          enabled,\n          notBefore,\n          exportable,\n          expiresOn: expires,\n          hardwareProtected: hsm\n        } = options,\n        remainingOptions = __rest(options, [\"enabled\", \"notBefore\", \"exportable\", \"expiresOn\", \"hardwareProtected\"]);\n      unflattenedOptions = Object.assign(Object.assign({}, remainingOptions), {\n        keyAttributes: {\n          enabled,\n          notBefore,\n          expires,\n          hsm,\n          exportable\n        }\n      });\n    }\n    return tracingClient.withSpan(`KeyClient.importKey`, unflattenedOptions, async updatedOptions => {\n      const response = await this.client.importKey(this.vaultUrl, name, key, updatedOptions);\n      return getKeyFromKeyBundle(response);\n    });\n  }\n  /**\n   * Gets a {@link CryptographyClient} for the given key.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * // get a cryptography client for a given key\n   * let cryptographyClient = client.getCryptographyClient(\"MyKey\");\n   * ```\n   * @param name - The name of the key used to perform cryptographic operations.\n   * @param version - Optional version of the key used to perform cryptographic operations.\n   * @returns - A {@link CryptographyClient} using the same options, credentials, and http client as this {@link KeyClient}\n   */\n  getCryptographyClient(keyName, options) {\n    const keyUrl = new URL([\"keys\", keyName, options === null || options === void 0 ? void 0 : options.keyVersion].filter(Boolean).join(\"/\"), this.vaultUrl);\n    // The goals of this method are discoverability and performance (by sharing a client and pipeline).\n    // The existing cryptography client does not accept a pipeline as an argument, nor does it expose it.\n    // In order to avoid publicly exposing the pipeline we will pass in the underlying client as an undocumented\n    // property to the constructor so that crypto providers downstream can use it.\n    const constructorOptions = {\n      generatedClient: this.client\n    };\n    const cryptoClient = new CryptographyClient(keyUrl.toString(), this.credential, constructorOptions);\n    return cryptoClient;\n  }\n  /**\n   * The delete operation applies to any key stored in Azure Key Vault. Individual versions\n   * of a key can not be deleted, only all versions of a given key at once.\n   *\n   * This function returns a Long Running Operation poller that allows you to wait indefinitely until the key is deleted.\n   *\n   * This operation requires the keys/delete permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new KeyClient(url, credentials);\n   * await client.createKey(\"MyKey\", \"EC\");\n   * const poller = await client.beginDeleteKey(\"MyKey\");\n   *\n   * // Serializing the poller\n   * const serialized = poller.toString();\n   * // A new poller can be created with:\n   * // await client.beginDeleteKey(\"MyKey\", { resumeFrom: serialized });\n   *\n   * // Waiting until it's done\n   * const deletedKey = await poller.pollUntilDone();\n   * console.log(deletedKey);\n   * ```\n   * Deletes a key from a specified key vault.\n   * @param name - The name of the key.\n   * @param options - The optional parameters.\n   */\n  async beginDeleteKey(name, options = {}) {\n    const poller = new DeleteKeyPoller({\n      name,\n      vaultUrl: this.vaultUrl,\n      client: this.client,\n      intervalInMs: options.intervalInMs,\n      resumeFrom: options.resumeFrom,\n      operationOptions: options\n    });\n    // This will initialize the poller's operation (the deletion of the key).\n    await poller.poll();\n    return poller;\n  }\n  updateKeyProperties(...args) {\n    const [name, keyVersion, options] = this.disambiguateUpdateKeyPropertiesArgs(args);\n    return tracingClient.withSpan(`KeyClient.updateKeyProperties`, options, async updatedOptions => {\n      const {\n          enabled,\n          notBefore,\n          expiresOn: expires\n        } = updatedOptions,\n        remainingOptions = __rest(updatedOptions, [\"enabled\", \"notBefore\", \"expiresOn\"]);\n      const unflattenedOptions = Object.assign(Object.assign({}, remainingOptions), {\n        keyAttributes: {\n          enabled,\n          notBefore,\n          expires\n        }\n      });\n      const response = await this.client.updateKey(this.vaultUrl, name, keyVersion, unflattenedOptions);\n      return getKeyFromKeyBundle(response);\n    });\n  }\n  /**\n   * Standardizes an overloaded arguments collection for the updateKeyProperties method.\n   *\n   * @param args - The arguments collection.\n   * @returns - The standardized arguments collection.\n   */\n  disambiguateUpdateKeyPropertiesArgs(args) {\n    if (typeof args[1] === \"string\") {\n      // [name, keyVersion, options?] => [name, keyVersion, options || {}]\n      return [args[0], args[1], args[2] || {}];\n    } else {\n      // [name, options?] => [name , \"\", options || {}]\n      return [args[0], \"\", args[1] || {}];\n    }\n  }\n  /**\n   * The getKey method gets a specified key and is applicable to any key stored in Azure Key Vault.\n   * This operation requires the keys/get permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * let key = await client.getKey(\"MyKey\");\n   * ```\n   * Get a specified key from a given key vault.\n   * @param name - The name of the key.\n   * @param options - The optional parameters.\n   */\n  getKey(name, options = {}) {\n    return tracingClient.withSpan(`KeyClient.getKey`, options, async updatedOptions => {\n      const response = await this.client.getKey(this.vaultUrl, name, options && options.version ? options.version : \"\", updatedOptions);\n      return getKeyFromKeyBundle(response);\n    });\n  }\n  /**\n   * The getDeletedKey method returns the specified deleted key along with its properties.\n   * This operation requires the keys/get permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * let key = await client.getDeletedKey(\"MyDeletedKey\");\n   * ```\n   * Gets the specified deleted key.\n   * @param name - The name of the key.\n   * @param options - The optional parameters.\n   */\n  getDeletedKey(name, options = {}) {\n    return tracingClient.withSpan(`KeyClient.getDeletedKey`, options, async updatedOptions => {\n      const response = await this.client.getDeletedKey(this.vaultUrl, name, updatedOptions);\n      return getKeyFromKeyBundle(response);\n    });\n  }\n  /**\n   * The purge deleted key operation removes the key permanently, without the possibility of\n   * recovery. This operation can only be enabled on a soft-delete enabled vault. This operation\n   * requires the keys/purge permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new KeyClient(url, credentials);\n   * const deletePoller = await client.beginDeleteKey(\"MyKey\")\n   * await deletePoller.pollUntilDone();\n   * await client.purgeDeletedKey(\"MyKey\");\n   * ```\n   * Permanently deletes the specified key.\n   * @param name - The name of the key.\n   * @param options - The optional parameters.\n   */\n  purgeDeletedKey(name, options = {}) {\n    return tracingClient.withSpan(`KeyClient.purgeDeletedKey`, options, async updatedOptions => {\n      await this.client.purgeDeletedKey(this.vaultUrl, name, updatedOptions);\n    });\n  }\n  /**\n   * Recovers the deleted key in the specified vault. This operation can only be performed on a\n   * soft-delete enabled vault.\n   *\n   * This function returns a Long Running Operation poller that allows you to wait indefinitely until the deleted key is recovered.\n   *\n   * This operation requires the keys/recover permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new KeyClient(url, credentials);\n   * await client.createKey(\"MyKey\", \"EC\");\n   * const deletePoller = await client.beginDeleteKey(\"MyKey\");\n   * await deletePoller.pollUntilDone();\n   * const poller = await client.beginRecoverDeletedKey(\"MyKey\");\n   *\n   * // Serializing the poller\n   * const serialized = poller.toString();\n   * // A new poller can be created with:\n   * // await client.beginRecoverDeletedKey(\"MyKey\", { resumeFrom: serialized });\n   *\n   * // Waiting until it's done\n   * const key = await poller.pollUntilDone();\n   * console.log(key);\n   * ```\n   * Recovers the deleted key to the latest version.\n   * @param name - The name of the deleted key.\n   * @param options - The optional parameters.\n   */\n  async beginRecoverDeletedKey(name, options = {}) {\n    const poller = new RecoverDeletedKeyPoller({\n      name,\n      vaultUrl: this.vaultUrl,\n      client: this.client,\n      intervalInMs: options.intervalInMs,\n      resumeFrom: options.resumeFrom,\n      operationOptions: options\n    });\n    // This will initialize the poller's operation (the deletion of the key).\n    await poller.poll();\n    return poller;\n  }\n  /**\n   * Requests that a backup of the specified key be downloaded to the client. All versions of the\n   * key will be downloaded. This operation requires the keys/backup permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * let backupContents = await client.backupKey(\"MyKey\");\n   * ```\n   * Backs up the specified key.\n   * @param name - The name of the key.\n   * @param options - The optional parameters.\n   */\n  backupKey(name, options = {}) {\n    return tracingClient.withSpan(`KeyClient.backupKey`, options, async updatedOptions => {\n      const response = await this.client.backupKey(this.vaultUrl, name, updatedOptions);\n      return response.value;\n    });\n  }\n  /**\n   * Restores a backed up key, and all its versions, to a vault. This operation requires the\n   * keys/restore permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * let backupContents = await client.backupKey(\"MyKey\");\n   * // ...\n   * let key = await client.restoreKeyBackup(backupContents);\n   * ```\n   * Restores a backed up key to a vault.\n   * @param backup - The backup blob associated with a key bundle.\n   * @param options - The optional parameters.\n   */\n  async restoreKeyBackup(backup, options = {}) {\n    return tracingClient.withSpan(`KeyClient.restoreKeyBackup`, options, async updatedOptions => {\n      const response = await this.client.restoreKey(this.vaultUrl, backup, updatedOptions);\n      return getKeyFromKeyBundle(response);\n    });\n  }\n  /**\n   * Gets the requested number of bytes containing random values from a managed HSM.\n   * This operation requires the managedHsm/rng permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(vaultUrl, credentials);\n   * let { bytes } = await client.getRandomBytes(10);\n   * ```\n   * @param count - The number of bytes to generate between 1 and 128 inclusive.\n   * @param options - The optional parameters.\n   */\n  getRandomBytes(count, options = {}) {\n    return tracingClient.withSpan(\"KeyClient.getRandomBytes\", options, async updatedOptions => {\n      const response = await this.client.getRandomBytes(this.vaultUrl, count, updatedOptions);\n      return response.value;\n    });\n  }\n  /**\n   * Rotates the key based on the key policy by generating a new version of the key. This operation requires the keys/rotate permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(vaultUrl, credentials);\n   * let key = await client.rotateKey(\"MyKey\");\n   * ```\n   *\n   * @param name - The name of the key to rotate.\n   * @param options - The optional parameters.\n   */\n  rotateKey(name, options = {}) {\n    return tracingClient.withSpan(\"KeyClient.rotateKey\", options, async updatedOptions => {\n      const key = await this.client.rotateKey(this.vaultUrl, name, updatedOptions);\n      return getKeyFromKeyBundle(key);\n    });\n  }\n  /**\n   * Releases a key from a managed HSM.\n   *\n   * The release key operation is applicable to all key types. The operation requires the key to be marked exportable and the keys/release permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(vaultUrl, credentials);\n   * let result = await client.releaseKey(\"myKey\", target)\n   * ```\n   *\n   * @param name - The name of the key.\n   * @param targetAttestationToken - The attestation assertion for the target of the key release.\n   * @param options - The optional parameters.\n   */\n  releaseKey(name, targetAttestationToken, options = {}) {\n    return tracingClient.withSpan(\"KeyClient.releaseKey\", options, async updatedOptions => {\n      const {\n          nonce,\n          algorithm\n        } = updatedOptions,\n        rest = __rest(updatedOptions, [\"nonce\", \"algorithm\"]);\n      const result = await this.client.release(this.vaultUrl, name, (options === null || options === void 0 ? void 0 : options.version) || \"\", targetAttestationToken, Object.assign({\n        enc: algorithm,\n        nonce\n      }, rest));\n      return {\n        value: result.value\n      };\n    });\n  }\n  /**\n   * Gets the rotation policy of a Key Vault Key.\n   * By default, all keys have a policy that will notify 30 days before expiry.\n   *\n   * This operation requires the keys/get permission.\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(vaultUrl, credentials);\n   * let result = await client.getKeyRotationPolicy(\"myKey\");\n   * ```\n   *\n   * @param keyName - The name of the key.\n   * @param options - The optional parameters.\n   */\n  getKeyRotationPolicy(keyName, options = {}) {\n    return tracingClient.withSpan(\"KeyClient.getKeyRotationPolicy\", options, async () => {\n      const policy = await this.client.getKeyRotationPolicy(this.vaultUrl, keyName);\n      return keyRotationTransformations.generatedToPublic(policy);\n    });\n  }\n  /**\n   * Updates the rotation policy of a Key Vault Key.\n   * This operation requires the keys/update permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(vaultUrl, credentials);\n   * const setPolicy = await client.updateKeyRotationPolicy(\"MyKey\", myPolicy);\n   * ```\n   *\n   * @param keyName - The name of the key.\n   * @param policyProperties - The {@link KeyRotationPolicyProperties} for the policy.\n   * @param options - The optional parameters.\n   */\n  updateKeyRotationPolicy(keyName, policy, options = {}) {\n    return tracingClient.withSpan(\"KeyClient.updateKeyRotationPolicy\", options, async updatedOptions => {\n      const result = await this.client.updateKeyRotationPolicy(this.vaultUrl, keyName, keyRotationTransformations.propertiesToGenerated(policy), updatedOptions);\n      return keyRotationTransformations.generatedToPublic(result);\n    });\n  }\n  /**\n   * Deals with the pagination of {@link listPropertiesOfKeyVersions}.\n   * @param name - The name of the Key Vault Key.\n   * @param continuationState - An object that indicates the position of the paginated request.\n   * @param options - Common options for the iterative endpoints.\n   */\n  listPropertiesOfKeyVersionsPage(name, continuationState, options) {\n    return __asyncGenerator(this, arguments, function* listPropertiesOfKeyVersionsPage_1() {\n      if (continuationState.continuationToken == null) {\n        const optionsComplete = Object.assign({\n          maxresults: continuationState.maxPageSize\n        }, options);\n        const currentSetResponse = yield __await(tracingClient.withSpan(\"KeyClient.listPropertiesOfKeyVersionsPage\", optionsComplete, async updatedOptions => this.client.getKeyVersions(this.vaultUrl, name, updatedOptions)));\n        continuationState.continuationToken = currentSetResponse.nextLink;\n        if (currentSetResponse.value) {\n          yield yield __await(currentSetResponse.value.map(getKeyPropertiesFromKeyItem, this));\n        }\n      }\n      while (continuationState.continuationToken) {\n        const currentSetResponse = yield __await(tracingClient.withSpan(\"KeyClient.listPropertiesOfKeyVersionsPage\", options || {}, async updatedOptions => this.client.getKeyVersionsNext(this.vaultUrl, name, continuationState.continuationToken, updatedOptions)));\n        continuationState.continuationToken = currentSetResponse.nextLink;\n        if (currentSetResponse.value) {\n          yield yield __await(currentSetResponse.value.map(getKeyPropertiesFromKeyItem, this));\n        } else {\n          break;\n        }\n      }\n    });\n  }\n  /**\n   * Deals with the iteration of all the available results of {@link listPropertiesOfKeyVersions}.\n   * @param name - The name of the Key Vault Key.\n   * @param options - Common options for the iterative endpoints.\n   */\n  listPropertiesOfKeyVersionsAll(name, options) {\n    return __asyncGenerator(this, arguments, function* listPropertiesOfKeyVersionsAll_1() {\n      var _a, e_1, _b, _c;\n      const f = {};\n      try {\n        for (var _d = true, _e = __asyncValues(this.listPropertiesOfKeyVersionsPage(name, f, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {\n          _c = _f.value;\n          _d = false;\n          const page = _c;\n          for (const item of page) {\n            yield yield __await(item);\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    });\n  }\n  /**\n   * Iterates all versions of the given key in the vault. The full key identifier, properties, and tags are provided\n   * in the response. This operation requires the keys/list permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * for await (const keyProperties of client.listPropertiesOfKeyVersions(\"MyKey\")) {\n   *   const key = await client.getKey(keyProperties.name);\n   *   console.log(\"key version: \", key);\n   * }\n   * ```\n   * @param name - Name of the key to fetch versions for\n   * @param options - The optional parameters.\n   */\n  listPropertiesOfKeyVersions(name, options = {}) {\n    const iter = this.listPropertiesOfKeyVersionsAll(name, options);\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings = {}) => this.listPropertiesOfKeyVersionsPage(name, settings, options)\n    };\n  }\n  /**\n   * Deals with the pagination of {@link listPropertiesOfKeys}.\n   * @param continuationState - An object that indicates the position of the paginated request.\n   * @param options - Common options for the iterative endpoints.\n   */\n  listPropertiesOfKeysPage(continuationState, options) {\n    return __asyncGenerator(this, arguments, function* listPropertiesOfKeysPage_1() {\n      if (continuationState.continuationToken == null) {\n        const optionsComplete = Object.assign({\n          maxresults: continuationState.maxPageSize\n        }, options);\n        const currentSetResponse = yield __await(tracingClient.withSpan(\"KeyClient.listPropertiesOfKeysPage\", optionsComplete, async updatedOptions => this.client.getKeys(this.vaultUrl, updatedOptions)));\n        continuationState.continuationToken = currentSetResponse.nextLink;\n        if (currentSetResponse.value) {\n          yield yield __await(currentSetResponse.value.map(getKeyPropertiesFromKeyItem, this));\n        }\n      }\n      while (continuationState.continuationToken) {\n        const currentSetResponse = yield __await(tracingClient.withSpan(\"KeyClient.listPropertiesOfKeysPage\", options || {}, async updatedOptions => this.client.getKeysNext(this.vaultUrl, continuationState.continuationToken, updatedOptions)));\n        continuationState.continuationToken = currentSetResponse.nextLink;\n        if (currentSetResponse.value) {\n          yield yield __await(currentSetResponse.value.map(getKeyPropertiesFromKeyItem, this));\n        } else {\n          break;\n        }\n      }\n    });\n  }\n  /**\n   * Deals with the iteration of all the available results of {@link listPropertiesOfKeys}.\n   * @param options - Common options for the iterative endpoints.\n   */\n  listPropertiesOfKeysAll(options) {\n    return __asyncGenerator(this, arguments, function* listPropertiesOfKeysAll_1() {\n      var _a, e_2, _b, _c;\n      const f = {};\n      try {\n        for (var _d = true, _e = __asyncValues(this.listPropertiesOfKeysPage(f, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {\n          _c = _f.value;\n          _d = false;\n          const page = _c;\n          for (const item of page) {\n            yield yield __await(item);\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    });\n  }\n  /**\n   * Iterates the latest version of all keys in the vault.  The full key identifier and properties are provided\n   * in the response. No values are returned for the keys. This operations requires the keys/list permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * for await (const keyProperties of client.listPropertiesOfKeys()) {\n   *   const key = await client.getKey(keyProperties.name);\n   *   console.log(\"key: \", key);\n   * }\n   * ```\n   * List all keys in the vault\n   * @param options - The optional parameters.\n   */\n  listPropertiesOfKeys(options = {}) {\n    const iter = this.listPropertiesOfKeysAll(options);\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings = {}) => this.listPropertiesOfKeysPage(settings, options)\n    };\n  }\n  /**\n   * Deals with the pagination of {@link listDeletedKeys}.\n   * @param continuationState - An object that indicates the position of the paginated request.\n   * @param options - Common options for the iterative endpoints.\n   */\n  listDeletedKeysPage(continuationState, options) {\n    return __asyncGenerator(this, arguments, function* listDeletedKeysPage_1() {\n      if (continuationState.continuationToken == null) {\n        const optionsComplete = Object.assign({\n          maxresults: continuationState.maxPageSize\n        }, options);\n        const currentSetResponse = yield __await(tracingClient.withSpan(\"KeyClient.listDeletedKeysPage\", optionsComplete, async updatedOptions => this.client.getDeletedKeys(this.vaultUrl, updatedOptions)));\n        continuationState.continuationToken = currentSetResponse.nextLink;\n        if (currentSetResponse.value) {\n          yield yield __await(currentSetResponse.value.map(getDeletedKeyFromDeletedKeyItem, this));\n        }\n      }\n      while (continuationState.continuationToken) {\n        const currentSetResponse = yield __await(tracingClient.withSpan(\"KeyClient.listDeletedKeysPage\", options || {}, async updatedOptions => this.client.getDeletedKeysNext(this.vaultUrl, continuationState.continuationToken, updatedOptions)));\n        continuationState.continuationToken = currentSetResponse.nextLink;\n        if (currentSetResponse.value) {\n          yield yield __await(currentSetResponse.value.map(getDeletedKeyFromDeletedKeyItem, this));\n        } else {\n          break;\n        }\n      }\n    });\n  }\n  /**\n   * Deals with the iteration of all the available results of {@link listDeletedKeys}.\n   * @param options - Common options for the iterative endpoints.\n   */\n  listDeletedKeysAll(options) {\n    return __asyncGenerator(this, arguments, function* listDeletedKeysAll_1() {\n      var _a, e_3, _b, _c;\n      const f = {};\n      try {\n        for (var _d = true, _e = __asyncValues(this.listDeletedKeysPage(f, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {\n          _c = _f.value;\n          _d = false;\n          const page = _c;\n          for (const item of page) {\n            yield yield __await(item);\n          }\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n    });\n  }\n  /**\n   * Iterates the deleted keys in the vault.  The full key identifier and properties are provided\n   * in the response. No values are returned for the keys. This operations requires the keys/list permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * for await (const deletedKey of client.listDeletedKeys()) {\n   *   console.log(\"deleted key: \", deletedKey);\n   * }\n   * ```\n   * List all keys in the vault\n   * @param options - The optional parameters.\n   */\n  listDeletedKeys(options = {}) {\n    const iter = this.listDeletedKeysAll(options);\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings = {}) => this.listDeletedKeysPage(settings, options)\n    };\n  }\n}","map":{"version":3,"names":["logger","KnownDeletionRecoveryLevel","KnownJsonWebKeyType","KeyVaultClient","SDK_VERSION","keyVaultAuthenticationPolicy","DeleteKeyPoller","RecoverDeletedKeyPoller","KnownKeyExportEncryptionAlgorithm","KnownKeyOperations","KnownKeyTypes","LATEST_API_VERSION","CryptographyClient","KnownEncryptionAlgorithms","KnownKeyCurveNames","KnownSignatureAlgorithms","parseKeyVaultKeyIdentifier","getDeletedKeyFromDeletedKeyItem","getKeyFromKeyBundle","getKeyPropertiesFromKeyItem","keyRotationTransformations","tracingClient","KeyClient","constructor","vaultUrl","credential","pipelineOptions","libInfo","userAgentOptions","userAgentPrefix","internalPipelineOptions","Object","assign","loggingOptions","info","allowedHeaderNames","client","serviceVersion","pipeline","addPolicy","afterPolicies","createKey","name","keyType","options","unflattenedOptions","enabled","notBefore","expiresOn","expires","exportable","remainingOptions","__rest","keyAttributes","withSpan","updatedOptions","response","createEcKey","hsm","ECHSM","EC","createRsaKey","RSAHSM","RSA","createOctKey","OctHSM","Oct","importKey","key","hardwareProtected","getCryptographyClient","keyName","keyUrl","URL","keyVersion","filter","Boolean","join","constructorOptions","generatedClient","cryptoClient","toString","beginDeleteKey","poller","intervalInMs","resumeFrom","operationOptions","poll","updateKeyProperties","args","disambiguateUpdateKeyPropertiesArgs","updateKey","getKey","version","getDeletedKey","purgeDeletedKey","beginRecoverDeletedKey","backupKey","value","restoreKeyBackup","backup","restoreKey","getRandomBytes","count","rotateKey","releaseKey","targetAttestationToken","nonce","algorithm","rest","result","release","enc","getKeyRotationPolicy","policy","generatedToPublic","updateKeyRotationPolicy","propertiesToGenerated","listPropertiesOfKeyVersionsPage","continuationState","continuationToken","optionsComplete","maxresults","maxPageSize","currentSetResponse","__await","getKeyVersions","nextLink","map","getKeyVersionsNext","listPropertiesOfKeyVersionsAll","f","_d","_e","__asyncValues","_f","next","_a","done","_c","page","item","listPropertiesOfKeyVersions","iter","Symbol","asyncIterator","byPage","settings","listPropertiesOfKeysPage","getKeys","getKeysNext","listPropertiesOfKeysAll","listPropertiesOfKeys","listDeletedKeysPage","getDeletedKeys","getDeletedKeysNext","listDeletedKeysAll","listDeletedKeys"],"sources":["/Users/eimis/test-server/Azure Hackthons/azure-cloud-architecture-game /node_modules/@azure/keyvault-keys/src/index.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/// <reference lib=\"esnext.asynciterable\" />\n\nimport { TokenCredential } from \"@azure/core-auth\";\n\nimport { logger } from \"./log.js\";\n\nimport { PageSettings, PagedAsyncIterableIterator } from \"@azure/core-paging\";\nimport { PollOperationState, PollerLike } from \"@azure/core-lro\";\n\nimport {\n  DeletionRecoveryLevel,\n  GetKeysOptionalParams,\n  KnownDeletionRecoveryLevel,\n  KnownJsonWebKeyType,\n} from \"./generated/models/index.js\";\nimport { KeyVaultClient } from \"./generated/keyVaultClient.js\";\nimport { SDK_VERSION } from \"./constants.js\";\nimport { keyVaultAuthenticationPolicy } from \"@azure/keyvault-common\";\n\nimport { DeleteKeyPoller } from \"./lro/delete/poller.js\";\nimport { RecoverDeletedKeyPoller } from \"./lro/recover/poller.js\";\n\nimport {\n  BackupKeyOptions,\n  BeginDeleteKeyOptions,\n  BeginRecoverDeletedKeyOptions,\n  CreateEcKeyOptions,\n  CreateKeyOptions,\n  CreateOctKeyOptions,\n  CreateRsaKeyOptions,\n  CryptographyClientOptions,\n  CryptographyOptions,\n  DeletedKey,\n  GetCryptographyClientOptions,\n  GetDeletedKeyOptions,\n  GetKeyOptions,\n  GetKeyRotationPolicyOptions,\n  GetRandomBytesOptions,\n  ImportKeyOptions,\n  JsonWebKey,\n  KeyClientOptions,\n  KeyExportEncryptionAlgorithm,\n  KeyOperation,\n  KeyPollerOptions,\n  KeyProperties,\n  KeyReleasePolicy,\n  KeyRotationLifetimeAction,\n  KeyRotationPolicy,\n  KeyRotationPolicyAction,\n  KeyRotationPolicyProperties,\n  KeyType,\n  KeyVaultKey,\n  KnownKeyExportEncryptionAlgorithm,\n  KnownKeyOperations,\n  KnownKeyTypes,\n  LATEST_API_VERSION,\n  ListDeletedKeysOptions,\n  ListPropertiesOfKeyVersionsOptions,\n  ListPropertiesOfKeysOptions,\n  PurgeDeletedKeyOptions,\n  ReleaseKeyOptions,\n  ReleaseKeyResult,\n  RestoreKeyBackupOptions,\n  RotateKeyOptions,\n  UpdateKeyPropertiesOptions,\n  UpdateKeyRotationPolicyOptions,\n} from \"./keysModels.js\";\n\nimport { CryptographyClient } from \"./cryptographyClient.js\";\n\nimport {\n  AesCbcDecryptParameters,\n  AesCbcEncryptParameters,\n  AesCbcEncryptionAlgorithm,\n  AesGcmDecryptParameters,\n  AesGcmEncryptParameters,\n  AesGcmEncryptionAlgorithm,\n  DecryptOptions,\n  DecryptParameters,\n  DecryptResult,\n  EncryptOptions,\n  EncryptParameters,\n  EncryptResult,\n  EncryptionAlgorithm,\n  KeyCurveName,\n  KeyWrapAlgorithm,\n  KnownEncryptionAlgorithms,\n  KnownKeyCurveNames,\n  KnownSignatureAlgorithms,\n  RsaDecryptParameters,\n  RsaEncryptParameters,\n  RsaEncryptionAlgorithm,\n  SignOptions,\n  SignResult,\n  SignatureAlgorithm,\n  UnwrapKeyOptions,\n  UnwrapResult,\n  VerifyDataOptions,\n  VerifyOptions,\n  VerifyResult,\n  WrapKeyOptions,\n  WrapResult,\n} from \"./cryptographyClientModels.js\";\n\nimport { KeyVaultKeyIdentifier, parseKeyVaultKeyIdentifier } from \"./identifier.js\";\nimport {\n  getDeletedKeyFromDeletedKeyItem,\n  getKeyFromKeyBundle,\n  getKeyPropertiesFromKeyItem,\n  keyRotationTransformations,\n} from \"./transformations.js\";\nimport { tracingClient } from \"./tracing.js\";\n\nexport {\n  CryptographyClientOptions,\n  KeyClientOptions,\n  BackupKeyOptions,\n  CreateEcKeyOptions,\n  CreateKeyOptions,\n  CreateRsaKeyOptions,\n  CreateOctKeyOptions,\n  CryptographyClient,\n  CryptographyOptions,\n  RsaEncryptionAlgorithm,\n  RsaDecryptParameters,\n  AesGcmEncryptionAlgorithm,\n  AesGcmDecryptParameters,\n  AesCbcEncryptionAlgorithm,\n  AesCbcDecryptParameters,\n  DecryptParameters,\n  DecryptOptions,\n  DecryptResult,\n  DeletedKey,\n  DeletionRecoveryLevel,\n  KnownDeletionRecoveryLevel,\n  RsaEncryptParameters,\n  AesGcmEncryptParameters,\n  AesCbcEncryptParameters,\n  EncryptParameters,\n  EncryptOptions,\n  EncryptResult,\n  GetDeletedKeyOptions,\n  GetKeyOptions,\n  GetRandomBytesOptions,\n  ImportKeyOptions,\n  JsonWebKey,\n  KeyCurveName,\n  KnownKeyCurveNames,\n  KnownKeyExportEncryptionAlgorithm,\n  EncryptionAlgorithm,\n  KnownEncryptionAlgorithms,\n  KeyOperation,\n  KnownKeyOperations,\n  KeyType,\n  KnownKeyTypes,\n  KeyPollerOptions,\n  BeginDeleteKeyOptions,\n  BeginRecoverDeletedKeyOptions,\n  KeyProperties,\n  SignatureAlgorithm,\n  KnownSignatureAlgorithms,\n  KeyVaultKey,\n  KeyWrapAlgorithm,\n  ListPropertiesOfKeysOptions,\n  ListPropertiesOfKeyVersionsOptions,\n  ListDeletedKeysOptions,\n  PageSettings,\n  PagedAsyncIterableIterator,\n  KeyVaultKeyIdentifier,\n  parseKeyVaultKeyIdentifier,\n  PollOperationState,\n  PollerLike,\n  PurgeDeletedKeyOptions,\n  RestoreKeyBackupOptions,\n  RotateKeyOptions,\n  SignOptions,\n  SignResult,\n  UnwrapKeyOptions,\n  UnwrapResult,\n  UpdateKeyPropertiesOptions,\n  VerifyOptions,\n  VerifyDataOptions,\n  VerifyResult,\n  WrapKeyOptions,\n  WrapResult,\n  ReleaseKeyOptions,\n  ReleaseKeyResult,\n  KeyReleasePolicy,\n  KeyExportEncryptionAlgorithm,\n  GetCryptographyClientOptions,\n  KeyRotationPolicyAction,\n  KeyRotationPolicyProperties,\n  KeyRotationPolicy,\n  KeyRotationLifetimeAction,\n  UpdateKeyRotationPolicyOptions,\n  GetKeyRotationPolicyOptions,\n  logger,\n};\n\n/**\n * The KeyClient provides methods to manage {@link KeyVaultKey} in the\n * Azure Key Vault. The client supports creating, retrieving, updating,\n * deleting, purging, backing up, restoring and listing KeyVaultKeys. The\n * client also supports listing {@link DeletedKey} for a soft-delete enabled Azure Key\n * Vault.\n */\nexport class KeyClient {\n  /**\n   * The base URL to the vault\n   */\n  public readonly vaultUrl: string;\n\n  /**\n   * A reference to the auto-generated Key Vault HTTP client.\n   */\n  private readonly client: KeyVaultClient;\n\n  /**\n   * A reference to the credential that was used to construct this client.\n   * Later used to instantiate a {@link CryptographyClient} with the same credential.\n   */\n  private readonly credential: TokenCredential;\n\n  /**\n   * Creates an instance of KeyClient.\n   *\n   * Example usage:\n   * ```ts\n   * import { KeyClient } from \"@azure/keyvault-keys\";\n   * import { DefaultAzureCredential } from \"@azure/identity\";\n   *\n   * let vaultUrl = `https://<MY KEYVAULT HERE>.vault.azure.net`;\n   * let credentials = new DefaultAzureCredential();\n   *\n   * let client = new KeyClient(vaultUrl, credentials);\n   * ```\n   * @param vaultUrl - the URL of the Key Vault. It should have this shape: `https://${your-key-vault-name}.vault.azure.net`. You should validate that this URL references a valid Key Vault or Managed HSM resource. See https://aka.ms/azsdk/blog/vault-uri for details.\n   * @param credential - An object that implements the `TokenCredential` interface used to authenticate requests to the service. Use the \\@azure/identity package to create a credential that suits your needs.\n   * @param pipelineOptions - Pipeline options used to configure Key Vault API requests. Omit this parameter to use the default pipeline configuration.\n   */\n  constructor(\n    vaultUrl: string,\n    credential: TokenCredential,\n    pipelineOptions: KeyClientOptions = {},\n  ) {\n    this.vaultUrl = vaultUrl;\n\n    const libInfo = `azsdk-js-keyvault-keys/${SDK_VERSION}`;\n\n    const userAgentOptions = pipelineOptions.userAgentOptions;\n\n    pipelineOptions.userAgentOptions = {\n      userAgentPrefix:\n        userAgentOptions && userAgentOptions.userAgentPrefix\n          ? `${userAgentOptions.userAgentPrefix} ${libInfo}`\n          : libInfo,\n    };\n\n    const internalPipelineOptions = {\n      ...pipelineOptions,\n      loggingOptions: {\n        logger: logger.info,\n        allowedHeaderNames: [\n          \"x-ms-keyvault-region\",\n          \"x-ms-keyvault-network-info\",\n          \"x-ms-keyvault-service-version\",\n        ],\n      },\n    };\n\n    this.credential = credential;\n    this.client = new KeyVaultClient(\n      pipelineOptions.serviceVersion || LATEST_API_VERSION,\n      internalPipelineOptions,\n    );\n\n    // The authentication policy must come after the deserialization policy since the deserialization policy\n    // converts 401 responses to an Error, and we don't want to deal with that.\n    this.client.pipeline.addPolicy(keyVaultAuthenticationPolicy(credential, pipelineOptions), {\n      afterPolicies: [\"deserializationPolicy\"],\n    });\n  }\n\n  /**\n   * The create key operation can be used to create any key type in Azure Key Vault. If the named key\n   * already exists, Azure Key Vault creates a new version of the key. It requires the keys/create\n   * permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * // Create an elliptic-curve key:\n   * let result = await client.createKey(\"MyKey\", \"EC\");\n   * ```\n   * Creates a new key, stores it, then returns key parameters and properties to the client.\n   * @param name - The name of the key.\n   * @param keyType - The type of the key. One of the following: 'EC', 'EC-HSM', 'RSA', 'RSA-HSM', 'oct'.\n   * @param options - The optional parameters.\n   */\n  public createKey(\n    name: string,\n    keyType: KeyType,\n    options?: CreateKeyOptions,\n  ): Promise<KeyVaultKey> {\n    let unflattenedOptions = {};\n\n    if (options) {\n      const { enabled, notBefore, expiresOn: expires, exportable, ...remainingOptions } = options;\n      unflattenedOptions = {\n        ...remainingOptions,\n        keyAttributes: {\n          enabled,\n          notBefore,\n          expires,\n          exportable,\n        },\n      };\n    }\n    return tracingClient.withSpan(\n      \"KeyClient.createKey\",\n      unflattenedOptions,\n      async (updatedOptions) => {\n        const response = await this.client.createKey(this.vaultUrl, name, keyType, updatedOptions);\n        return getKeyFromKeyBundle(response);\n      },\n    );\n  }\n\n  /**\n   * The createEcKey method creates a new elliptic curve key in Azure Key Vault. If the named key\n   * already exists, Azure Key Vault creates a new version of the key. It requires the keys/create\n   * permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * let result = await client.createEcKey(\"MyKey\", { curve: \"P-256\" });\n   * ```\n   * Creates a new key, stores it, then returns key parameters and properties to the client.\n   * @param name - The name of the key.\n   * @param options - The optional parameters.\n   */\n  public async createEcKey(name: string, options?: CreateEcKeyOptions): Promise<KeyVaultKey> {\n    const keyType = options?.hsm ? KnownJsonWebKeyType.ECHSM : KnownJsonWebKeyType.EC;\n    return this.createKey(name, keyType, options);\n  }\n\n  /**\n   * The createRSAKey method creates a new RSA key in Azure Key Vault. If the named key\n   * already exists, Azure Key Vault creates a new version of the key. It requires the keys/create\n   * permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * let result = await client.createRsaKey(\"MyKey\", { keySize: 2048 });\n   * ```\n   * Creates a new key, stores it, then returns key parameters and properties to the client.\n   * @param name - The name of the key.\n   * @param options - The optional parameters.\n   */\n  public async createRsaKey(name: string, options?: CreateRsaKeyOptions): Promise<KeyVaultKey> {\n    const keyType = options?.hsm ? KnownJsonWebKeyType.RSAHSM : KnownJsonWebKeyType.RSA;\n    return this.createKey(name, keyType, options);\n  }\n\n  /**\n   * The createOctKey method creates a new OCT key in Azure Key Vault. If the named key\n   * already exists, Azure Key Vault creates a new version of the key. It requires the keys/create\n   * permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * let result = await client.createOctKey(\"MyKey\", { hsm: true });\n   * ```\n   * Creates a new key, stores it, then returns key parameters and properties to the client.\n   * @param name - The name of the key.\n   * @param options - The optional parameters.\n   */\n  public async createOctKey(name: string, options?: CreateOctKeyOptions): Promise<KeyVaultKey> {\n    const keyType = options?.hsm ? KnownJsonWebKeyType.OctHSM : KnownJsonWebKeyType.Oct;\n    return this.createKey(name, keyType, options);\n  }\n\n  /**\n   * The import key operation may be used to import any key type into an Azure Key Vault. If the\n   * named key already exists, Azure Key Vault creates a new version of the key. This operation\n   * requires the keys/import permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * // Key contents in myKeyContents\n   * let result = await client.importKey(\"MyKey\", myKeyContents);\n   * ```\n   * Imports an externally created key, stores it, and returns key parameters and properties\n   * to the client.\n   * @param name - Name for the imported key.\n   * @param key - The JSON web key.\n   * @param options - The optional parameters.\n   */\n  public importKey(\n    name: string,\n    key: JsonWebKey,\n    options?: ImportKeyOptions,\n  ): Promise<KeyVaultKey> {\n    let unflattenedOptions = {};\n\n    if (options) {\n      const {\n        enabled,\n        notBefore,\n        exportable,\n        expiresOn: expires,\n        hardwareProtected: hsm,\n        ...remainingOptions\n      } = options;\n      unflattenedOptions = {\n        ...remainingOptions,\n        keyAttributes: {\n          enabled,\n          notBefore,\n          expires,\n          hsm,\n          exportable,\n        },\n      };\n    }\n\n    return tracingClient.withSpan(\n      `KeyClient.importKey`,\n      unflattenedOptions,\n      async (updatedOptions) => {\n        const response = await this.client.importKey(this.vaultUrl, name, key, updatedOptions);\n        return getKeyFromKeyBundle(response);\n      },\n    );\n  }\n\n  /**\n   * Gets a {@link CryptographyClient} for the given key.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * // get a cryptography client for a given key\n   * let cryptographyClient = client.getCryptographyClient(\"MyKey\");\n   * ```\n   * @param name - The name of the key used to perform cryptographic operations.\n   * @param version - Optional version of the key used to perform cryptographic operations.\n   * @returns - A {@link CryptographyClient} using the same options, credentials, and http client as this {@link KeyClient}\n   */\n  public getCryptographyClient(\n    keyName: string,\n    options?: GetCryptographyClientOptions,\n  ): CryptographyClient {\n    const keyUrl = new URL(\n      [\"keys\", keyName, options?.keyVersion].filter(Boolean).join(\"/\"),\n      this.vaultUrl,\n    );\n\n    // The goals of this method are discoverability and performance (by sharing a client and pipeline).\n    // The existing cryptography client does not accept a pipeline as an argument, nor does it expose it.\n    // In order to avoid publicly exposing the pipeline we will pass in the underlying client as an undocumented\n    // property to the constructor so that crypto providers downstream can use it.\n    const constructorOptions: CryptographyClientOptions & { generatedClient: KeyVaultClient } = {\n      generatedClient: this.client,\n    };\n    const cryptoClient = new CryptographyClient(\n      keyUrl.toString(),\n      this.credential,\n      constructorOptions,\n    );\n    return cryptoClient;\n  }\n\n  /**\n   * The delete operation applies to any key stored in Azure Key Vault. Individual versions\n   * of a key can not be deleted, only all versions of a given key at once.\n   *\n   * This function returns a Long Running Operation poller that allows you to wait indefinitely until the key is deleted.\n   *\n   * This operation requires the keys/delete permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new KeyClient(url, credentials);\n   * await client.createKey(\"MyKey\", \"EC\");\n   * const poller = await client.beginDeleteKey(\"MyKey\");\n   *\n   * // Serializing the poller\n   * const serialized = poller.toString();\n   * // A new poller can be created with:\n   * // await client.beginDeleteKey(\"MyKey\", { resumeFrom: serialized });\n   *\n   * // Waiting until it's done\n   * const deletedKey = await poller.pollUntilDone();\n   * console.log(deletedKey);\n   * ```\n   * Deletes a key from a specified key vault.\n   * @param name - The name of the key.\n   * @param options - The optional parameters.\n   */\n  public async beginDeleteKey(\n    name: string,\n    options: BeginDeleteKeyOptions = {},\n  ): Promise<PollerLike<PollOperationState<DeletedKey>, DeletedKey>> {\n    const poller = new DeleteKeyPoller({\n      name,\n      vaultUrl: this.vaultUrl,\n      client: this.client,\n      intervalInMs: options.intervalInMs,\n      resumeFrom: options.resumeFrom,\n      operationOptions: options,\n    });\n\n    // This will initialize the poller's operation (the deletion of the key).\n    await poller.poll();\n\n    return poller;\n  }\n\n  /**\n   * The updateKeyProperties method changes specified properties of an existing stored key. Properties that\n   * are not specified in the request are left unchanged. The value of a key itself cannot be\n   * changed. This operation requires the keys/set permission.\n   *\n   * Example usage:\n   * ```ts\n   * let keyName = \"MyKey\";\n   * let client = new KeyClient(vaultUrl, credentials);\n   * let key = await client.getKey(keyName);\n   * let result = await client.updateKeyProperties(keyName, key.properties.version, { enabled: false });\n   * ```\n   * Updates the properties associated with a specified key in a given key vault.\n   * @param name - The name of the key.\n   * @param keyVersion - The version of the key.\n   * @param options - The optional parameters.\n   */\n  public updateKeyProperties(\n    name: string,\n    keyVersion: string,\n    options?: UpdateKeyPropertiesOptions,\n  ): Promise<KeyVaultKey>;\n  /**\n   * The updateKeyProperties method changes specified properties of the latest version of an existing stored key. Properties that\n   * are not specified in the request are left unchanged. The value of a key itself cannot be\n   * changed. This operation requires the keys/set permission.\n   *\n   * Example usage:\n   * ```ts\n   * let keyName = \"MyKey\";\n   * let client = new KeyClient(vaultUrl, credentials);\n   * let key = await client.getKey(keyName);\n   * let result = await client.updateKeyProperties(keyName, { enabled: false });\n   * ```\n   * Updates the properties associated with a specified key in a given key vault.\n   * @param name - The name of the key.\n   * @param keyVersion - The version of the key.\n   * @param options - The optional parameters.\n   */\n  public updateKeyProperties(\n    name: string,\n    options?: UpdateKeyPropertiesOptions,\n  ): Promise<KeyVaultKey>;\n  public updateKeyProperties(\n    ...args: [string, string, UpdateKeyPropertiesOptions?] | [string, UpdateKeyPropertiesOptions?]\n  ): Promise<KeyVaultKey> {\n    const [name, keyVersion, options] = this.disambiguateUpdateKeyPropertiesArgs(args);\n    return tracingClient.withSpan(\n      `KeyClient.updateKeyProperties`,\n      options,\n      async (updatedOptions) => {\n        const { enabled, notBefore, expiresOn: expires, ...remainingOptions } = updatedOptions;\n        const unflattenedOptions = {\n          ...remainingOptions,\n          keyAttributes: {\n            enabled,\n            notBefore,\n            expires,\n          },\n        };\n        const response = await this.client.updateKey(\n          this.vaultUrl,\n          name,\n          keyVersion,\n          unflattenedOptions,\n        );\n        return getKeyFromKeyBundle(response);\n      },\n    );\n  }\n\n  /**\n   * Standardizes an overloaded arguments collection for the updateKeyProperties method.\n   *\n   * @param args - The arguments collection.\n   * @returns - The standardized arguments collection.\n   */\n  private disambiguateUpdateKeyPropertiesArgs(\n    args: [string, string, UpdateKeyPropertiesOptions?] | [string, UpdateKeyPropertiesOptions?],\n  ): [string, string, UpdateKeyPropertiesOptions] {\n    if (typeof args[1] === \"string\") {\n      // [name, keyVersion, options?] => [name, keyVersion, options || {}]\n      return [args[0], args[1], args[2] || {}];\n    } else {\n      // [name, options?] => [name , \"\", options || {}]\n      return [args[0], \"\", args[1] || {}];\n    }\n  }\n\n  /**\n   * The getKey method gets a specified key and is applicable to any key stored in Azure Key Vault.\n   * This operation requires the keys/get permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * let key = await client.getKey(\"MyKey\");\n   * ```\n   * Get a specified key from a given key vault.\n   * @param name - The name of the key.\n   * @param options - The optional parameters.\n   */\n  public getKey(name: string, options: GetKeyOptions = {}): Promise<KeyVaultKey> {\n    return tracingClient.withSpan(`KeyClient.getKey`, options, async (updatedOptions) => {\n      const response = await this.client.getKey(\n        this.vaultUrl,\n        name,\n        options && options.version ? options.version : \"\",\n        updatedOptions,\n      );\n      return getKeyFromKeyBundle(response);\n    });\n  }\n\n  /**\n   * The getDeletedKey method returns the specified deleted key along with its properties.\n   * This operation requires the keys/get permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * let key = await client.getDeletedKey(\"MyDeletedKey\");\n   * ```\n   * Gets the specified deleted key.\n   * @param name - The name of the key.\n   * @param options - The optional parameters.\n   */\n  public getDeletedKey(name: string, options: GetDeletedKeyOptions = {}): Promise<DeletedKey> {\n    return tracingClient.withSpan(`KeyClient.getDeletedKey`, options, async (updatedOptions) => {\n      const response = await this.client.getDeletedKey(this.vaultUrl, name, updatedOptions);\n      return getKeyFromKeyBundle(response);\n    });\n  }\n\n  /**\n   * The purge deleted key operation removes the key permanently, without the possibility of\n   * recovery. This operation can only be enabled on a soft-delete enabled vault. This operation\n   * requires the keys/purge permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new KeyClient(url, credentials);\n   * const deletePoller = await client.beginDeleteKey(\"MyKey\")\n   * await deletePoller.pollUntilDone();\n   * await client.purgeDeletedKey(\"MyKey\");\n   * ```\n   * Permanently deletes the specified key.\n   * @param name - The name of the key.\n   * @param options - The optional parameters.\n   */\n  public purgeDeletedKey(name: string, options: PurgeDeletedKeyOptions = {}): Promise<void> {\n    return tracingClient.withSpan(`KeyClient.purgeDeletedKey`, options, async (updatedOptions) => {\n      await this.client.purgeDeletedKey(this.vaultUrl, name, updatedOptions);\n    });\n  }\n\n  /**\n   * Recovers the deleted key in the specified vault. This operation can only be performed on a\n   * soft-delete enabled vault.\n   *\n   * This function returns a Long Running Operation poller that allows you to wait indefinitely until the deleted key is recovered.\n   *\n   * This operation requires the keys/recover permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new KeyClient(url, credentials);\n   * await client.createKey(\"MyKey\", \"EC\");\n   * const deletePoller = await client.beginDeleteKey(\"MyKey\");\n   * await deletePoller.pollUntilDone();\n   * const poller = await client.beginRecoverDeletedKey(\"MyKey\");\n   *\n   * // Serializing the poller\n   * const serialized = poller.toString();\n   * // A new poller can be created with:\n   * // await client.beginRecoverDeletedKey(\"MyKey\", { resumeFrom: serialized });\n   *\n   * // Waiting until it's done\n   * const key = await poller.pollUntilDone();\n   * console.log(key);\n   * ```\n   * Recovers the deleted key to the latest version.\n   * @param name - The name of the deleted key.\n   * @param options - The optional parameters.\n   */\n  public async beginRecoverDeletedKey(\n    name: string,\n    options: BeginRecoverDeletedKeyOptions = {},\n  ): Promise<PollerLike<PollOperationState<DeletedKey>, DeletedKey>> {\n    const poller = new RecoverDeletedKeyPoller({\n      name,\n      vaultUrl: this.vaultUrl,\n      client: this.client,\n      intervalInMs: options.intervalInMs,\n      resumeFrom: options.resumeFrom,\n      operationOptions: options,\n    });\n    // This will initialize the poller's operation (the deletion of the key).\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Requests that a backup of the specified key be downloaded to the client. All versions of the\n   * key will be downloaded. This operation requires the keys/backup permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * let backupContents = await client.backupKey(\"MyKey\");\n   * ```\n   * Backs up the specified key.\n   * @param name - The name of the key.\n   * @param options - The optional parameters.\n   */\n  public backupKey(name: string, options: BackupKeyOptions = {}): Promise<Uint8Array | undefined> {\n    return tracingClient.withSpan(`KeyClient.backupKey`, options, async (updatedOptions) => {\n      const response = await this.client.backupKey(this.vaultUrl, name, updatedOptions);\n      return response.value;\n    });\n  }\n\n  /**\n   * Restores a backed up key, and all its versions, to a vault. This operation requires the\n   * keys/restore permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * let backupContents = await client.backupKey(\"MyKey\");\n   * // ...\n   * let key = await client.restoreKeyBackup(backupContents);\n   * ```\n   * Restores a backed up key to a vault.\n   * @param backup - The backup blob associated with a key bundle.\n   * @param options - The optional parameters.\n   */\n  public async restoreKeyBackup(\n    backup: Uint8Array,\n    options: RestoreKeyBackupOptions = {},\n  ): Promise<KeyVaultKey> {\n    return tracingClient.withSpan(`KeyClient.restoreKeyBackup`, options, async (updatedOptions) => {\n      const response = await this.client.restoreKey(this.vaultUrl, backup, updatedOptions);\n      return getKeyFromKeyBundle(response);\n    });\n  }\n\n  /**\n   * Gets the requested number of bytes containing random values from a managed HSM.\n   * This operation requires the managedHsm/rng permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(vaultUrl, credentials);\n   * let { bytes } = await client.getRandomBytes(10);\n   * ```\n   * @param count - The number of bytes to generate between 1 and 128 inclusive.\n   * @param options - The optional parameters.\n   */\n  public getRandomBytes(count: number, options: GetRandomBytesOptions = {}): Promise<Uint8Array> {\n    return tracingClient.withSpan(\"KeyClient.getRandomBytes\", options, async (updatedOptions) => {\n      const response = await this.client.getRandomBytes(this.vaultUrl, count, updatedOptions);\n      return response.value!;\n    });\n  }\n\n  /**\n   * Rotates the key based on the key policy by generating a new version of the key. This operation requires the keys/rotate permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(vaultUrl, credentials);\n   * let key = await client.rotateKey(\"MyKey\");\n   * ```\n   *\n   * @param name - The name of the key to rotate.\n   * @param options - The optional parameters.\n   */\n  public rotateKey(name: string, options: RotateKeyOptions = {}): Promise<KeyVaultKey> {\n    return tracingClient.withSpan(\"KeyClient.rotateKey\", options, async (updatedOptions) => {\n      const key = await this.client.rotateKey(this.vaultUrl, name, updatedOptions);\n      return getKeyFromKeyBundle(key);\n    });\n  }\n\n  /**\n   * Releases a key from a managed HSM.\n   *\n   * The release key operation is applicable to all key types. The operation requires the key to be marked exportable and the keys/release permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(vaultUrl, credentials);\n   * let result = await client.releaseKey(\"myKey\", target)\n   * ```\n   *\n   * @param name - The name of the key.\n   * @param targetAttestationToken - The attestation assertion for the target of the key release.\n   * @param options - The optional parameters.\n   */\n  public releaseKey(\n    name: string,\n    targetAttestationToken: string,\n    options: ReleaseKeyOptions = {},\n  ): Promise<ReleaseKeyResult> {\n    return tracingClient.withSpan(\"KeyClient.releaseKey\", options, async (updatedOptions) => {\n      const { nonce, algorithm, ...rest } = updatedOptions;\n      const result = await this.client.release(\n        this.vaultUrl,\n        name,\n        options?.version || \"\",\n        targetAttestationToken,\n        {\n          enc: algorithm,\n          nonce,\n          ...rest,\n        },\n      );\n\n      return { value: result.value! };\n    });\n  }\n\n  /**\n   * Gets the rotation policy of a Key Vault Key.\n   * By default, all keys have a policy that will notify 30 days before expiry.\n   *\n   * This operation requires the keys/get permission.\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(vaultUrl, credentials);\n   * let result = await client.getKeyRotationPolicy(\"myKey\");\n   * ```\n   *\n   * @param keyName - The name of the key.\n   * @param options - The optional parameters.\n   */\n  public getKeyRotationPolicy(\n    keyName: string,\n    options: GetKeyRotationPolicyOptions = {},\n  ): Promise<KeyRotationPolicy> {\n    return tracingClient.withSpan(\"KeyClient.getKeyRotationPolicy\", options, async () => {\n      const policy = await this.client.getKeyRotationPolicy(this.vaultUrl, keyName);\n      return keyRotationTransformations.generatedToPublic(policy);\n    });\n  }\n\n  /**\n   * Updates the rotation policy of a Key Vault Key.\n   * This operation requires the keys/update permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(vaultUrl, credentials);\n   * const setPolicy = await client.updateKeyRotationPolicy(\"MyKey\", myPolicy);\n   * ```\n   *\n   * @param keyName - The name of the key.\n   * @param policyProperties - The {@link KeyRotationPolicyProperties} for the policy.\n   * @param options - The optional parameters.\n   */\n  public updateKeyRotationPolicy(\n    keyName: string,\n    policy: KeyRotationPolicyProperties,\n    options: UpdateKeyRotationPolicyOptions = {},\n  ): Promise<KeyRotationPolicy> {\n    return tracingClient.withSpan(\n      \"KeyClient.updateKeyRotationPolicy\",\n      options,\n      async (updatedOptions) => {\n        const result = await this.client.updateKeyRotationPolicy(\n          this.vaultUrl,\n          keyName,\n          keyRotationTransformations.propertiesToGenerated(policy),\n          updatedOptions,\n        );\n        return keyRotationTransformations.generatedToPublic(result);\n      },\n    );\n  }\n\n  /**\n   * Deals with the pagination of {@link listPropertiesOfKeyVersions}.\n   * @param name - The name of the Key Vault Key.\n   * @param continuationState - An object that indicates the position of the paginated request.\n   * @param options - Common options for the iterative endpoints.\n   */\n  private async *listPropertiesOfKeyVersionsPage(\n    name: string,\n    continuationState: PageSettings,\n    options?: ListPropertiesOfKeyVersionsOptions,\n  ): AsyncIterableIterator<KeyProperties[]> {\n    if (continuationState.continuationToken == null) {\n      const optionsComplete: GetKeysOptionalParams = {\n        maxresults: continuationState.maxPageSize,\n        ...options,\n      };\n      const currentSetResponse = await tracingClient.withSpan(\n        \"KeyClient.listPropertiesOfKeyVersionsPage\",\n        optionsComplete,\n        async (updatedOptions) => this.client.getKeyVersions(this.vaultUrl, name, updatedOptions),\n      );\n\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(getKeyPropertiesFromKeyItem, this);\n      }\n    }\n    while (continuationState.continuationToken) {\n      const currentSetResponse = await tracingClient.withSpan(\n        \"KeyClient.listPropertiesOfKeyVersionsPage\",\n        options || {},\n        async (updatedOptions) =>\n          this.client.getKeyVersionsNext(\n            this.vaultUrl,\n            name,\n            continuationState.continuationToken!,\n            updatedOptions,\n          ),\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(getKeyPropertiesFromKeyItem, this);\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\n   * Deals with the iteration of all the available results of {@link listPropertiesOfKeyVersions}.\n   * @param name - The name of the Key Vault Key.\n   * @param options - Common options for the iterative endpoints.\n   */\n  private async *listPropertiesOfKeyVersionsAll(\n    name: string,\n    options?: ListPropertiesOfKeyVersionsOptions,\n  ): AsyncIterableIterator<KeyProperties> {\n    const f = {};\n\n    for await (const page of this.listPropertiesOfKeyVersionsPage(name, f, options)) {\n      for (const item of page) {\n        yield item;\n      }\n    }\n  }\n\n  /**\n   * Iterates all versions of the given key in the vault. The full key identifier, properties, and tags are provided\n   * in the response. This operation requires the keys/list permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * for await (const keyProperties of client.listPropertiesOfKeyVersions(\"MyKey\")) {\n   *   const key = await client.getKey(keyProperties.name);\n   *   console.log(\"key version: \", key);\n   * }\n   * ```\n   * @param name - Name of the key to fetch versions for\n   * @param options - The optional parameters.\n   */\n  public listPropertiesOfKeyVersions(\n    name: string,\n    options: ListPropertiesOfKeyVersionsOptions = {},\n  ): PagedAsyncIterableIterator<KeyProperties> {\n    const iter = this.listPropertiesOfKeyVersionsAll(name, options);\n\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings: PageSettings = {}) =>\n        this.listPropertiesOfKeyVersionsPage(name, settings, options),\n    };\n  }\n\n  /**\n   * Deals with the pagination of {@link listPropertiesOfKeys}.\n   * @param continuationState - An object that indicates the position of the paginated request.\n   * @param options - Common options for the iterative endpoints.\n   */\n  private async *listPropertiesOfKeysPage(\n    continuationState: PageSettings,\n    options?: ListPropertiesOfKeysOptions,\n  ): AsyncIterableIterator<KeyProperties[]> {\n    if (continuationState.continuationToken == null) {\n      const optionsComplete: GetKeysOptionalParams = {\n        maxresults: continuationState.maxPageSize,\n        ...options,\n      };\n      const currentSetResponse = await tracingClient.withSpan(\n        \"KeyClient.listPropertiesOfKeysPage\",\n        optionsComplete,\n        async (updatedOptions) => this.client.getKeys(this.vaultUrl, updatedOptions),\n      );\n\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(getKeyPropertiesFromKeyItem, this);\n      }\n    }\n    while (continuationState.continuationToken) {\n      const currentSetResponse = await tracingClient.withSpan(\n        \"KeyClient.listPropertiesOfKeysPage\",\n        options || {},\n        async (updatedOptions) =>\n          this.client.getKeysNext(\n            this.vaultUrl,\n            continuationState.continuationToken!,\n            updatedOptions,\n          ),\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(getKeyPropertiesFromKeyItem, this);\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\n   * Deals with the iteration of all the available results of {@link listPropertiesOfKeys}.\n   * @param options - Common options for the iterative endpoints.\n   */\n  private async *listPropertiesOfKeysAll(\n    options?: ListPropertiesOfKeysOptions,\n  ): AsyncIterableIterator<KeyProperties> {\n    const f = {};\n\n    for await (const page of this.listPropertiesOfKeysPage(f, options)) {\n      for (const item of page) {\n        yield item;\n      }\n    }\n  }\n\n  /**\n   * Iterates the latest version of all keys in the vault.  The full key identifier and properties are provided\n   * in the response. No values are returned for the keys. This operations requires the keys/list permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * for await (const keyProperties of client.listPropertiesOfKeys()) {\n   *   const key = await client.getKey(keyProperties.name);\n   *   console.log(\"key: \", key);\n   * }\n   * ```\n   * List all keys in the vault\n   * @param options - The optional parameters.\n   */\n  public listPropertiesOfKeys(\n    options: ListPropertiesOfKeysOptions = {},\n  ): PagedAsyncIterableIterator<KeyProperties> {\n    const iter = this.listPropertiesOfKeysAll(options);\n\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings: PageSettings = {}) => this.listPropertiesOfKeysPage(settings, options),\n    };\n  }\n\n  /**\n   * Deals with the pagination of {@link listDeletedKeys}.\n   * @param continuationState - An object that indicates the position of the paginated request.\n   * @param options - Common options for the iterative endpoints.\n   */\n  private async *listDeletedKeysPage(\n    continuationState: PageSettings,\n    options?: ListDeletedKeysOptions,\n  ): AsyncIterableIterator<DeletedKey[]> {\n    if (continuationState.continuationToken == null) {\n      const optionsComplete: GetKeysOptionalParams = {\n        maxresults: continuationState.maxPageSize,\n        ...options,\n      };\n      const currentSetResponse = await tracingClient.withSpan(\n        \"KeyClient.listDeletedKeysPage\",\n        optionsComplete,\n        async (updatedOptions) => this.client.getDeletedKeys(this.vaultUrl, updatedOptions),\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(getDeletedKeyFromDeletedKeyItem, this);\n      }\n    }\n    while (continuationState.continuationToken) {\n      const currentSetResponse = await tracingClient.withSpan(\n        \"KeyClient.listDeletedKeysPage\",\n        options || {},\n        async (updatedOptions) =>\n          this.client.getDeletedKeysNext(\n            this.vaultUrl,\n            continuationState.continuationToken!,\n            updatedOptions,\n          ),\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(getDeletedKeyFromDeletedKeyItem, this);\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\n   * Deals with the iteration of all the available results of {@link listDeletedKeys}.\n   * @param options - Common options for the iterative endpoints.\n   */\n  private async *listDeletedKeysAll(\n    options?: ListDeletedKeysOptions,\n  ): AsyncIterableIterator<DeletedKey> {\n    const f = {};\n\n    for await (const page of this.listDeletedKeysPage(f, options)) {\n      for (const item of page) {\n        yield item;\n      }\n    }\n  }\n\n  /**\n   * Iterates the deleted keys in the vault.  The full key identifier and properties are provided\n   * in the response. No values are returned for the keys. This operations requires the keys/list permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * for await (const deletedKey of client.listDeletedKeys()) {\n   *   console.log(\"deleted key: \", deletedKey);\n   * }\n   * ```\n   * List all keys in the vault\n   * @param options - The optional parameters.\n   */\n  public listDeletedKeys(\n    options: ListDeletedKeysOptions = {},\n  ): PagedAsyncIterableIterator<DeletedKey> {\n    const iter = this.listDeletedKeysAll(options);\n\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings: PageSettings = {}) => this.listDeletedKeysPage(settings, options),\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}