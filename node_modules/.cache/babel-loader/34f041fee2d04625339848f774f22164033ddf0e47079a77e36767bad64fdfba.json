{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { Constants } from \"../common/constants\";\n/**\n * This class implements the resource throttle retry policy for requests.\n * @hidden\n */\nexport class ResourceThrottleRetryPolicy {\n  constructor(options) {\n    var _a, _b, _c;\n    /** Current retry attempt count. */\n    this.currentRetryAttemptCount = 0;\n    /** Cummulative wait time in milliseconds for a request while the retries are happening. */\n    this.cummulativeWaitTimeinMs = 0;\n    /** Retry interval in milliseconds to wait before the next request will be sent. */\n    this.retryAfterInMs = 0;\n    this.maxTries = (_a = options.maxRetryAttemptCount) !== null && _a !== void 0 ? _a : Constants.ThrottledRequestMaxRetryAttemptCount;\n    this.fixedRetryIntervalInMs = (_b = options.fixedRetryIntervalInMilliseconds) !== null && _b !== void 0 ? _b : Constants.ThrottledRequestFixedRetryIntervalInMs;\n    const timeoutInSeconds = (_c = options.maxWaitTimeInSeconds) !== null && _c !== void 0 ? _c : Constants.ThrottledRequestMaxWaitTimeInSeconds;\n    this.timeoutInMs = timeoutInSeconds * 1000;\n    this.currentRetryAttemptCount = 0;\n    this.cummulativeWaitTimeinMs = 0;\n  }\n  /**\n   * Determines whether the request should be retried or not.\n   * @param err - Error returned by the request.\n   */\n  async shouldRetry(err, diagnosticNode) {\n    // TODO: any custom error object\n    if (err) {\n      if (this.currentRetryAttemptCount < this.maxTries) {\n        this.currentRetryAttemptCount++;\n        this.retryAfterInMs = 0;\n        if (this.fixedRetryIntervalInMs) {\n          this.retryAfterInMs = this.fixedRetryIntervalInMs;\n        } else if (err.retryAfterInMs) {\n          this.retryAfterInMs = err.retryAfterInMs;\n        }\n        if (this.cummulativeWaitTimeinMs < this.timeoutInMs) {\n          this.cummulativeWaitTimeinMs += this.retryAfterInMs;\n          diagnosticNode.addData({\n            successfulRetryPolicy: \"resourceThrottle\"\n          });\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n}","map":{"version":3,"names":["Constants","ResourceThrottleRetryPolicy","constructor","options","currentRetryAttemptCount","cummulativeWaitTimeinMs","retryAfterInMs","maxTries","_a","maxRetryAttemptCount","ThrottledRequestMaxRetryAttemptCount","fixedRetryIntervalInMs","_b","fixedRetryIntervalInMilliseconds","ThrottledRequestFixedRetryIntervalInMs","timeoutInSeconds","_c","maxWaitTimeInSeconds","ThrottledRequestMaxWaitTimeInSeconds","timeoutInMs","shouldRetry","err","diagnosticNode","addData","successfulRetryPolicy"],"sources":["/Users/eimis/test-server/Azure Hackthons/azure-cloud-architecture-game /node_modules/@azure/cosmos/src/retry/resourceThrottleRetryPolicy.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { Constants } from \"../common/constants\";\nimport type { DiagnosticNodeInternal } from \"../diagnostics/DiagnosticNodeInternal\";\nimport type { ErrorResponse } from \"../request\";\nimport type { RetryOptions } from \"./retryOptions\";\n\n/**\n * This class implements the resource throttle retry policy for requests.\n * @hidden\n */\nexport class ResourceThrottleRetryPolicy {\n  /** Current retry attempt count. */\n  public currentRetryAttemptCount: number = 0;\n  /** Cummulative wait time in milliseconds for a request while the retries are happening. */\n  public cummulativeWaitTimeinMs: number = 0;\n  /** Retry interval in milliseconds to wait before the next request will be sent. */\n  public retryAfterInMs: number = 0;\n\n  /** Max wait time in milliseconds to wait for a request while the retries are happening. */\n  private timeoutInMs: number;\n  /**\n   * @param maxTries - Max number of retries to be performed for a request.\n   * @param fixedRetryIntervalInMs - Fixed retry interval in milliseconds to wait between each\n   * retry ignoring the retryAfter returned as part of the response.\n   * @param timeoutInSeconds - Max wait time in seconds to wait for a request while the\n   * retries are happening.\n   */\n\n  private maxTries: number;\n  private fixedRetryIntervalInMs: number;\n  constructor(options: RetryOptions) {\n    this.maxTries = options.maxRetryAttemptCount ?? Constants.ThrottledRequestMaxRetryAttemptCount;\n    this.fixedRetryIntervalInMs =\n      options.fixedRetryIntervalInMilliseconds ?? Constants.ThrottledRequestFixedRetryIntervalInMs;\n    const timeoutInSeconds =\n      options.maxWaitTimeInSeconds ?? Constants.ThrottledRequestMaxWaitTimeInSeconds;\n    this.timeoutInMs = timeoutInSeconds * 1000;\n    this.currentRetryAttemptCount = 0;\n    this.cummulativeWaitTimeinMs = 0;\n  }\n  /**\n   * Determines whether the request should be retried or not.\n   * @param err - Error returned by the request.\n   */\n  public async shouldRetry(\n    err: ErrorResponse,\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<boolean> {\n    // TODO: any custom error object\n    if (err) {\n      if (this.currentRetryAttemptCount < this.maxTries) {\n        this.currentRetryAttemptCount++;\n        this.retryAfterInMs = 0;\n\n        if (this.fixedRetryIntervalInMs) {\n          this.retryAfterInMs = this.fixedRetryIntervalInMs;\n        } else if (err.retryAfterInMs) {\n          this.retryAfterInMs = err.retryAfterInMs;\n        }\n\n        if (this.cummulativeWaitTimeinMs < this.timeoutInMs) {\n          this.cummulativeWaitTimeinMs += this.retryAfterInMs;\n          diagnosticNode.addData({ successfulRetryPolicy: \"resourceThrottle\" });\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n}\n"],"mappings":"AAAA;AACA;AACA,SAASA,SAAS,QAAQ,qBAAqB;AAK/C;;;;AAIA,OAAM,MAAOC,2BAA2B;EAoBtCC,YAAYC,OAAqB;;IAnBjC;IACO,KAAAC,wBAAwB,GAAW,CAAC;IAC3C;IACO,KAAAC,uBAAuB,GAAW,CAAC;IAC1C;IACO,KAAAC,cAAc,GAAW,CAAC;IAe/B,IAAI,CAACC,QAAQ,GAAG,CAAAC,EAAA,GAAAL,OAAO,CAACM,oBAAoB,cAAAD,EAAA,cAAAA,EAAA,GAAIR,SAAS,CAACU,oCAAoC;IAC9F,IAAI,CAACC,sBAAsB,GACzB,CAAAC,EAAA,GAAAT,OAAO,CAACU,gCAAgC,cAAAD,EAAA,cAAAA,EAAA,GAAIZ,SAAS,CAACc,sCAAsC;IAC9F,MAAMC,gBAAgB,GACpB,CAAAC,EAAA,GAAAb,OAAO,CAACc,oBAAoB,cAAAD,EAAA,cAAAA,EAAA,GAAIhB,SAAS,CAACkB,oCAAoC;IAChF,IAAI,CAACC,WAAW,GAAGJ,gBAAgB,GAAG,IAAI;IAC1C,IAAI,CAACX,wBAAwB,GAAG,CAAC;IACjC,IAAI,CAACC,uBAAuB,GAAG,CAAC;EAClC;EACA;;;;EAIO,MAAMe,WAAWA,CACtBC,GAAkB,EAClBC,cAAsC;IAEtC;IACA,IAAID,GAAG,EAAE;MACP,IAAI,IAAI,CAACjB,wBAAwB,GAAG,IAAI,CAACG,QAAQ,EAAE;QACjD,IAAI,CAACH,wBAAwB,EAAE;QAC/B,IAAI,CAACE,cAAc,GAAG,CAAC;QAEvB,IAAI,IAAI,CAACK,sBAAsB,EAAE;UAC/B,IAAI,CAACL,cAAc,GAAG,IAAI,CAACK,sBAAsB;QACnD,CAAC,MAAM,IAAIU,GAAG,CAACf,cAAc,EAAE;UAC7B,IAAI,CAACA,cAAc,GAAGe,GAAG,CAACf,cAAc;QAC1C;QAEA,IAAI,IAAI,CAACD,uBAAuB,GAAG,IAAI,CAACc,WAAW,EAAE;UACnD,IAAI,CAACd,uBAAuB,IAAI,IAAI,CAACC,cAAc;UACnDgB,cAAc,CAACC,OAAO,CAAC;YAAEC,qBAAqB,EAAE;UAAkB,CAAE,CAAC;UACrE,OAAO,IAAI;QACb;MACF;IACF;IACA,OAAO,KAAK;EACd","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}