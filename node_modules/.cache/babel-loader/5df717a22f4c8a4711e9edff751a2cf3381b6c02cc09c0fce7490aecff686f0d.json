{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { KeyClient } from \"@azure/keyvault-keys\";\nimport { ErrorResponse } from \"../../request\";\nimport { EncryptionKeyResolverName } from \"../enums\";\n/**\n * Implementation of EncryptionKeyResolver that uses Azure Key Vault for customer managed keys.\n */\nexport class AzureKeyVaultEncryptionKeyResolver {\n  constructor(credentials) {\n    /**\n     * Name of the resolver to use for client side encryption.\n     * Currently only AzureKeyVault implementation is supported.\n     */\n    this.encryptionKeyResolverName = EncryptionKeyResolverName.AzureKeyVault;\n    this.credentials = credentials;\n  }\n  /**\n   * wraps the given key using the specified key encryption key path and algorithm.\n   * @param encryptionKeyId - path to the customer managed key to be used for wrapping. For Azure Key Vault, this is url of the key in the vault.\n   * @param algorithm - algorithm to be used for wrapping.\n   * @param unwrappedKey - dek to be wrapped.\n   * @returns wrapped DEK.\n   */\n  async wrapKey(encryptionKeyId, algorithm, unwrappedKey) {\n    try {\n      const origin = this.getOrigin(encryptionKeyId);\n      const keyClient = new KeyClient(origin, this.credentials);\n      const [keyName, keyVersion] = this.getKeyDetails(encryptionKeyId);\n      const cryptographyClient = keyClient.getCryptographyClient(keyName, {\n        keyVersion: keyVersion\n      });\n      const res = await cryptographyClient.wrapKey(algorithm, unwrappedKey);\n      if (!res || !res.result) {\n        throw new ErrorResponse(`Failed to wrap key: ${res}`);\n      }\n      return res.result;\n    } catch (e) {\n      throw new ErrorResponse(`Failed to wrap key: ${e.message}`);\n    }\n  }\n  /**\n   * Unwraps the given wrapped key using the specified key encryption key path and algorithm.\n   * @param encryptionKeyId - path to the customer managed key to be used for unwrapping. For Azure Key Vault, this is url of the key in the vault.\n   * @param algorithm - algorithm to be used for unwrapping.\n   * @param wrappedKey - wrapped DEK.\n   * @returns unwrapped DEK.\n   */\n  async unwrapKey(encryptionKeyId, algorithm, wrappedKey) {\n    try {\n      const origin = this.getOrigin(encryptionKeyId);\n      const keyClient = new KeyClient(origin, this.credentials);\n      const [keyName, keyVersion] = this.getKeyDetails(encryptionKeyId);\n      const cryptographyClient = keyClient.getCryptographyClient(keyName, {\n        keyVersion: keyVersion\n      });\n      const res = await cryptographyClient.unwrapKey(algorithm, wrappedKey);\n      if (!res || !res.result) {\n        throw new ErrorResponse(`Failed to wrap key: ${res}`);\n      }\n      return res.result;\n    } catch (e) {\n      throw new ErrorResponse(`Failed to unwrap key: ${e.message}`);\n    }\n  }\n  // TODO: improve this method to extract key name and version from the url\n  getKeyDetails(encryptionKeyId) {\n    let url;\n    try {\n      url = new URL(encryptionKeyId);\n      const parts = url.pathname.split(\"/\");\n      if (parts.length < 4 || parts.length > 5) {\n        throw new ErrorResponse(`Invalid key url: ${encryptionKeyId}. Key url must be in the format https://<vault>.vault.azure.net/keys/<key-name>/<key-version>`);\n      }\n      if (parts.length === 4 || parts.length === 5) {\n        return [parts[2], parts[3]];\n      }\n    } catch (e) {\n      throw new ErrorResponse(`Invalid key url: ${encryptionKeyId}. Key url must be in the format https://<vault>.vault.azure.net/keys/<key-name>/<key-version>. Error: ${e.message}`);\n    }\n  }\n  getOrigin(encryptionKeyId) {\n    try {\n      const url = new URL(encryptionKeyId);\n      return url.origin;\n    } catch (e) {\n      throw new ErrorResponse(`Invalid key url: ${encryptionKeyId}. Key url must be in the format https://<vault>.vault.azure.net/keys/<key-name>/<key-version>. Error: ${e.message}`);\n    }\n  }\n}","map":{"version":3,"names":["KeyClient","ErrorResponse","EncryptionKeyResolverName","AzureKeyVaultEncryptionKeyResolver","constructor","credentials","encryptionKeyResolverName","AzureKeyVault","wrapKey","encryptionKeyId","algorithm","unwrappedKey","origin","getOrigin","keyClient","keyName","keyVersion","getKeyDetails","cryptographyClient","getCryptographyClient","res","result","e","message","unwrapKey","wrappedKey","url","URL","parts","pathname","split","length"],"sources":["/Users/eimis/test-server/Azure Hackthons/azure-cloud-architecture-game /node_modules/@azure/cosmos/src/encryption/EncryptionKeyResolver/AzureKeyVaultEncryptionKeyResolver.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { TokenCredential } from \"@azure/core-auth\";\nimport type { EncryptionKeyResolver } from \"./EncryptionKeyResolver\";\nimport type { KeyWrapAlgorithm } from \"@azure/keyvault-keys\";\nimport { KeyClient } from \"@azure/keyvault-keys\";\nimport { ErrorResponse } from \"../../request\";\nimport { EncryptionKeyResolverName } from \"../enums\";\n\n/**\n * Implementation of EncryptionKeyResolver that uses Azure Key Vault for customer managed keys.\n */\nexport class AzureKeyVaultEncryptionKeyResolver implements EncryptionKeyResolver {\n  private credentials: TokenCredential;\n\n  constructor(credentials: TokenCredential) {\n    this.credentials = credentials;\n  }\n  /**\n   * Name of the resolver to use for client side encryption.\n   * Currently only AzureKeyVault implementation is supported.\n   */\n  public encryptionKeyResolverName = EncryptionKeyResolverName.AzureKeyVault;\n  /**\n   * wraps the given key using the specified key encryption key path and algorithm.\n   * @param encryptionKeyId - path to the customer managed key to be used for wrapping. For Azure Key Vault, this is url of the key in the vault.\n   * @param algorithm - algorithm to be used for wrapping.\n   * @param unwrappedKey - dek to be wrapped.\n   * @returns wrapped DEK.\n   */\n  public async wrapKey(\n    encryptionKeyId: string,\n    algorithm: string,\n    unwrappedKey: Uint8Array,\n  ): Promise<Uint8Array> {\n    try {\n      const origin = this.getOrigin(encryptionKeyId);\n      const keyClient = new KeyClient(origin, this.credentials);\n      const [keyName, keyVersion] = this.getKeyDetails(encryptionKeyId);\n      const cryptographyClient = keyClient.getCryptographyClient(keyName, {\n        keyVersion: keyVersion,\n      });\n      const res = await cryptographyClient.wrapKey(algorithm as KeyWrapAlgorithm, unwrappedKey);\n      if (!res || !res.result) {\n        throw new ErrorResponse(`Failed to wrap key: ${res}`);\n      }\n      return res.result;\n    } catch (e) {\n      throw new ErrorResponse(`Failed to wrap key: ${e.message}`);\n    }\n  }\n  /**\n   * Unwraps the given wrapped key using the specified key encryption key path and algorithm.\n   * @param encryptionKeyId - path to the customer managed key to be used for unwrapping. For Azure Key Vault, this is url of the key in the vault.\n   * @param algorithm - algorithm to be used for unwrapping.\n   * @param wrappedKey - wrapped DEK.\n   * @returns unwrapped DEK.\n   */\n  public async unwrapKey(\n    encryptionKeyId: string,\n    algorithm: string,\n    wrappedKey: Uint8Array,\n  ): Promise<Uint8Array> {\n    try {\n      const origin = this.getOrigin(encryptionKeyId);\n      const keyClient = new KeyClient(origin, this.credentials);\n      const [keyName, keyVersion] = this.getKeyDetails(encryptionKeyId);\n      const cryptographyClient = keyClient.getCryptographyClient(keyName, {\n        keyVersion: keyVersion,\n      });\n      const res = await cryptographyClient.unwrapKey(algorithm as KeyWrapAlgorithm, wrappedKey);\n      if (!res || !res.result) {\n        throw new ErrorResponse(`Failed to wrap key: ${res}`);\n      }\n      return res.result;\n    } catch (e) {\n      throw new ErrorResponse(`Failed to unwrap key: ${e.message}`);\n    }\n  }\n  // TODO: improve this method to extract key name and version from the url\n  private getKeyDetails(encryptionKeyId: string): [string, string] {\n    let url;\n    try {\n      url = new URL(encryptionKeyId);\n      const parts = url.pathname.split(\"/\");\n      if (parts.length < 4 || parts.length > 5) {\n        throw new ErrorResponse(\n          `Invalid key url: ${encryptionKeyId}. Key url must be in the format https://<vault>.vault.azure.net/keys/<key-name>/<key-version>`,\n        );\n      }\n      if (parts.length === 4 || parts.length === 5) {\n        return [parts[2], parts[3]];\n      }\n    } catch (e) {\n      throw new ErrorResponse(\n        `Invalid key url: ${encryptionKeyId}. Key url must be in the format https://<vault>.vault.azure.net/keys/<key-name>/<key-version>. Error: ${e.message}`,\n      );\n    }\n  }\n\n  private getOrigin(encryptionKeyId: string): string {\n    try {\n      const url = new URL(encryptionKeyId);\n      return url.origin;\n    } catch (e) {\n      throw new ErrorResponse(\n        `Invalid key url: ${encryptionKeyId}. Key url must be in the format https://<vault>.vault.azure.net/keys/<key-name>/<key-version>. Error: ${e.message}`,\n      );\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}