{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { Constants, ResourceType, StatusCodes, createDeserializer, createSerializer, extractPath } from \"../common\";\nimport { ErrorResponse } from \"../request\";\nimport { withDiagnostics } from \"../utils/diagnostics\";\nexport class EncryptionProcessor {\n  constructor(containerId, containerRid, database, clientContext, encryptionManager) {\n    this.containerId = containerId;\n    this.containerRid = containerRid;\n    this.database = database;\n    this.clientContext = clientContext;\n    this.encryptionManager = encryptionManager;\n  }\n  async encrypt(body) {\n    if (!body) {\n      throw new ErrorResponse(\"Input body is null or undefined.\");\n    }\n    let propertiesEncryptedCount = 0;\n    const encryptionSettings = await this.getEncryptionSetting();\n    if (!encryptionSettings) return {\n      body,\n      propertiesEncryptedCount\n    };\n    for (const pathToEncrypt of encryptionSettings.pathsToEncrypt) {\n      const propertyName = pathToEncrypt.slice(1);\n      if (!Object.prototype.hasOwnProperty.call(body, propertyName)) {\n        continue;\n      }\n      const settingForProperty = encryptionSettings.getEncryptionSettingForProperty(pathToEncrypt);\n      if (!settingForProperty) {\n        throw new ErrorResponse(\"Invalid Encryption Setting for the Property: \" + propertyName);\n      }\n      body[propertyName] = await this.encryptToken(body[propertyName], settingForProperty, propertyName === \"id\");\n      propertiesEncryptedCount++;\n    }\n    return {\n      body,\n      propertiesEncryptedCount\n    };\n  }\n  async isPathEncrypted(path) {\n    path = extractPath(path);\n    const encryptionSettings = await this.getEncryptionSetting();\n    const settingForProperty = encryptionSettings.getEncryptionSettingForProperty(path);\n    if (!settingForProperty) return false;\n    return true;\n  }\n  async encryptProperty(path, value) {\n    path = extractPath(path);\n    const encryptionSettings = await this.getEncryptionSetting();\n    if (!encryptionSettings) return value;\n    const settingForProperty = encryptionSettings.getEncryptionSettingForProperty(path);\n    if (!settingForProperty) {\n      return value;\n    }\n    value = await this.encryptToken(value, settingForProperty, path === \"/id\");\n    return value;\n  }\n  async getEncryptedPartitionKeyValue(partitionKeyList) {\n    const encryptionSettings = await this.getEncryptionSetting();\n    let encryptedCount = 0;\n    if (!encryptionSettings) return {\n      partitionKeyList,\n      encryptedCount\n    };\n    const partitionKeyPaths = encryptionSettings.partitionKeyPaths;\n    for (let i = 0; i < partitionKeyPaths.length; i++) {\n      const partitionKeyPath = extractPath(partitionKeyPaths[i]);\n      if (encryptionSettings.pathsToEncrypt.includes(partitionKeyPath)) {\n        const settingForProperty = encryptionSettings.getEncryptionSettingForProperty(partitionKeyPath);\n        partitionKeyList[i] = await this.encryptToken(partitionKeyList[i], settingForProperty, partitionKeyPath === \"/id\");\n        encryptedCount++;\n      }\n    }\n    return {\n      partitionKeyList,\n      encryptedCount\n    };\n  }\n  async getEncryptedUrl(id) {\n    const parts = id.split(\"/\");\n    const lastPart = parts[parts.length - 1];\n    const encryptedLastPart = await this.getEncryptedId(lastPart);\n    parts[parts.length - 1] = encryptedLastPart;\n    return parts.join(\"/\");\n  }\n  async getEncryptedId(id) {\n    const encryptionSettings = await this.getEncryptionSetting();\n    if (!encryptionSettings) return id;\n    const settingForProperty = encryptionSettings.getEncryptionSettingForProperty(\"/id\");\n    if (!settingForProperty) return id;\n    id = await this.encryptToken(id, settingForProperty, true);\n    return id;\n  }\n  async encryptQueryParameter(path, value, isValueId, type) {\n    if (value === null) {\n      return value;\n    }\n    path = extractPath(path);\n    const encryptionSettings = await this.getEncryptionSetting();\n    if (!encryptionSettings) return value;\n    const settingForProperty = encryptionSettings.getEncryptionSettingForProperty(path);\n    if (!settingForProperty) {\n      return value;\n    }\n    return this.encryptToken(value, settingForProperty, isValueId, type);\n  }\n  async encryptToken(valueToEncrypt, propertySetting, isValueId, type) {\n    if (typeof valueToEncrypt === \"object\" && valueToEncrypt !== null) {\n      for (const key in valueToEncrypt) {\n        if (Object.prototype.hasOwnProperty.call(valueToEncrypt, key)) {\n          valueToEncrypt[key] = await this.encryptToken(valueToEncrypt[key], propertySetting, isValueId, type);\n        }\n      }\n    } else if (Array.isArray(type)) {\n      for (let i = 0; i < valueToEncrypt.length; i++) {\n        valueToEncrypt[i] = await this.encryptToken(valueToEncrypt[i], propertySetting, isValueId, type);\n      }\n    } else {\n      valueToEncrypt = await this.serializeAndEncryptValue(valueToEncrypt, propertySetting, isValueId, type);\n    }\n    return valueToEncrypt;\n  }\n  async serializeAndEncryptValue(valueToEncrypt, propertySetting, isValueId, type) {\n    if (valueToEncrypt === null) {\n      return valueToEncrypt;\n    }\n    const [typeMarker, serializer] = createSerializer(valueToEncrypt, type);\n    const plainText = serializer.serialize(valueToEncrypt);\n    const encryptionAlgorithm = await this.buildEncryptionAlgorithm(propertySetting);\n    const cipherText = encryptionAlgorithm.encrypt(plainText);\n    if (isValueId) {\n      if (typeof valueToEncrypt !== \"string\") {\n        throw new ErrorResponse(\"The id should be of string type.\");\n      }\n    }\n    const cipherTextWithTypeMarker = Buffer.alloc(cipherText.length + 1);\n    cipherTextWithTypeMarker[0] = typeMarker;\n    cipherText.forEach((value, index) => {\n      cipherTextWithTypeMarker[index + 1] = value;\n    });\n    let encryptedValue = Buffer.from(cipherTextWithTypeMarker).toString(\"base64\");\n    if (isValueId) {\n      encryptedValue = encryptedValue.replace(/\\//g, \"_\").replace(/\\+/g, \"-\");\n    }\n    return encryptedValue;\n  }\n  async decrypt(body) {\n    let propertiesDecryptedCount = 0;\n    if (body == null) {\n      return {\n        body,\n        propertiesDecryptedCount\n      };\n    }\n    const encryptionSettings = await this.getEncryptionSetting();\n    if (!encryptionSettings) return {\n      body,\n      propertiesDecryptedCount\n    };\n    for (const pathToEncrypt of encryptionSettings.pathsToEncrypt) {\n      const propertyName = pathToEncrypt.slice(1);\n      if (!Object.prototype.hasOwnProperty.call(body, propertyName)) {\n        continue;\n      }\n      const settingForProperty = encryptionSettings.getEncryptionSettingForProperty(pathToEncrypt);\n      if (settingForProperty == null) {\n        throw new ErrorResponse(\"Invalid Encryption Setting for the Path: \" + pathToEncrypt);\n      }\n      body[propertyName] = await this.decryptToken(body[propertyName], settingForProperty, propertyName === \"id\");\n      propertiesDecryptedCount++;\n    }\n    return {\n      body,\n      propertiesDecryptedCount\n    };\n  }\n  async decryptToken(valueToDecrypt, propertySetting, isValueId) {\n    if (typeof valueToDecrypt === \"object\") {\n      for (const key in valueToDecrypt) {\n        if (Object.prototype.hasOwnProperty.call(valueToDecrypt, key)) {\n          valueToDecrypt[key] = await this.decryptToken(valueToDecrypt[key], propertySetting, isValueId);\n        }\n      }\n    } else if (Array.isArray(valueToDecrypt)) {\n      for (let i = 0; i < valueToDecrypt.length; i++) {\n        valueToDecrypt[i] = await this.decryptToken(valueToDecrypt[i], propertySetting, isValueId);\n      }\n    } else {\n      valueToDecrypt = await this.deserializeAndDecryptValue(valueToDecrypt, propertySetting, isValueId);\n    }\n    return valueToDecrypt;\n  }\n  async deserializeAndDecryptValue(valueToDecrypt, propertySetting, isValueId) {\n    if (isValueId) {\n      valueToDecrypt = valueToDecrypt.replace(/_/g, \"/\").replace(/-/g, \"+\");\n    }\n    const cipherTextWithTypeMarker = Buffer.from(valueToDecrypt, \"base64\");\n    if (cipherTextWithTypeMarker === null) {\n      return null;\n    }\n    let cipherText = Buffer.alloc(cipherTextWithTypeMarker.length - 1);\n    cipherText = Buffer.from(cipherTextWithTypeMarker.slice(1));\n    const encryptionAlgorithm = await this.buildEncryptionAlgorithm(propertySetting);\n    const plainText = encryptionAlgorithm.decrypt(cipherText);\n    if (plainText === null) {\n      throw new ErrorResponse(\"returned null plain text\");\n    }\n    const serializer = createDeserializer(cipherTextWithTypeMarker[0]);\n    return serializer.deserialize(plainText);\n  }\n  async getEncryptionSetting(forceRefresh) {\n    const key = this.database._rid + \"/\" + this.containerRid;\n    const encryptionSetting = this.encryptionManager.encryptionSettingsCache.get(key);\n    if (forceRefresh || !encryptionSetting) {\n      return withDiagnostics(async diagnosticNode => {\n        const path = `/dbs/${this.database.id}/colls/${this.containerId}`;\n        const id = `dbs/${this.database.id}/colls/${this.containerId}`;\n        const response = await this.clientContext.read({\n          path,\n          resourceType: ResourceType.container,\n          resourceId: id,\n          diagnosticNode\n        });\n        if (!response || !response.result) {\n          throw new ErrorResponse(\"Failed to fetch container definition\");\n        }\n        const containerRid = response.result._rid;\n        const clientEncryptionPolicy = response.result.clientEncryptionPolicy;\n        const partitionKeyPaths = response.result.partitionKey.paths;\n        const updatedEncryptionSetting = await this.encryptionManager.encryptionSettingsCache.create(key, containerRid, partitionKeyPaths, clientEncryptionPolicy);\n        return updatedEncryptionSetting;\n      }, this.clientContext);\n    }\n    return encryptionSetting;\n  }\n  async buildEncryptionAlgorithm(propertySetting) {\n    const key = `${this.database._rid}/${propertySetting.encryptionKeyId}`;\n    let clientEncryptionKeyProperties = this.encryptionManager.clientEncryptionKeyPropertiesCache.get(key);\n    if (!clientEncryptionKeyProperties) {\n      clientEncryptionKeyProperties = await this.fetchClientEncryptionKey(propertySetting.encryptionKeyId);\n    }\n    try {\n      // the buildEncryptionAlgorithm will build ProtectedDEK which calls unwrapKey  using the masterKey configured in\n      // KeyEncryptionKey(created before creating Protected DEK)\n      // we get wrapped key and key wrap metadata info from clientEncryptionKeyProperties.\n      return await propertySetting.buildEncryptionAlgorithm(clientEncryptionKeyProperties, this.encryptionManager);\n    } catch (err) {\n      if (err.statusCode !== StatusCodes.Forbidden) throw err;\n      // if access to key is revoked, and in case there's stale value in cache\n      clientEncryptionKeyProperties = await this.fetchClientEncryptionKey(propertySetting.encryptionKeyId);\n      try {\n        // This will succeed after if client has rewrapped CEK and gateway cache has updated value.\n        return await propertySetting.buildEncryptionAlgorithm(clientEncryptionKeyProperties, this.encryptionManager, true);\n      } catch (retryErr) {\n        if (retryErr.statusCode !== StatusCodes.Forbidden) throw retryErr;\n        // in case there's stale value in gateway cache. get fresh value from backend\n        clientEncryptionKeyProperties = await this.fetchClientEncryptionKey(propertySetting.encryptionKeyId, clientEncryptionKeyProperties.etag);\n        return propertySetting.buildEncryptionAlgorithm(clientEncryptionKeyProperties, this.encryptionManager);\n      }\n    }\n  }\n  async fetchClientEncryptionKey(cekId, cekEtag) {\n    return withDiagnostics(async diagnosticNode => {\n      const path = `/dbs/${this.database.id}/clientencryptionkeys/${cekId}`;\n      const id = `dbs/${this.database.id}/clientencryptionkeys/${cekId}`;\n      const options = {};\n      if (cekEtag) {\n        options.accessCondition = {\n          type: Constants.HttpHeaders.IfNoneMatch,\n          condition: cekEtag\n        };\n      }\n      options.databaseRid = this.database._rid;\n      const response = await this.clientContext.read({\n        path: path,\n        resourceType: ResourceType.clientencryptionkey,\n        resourceId: id,\n        options: options,\n        diagnosticNode\n      });\n      if (!response) {\n        throw new ErrorResponse(`Failed to fetch client encryption key ${cekId}`);\n      }\n      if (response.code === StatusCodes.NotModified) {\n        throw new ErrorResponse(`The Client Encryption Key with key id: ${cekId} on database: ${this.database.id} needs to be rewrapped with a valid Key Encryption Key using rewrapClientEncryptionKey. The Key Encryption Key used to wrap the Client Encryption Key has been revoked`);\n      }\n      const clientEncryptionKeyProperties = {\n        id: response.result.id,\n        encryptionAlgorithm: response.result.encryptionAlgorithm,\n        wrappedDataEncryptionKey: new Uint8Array(Buffer.from(response.result.wrappedDataEncryptionKey, \"base64\")),\n        encryptionKeyWrapMetadata: response.result.keyWrapMetadata,\n        etag: response.result._etag\n      };\n      const key = this.database._rid + \"/\" + cekId;\n      this.encryptionManager.clientEncryptionKeyPropertiesCache.set(key, clientEncryptionKeyProperties);\n      return clientEncryptionKeyProperties;\n    }, this.clientContext);\n  }\n}","map":{"version":3,"names":["Constants","ResourceType","StatusCodes","createDeserializer","createSerializer","extractPath","ErrorResponse","withDiagnostics","EncryptionProcessor","constructor","containerId","containerRid","database","clientContext","encryptionManager","encrypt","body","propertiesEncryptedCount","encryptionSettings","getEncryptionSetting","pathToEncrypt","pathsToEncrypt","propertyName","slice","Object","prototype","hasOwnProperty","call","settingForProperty","getEncryptionSettingForProperty","encryptToken","isPathEncrypted","path","encryptProperty","value","getEncryptedPartitionKeyValue","partitionKeyList","encryptedCount","partitionKeyPaths","i","length","partitionKeyPath","includes","getEncryptedUrl","id","parts","split","lastPart","encryptedLastPart","getEncryptedId","join","encryptQueryParameter","isValueId","type","valueToEncrypt","propertySetting","key","Array","isArray","serializeAndEncryptValue","typeMarker","serializer","plainText","serialize","encryptionAlgorithm","buildEncryptionAlgorithm","cipherText","cipherTextWithTypeMarker","Buffer","alloc","forEach","index","encryptedValue","from","toString","replace","decrypt","propertiesDecryptedCount","decryptToken","valueToDecrypt","deserializeAndDecryptValue","deserialize","forceRefresh","_rid","encryptionSetting","encryptionSettingsCache","get","diagnosticNode","response","read","resourceType","container","resourceId","result","clientEncryptionPolicy","partitionKey","paths","updatedEncryptionSetting","create","encryptionKeyId","clientEncryptionKeyProperties","clientEncryptionKeyPropertiesCache","fetchClientEncryptionKey","err","statusCode","Forbidden","retryErr","etag","cekId","cekEtag","options","accessCondition","HttpHeaders","IfNoneMatch","condition","databaseRid","clientencryptionkey","code","NotModified","wrappedDataEncryptionKey","Uint8Array","encryptionKeyWrapMetadata","keyWrapMetadata","_etag","set"],"sources":["/Users/eimis/test-server/Azure Hackthons/azure-cloud-architecture-game /node_modules/@azure/cosmos/src/encryption/EncryptionProcessor.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { EncryptionSettings } from \"./EncryptionSettings\";\nimport type { EncryptionSettingForProperty } from \"./EncryptionSettingForProperty\";\nimport type { AeadAes256CbcHmacSha256Algorithm } from \"./AeadAes256CbcHmacSha256Algorithm\";\nimport type { ContainerDefinition, Database, ItemDefinition } from \"../client\";\nimport type { PartitionKeyInternal } from \"../documents\";\nimport type { TypeMarker } from \"./enums/TypeMarker\";\nimport type { ClientContext } from \"../ClientContext\";\nimport type { ClientEncryptionKeyRequest } from \"./ClientEncryptionKey\";\nimport type { ClientEncryptionKeyProperties } from \"./ClientEncryptionKey\";\nimport type { DiagnosticNodeInternal } from \"../diagnostics/DiagnosticNodeInternal\";\nimport {\n  Constants,\n  ResourceType,\n  StatusCodes,\n  createDeserializer,\n  createSerializer,\n  extractPath,\n} from \"../common\";\nimport type { RequestOptions } from \"../request\";\nimport { ErrorResponse } from \"../request\";\nimport { withDiagnostics } from \"../utils/diagnostics\";\nimport type { EncryptionManager } from \"./EncryptionManager\";\nimport type { JSONValue } from \"../queryExecutionContext\";\n\nexport class EncryptionProcessor {\n  constructor(\n    private readonly containerId: string,\n    public containerRid: string,\n    private readonly database: Database,\n    private readonly clientContext: ClientContext,\n    private encryptionManager: EncryptionManager,\n  ) {}\n\n  async encrypt<T extends ItemDefinition>(\n    body: T,\n  ): Promise<{ body: T; propertiesEncryptedCount: number }> {\n    if (!body) {\n      throw new ErrorResponse(\"Input body is null or undefined.\");\n    }\n    let propertiesEncryptedCount = 0;\n    const encryptionSettings = await this.getEncryptionSetting();\n    if (!encryptionSettings) return { body, propertiesEncryptedCount };\n    for (const pathToEncrypt of encryptionSettings.pathsToEncrypt) {\n      const propertyName = pathToEncrypt.slice(1);\n      if (!Object.prototype.hasOwnProperty.call(body, propertyName)) {\n        continue;\n      }\n\n      const settingForProperty = encryptionSettings.getEncryptionSettingForProperty(pathToEncrypt);\n      if (!settingForProperty) {\n        throw new ErrorResponse(\"Invalid Encryption Setting for the Property: \" + propertyName);\n      }\n      body[propertyName as keyof T] = await this.encryptToken(\n        body[propertyName],\n        settingForProperty,\n        propertyName === \"id\",\n      );\n      propertiesEncryptedCount++;\n    }\n    return { body, propertiesEncryptedCount };\n  }\n\n  async isPathEncrypted(path: string): Promise<boolean> {\n    path = extractPath(path);\n    const encryptionSettings = await this.getEncryptionSetting();\n    const settingForProperty = encryptionSettings.getEncryptionSettingForProperty(path);\n    if (!settingForProperty) return false;\n    return true;\n  }\n\n  async encryptProperty(path: string, value: JSONValue): Promise<any> {\n    path = extractPath(path);\n    const encryptionSettings = await this.getEncryptionSetting();\n    if (!encryptionSettings) return value;\n    const settingForProperty = encryptionSettings.getEncryptionSettingForProperty(path);\n    if (!settingForProperty) {\n      return value;\n    }\n\n    value = await this.encryptToken(value, settingForProperty, path === \"/id\");\n    return value;\n  }\n\n  async getEncryptedPartitionKeyValue(\n    partitionKeyList: PartitionKeyInternal,\n  ): Promise<{ partitionKeyList: PartitionKeyInternal; encryptedCount: number }> {\n    const encryptionSettings = await this.getEncryptionSetting();\n    let encryptedCount = 0;\n    if (!encryptionSettings) return { partitionKeyList, encryptedCount };\n    const partitionKeyPaths = encryptionSettings.partitionKeyPaths;\n    for (let i = 0; i < partitionKeyPaths.length; i++) {\n      const partitionKeyPath = extractPath(partitionKeyPaths[i]);\n      if (encryptionSettings.pathsToEncrypt.includes(partitionKeyPath)) {\n        const settingForProperty =\n          encryptionSettings.getEncryptionSettingForProperty(partitionKeyPath);\n        partitionKeyList[i] = await this.encryptToken(\n          partitionKeyList[i],\n          settingForProperty,\n          partitionKeyPath === \"/id\",\n        );\n        encryptedCount++;\n      }\n    }\n    return { partitionKeyList, encryptedCount };\n  }\n\n  async getEncryptedUrl(id: string): Promise<string> {\n    const parts = id.split(\"/\");\n    const lastPart = parts[parts.length - 1];\n    const encryptedLastPart = await this.getEncryptedId(lastPart);\n    parts[parts.length - 1] = encryptedLastPart;\n    return parts.join(\"/\");\n  }\n\n  async getEncryptedId(id: string): Promise<string> {\n    const encryptionSettings = await this.getEncryptionSetting();\n    if (!encryptionSettings) return id;\n    const settingForProperty = encryptionSettings.getEncryptionSettingForProperty(\"/id\");\n\n    if (!settingForProperty) return id;\n    id = await this.encryptToken(id, settingForProperty, true);\n    return id;\n  }\n\n  async encryptQueryParameter(\n    path: string,\n    value: JSONValue,\n    isValueId: boolean,\n    type?: TypeMarker,\n  ): Promise<JSONValue> {\n    if (value === null) {\n      return value;\n    }\n    path = extractPath(path);\n    const encryptionSettings = await this.getEncryptionSetting();\n    if (!encryptionSettings) return value;\n    const settingForProperty = encryptionSettings.getEncryptionSettingForProperty(path);\n    if (!settingForProperty) {\n      return value;\n    }\n    return this.encryptToken(value, settingForProperty, isValueId, type);\n  }\n\n  private async encryptToken(\n    valueToEncrypt: any,\n    propertySetting: EncryptionSettingForProperty,\n    isValueId: boolean,\n    type?: TypeMarker,\n  ): Promise<any> {\n    if (typeof valueToEncrypt === \"object\" && valueToEncrypt !== null) {\n      for (const key in valueToEncrypt) {\n        if (Object.prototype.hasOwnProperty.call(valueToEncrypt, key)) {\n          valueToEncrypt[key] = await this.encryptToken(\n            valueToEncrypt[key],\n            propertySetting,\n            isValueId,\n            type,\n          );\n        }\n      }\n    } else if (Array.isArray(type)) {\n      for (let i = 0; i < valueToEncrypt.length; i++) {\n        valueToEncrypt[i] = await this.encryptToken(\n          valueToEncrypt[i],\n          propertySetting,\n          isValueId,\n          type,\n        );\n      }\n    } else {\n      valueToEncrypt = await this.serializeAndEncryptValue(\n        valueToEncrypt,\n        propertySetting,\n        isValueId,\n        type,\n      );\n    }\n    return valueToEncrypt;\n  }\n\n  private async serializeAndEncryptValue(\n    valueToEncrypt: any,\n    propertySetting: EncryptionSettingForProperty,\n    isValueId: boolean,\n    type?: TypeMarker,\n  ): Promise<string> {\n    if (valueToEncrypt === null) {\n      return valueToEncrypt;\n    }\n    const [typeMarker, serializer] = createSerializer(valueToEncrypt, type);\n    const plainText = serializer.serialize(valueToEncrypt);\n    const encryptionAlgorithm = await this.buildEncryptionAlgorithm(propertySetting);\n    const cipherText = encryptionAlgorithm.encrypt(plainText);\n    if (isValueId) {\n      if (typeof valueToEncrypt !== \"string\") {\n        throw new ErrorResponse(\"The id should be of string type.\");\n      }\n    }\n\n    const cipherTextWithTypeMarker = Buffer.alloc(cipherText.length + 1);\n    cipherTextWithTypeMarker[0] = typeMarker;\n    cipherText.forEach((value, index) => {\n      cipherTextWithTypeMarker[index + 1] = value;\n    });\n    let encryptedValue = Buffer.from(cipherTextWithTypeMarker).toString(\"base64\");\n    if (isValueId) {\n      encryptedValue = encryptedValue.replace(/\\//g, \"_\").replace(/\\+/g, \"-\");\n    }\n    return encryptedValue;\n  }\n\n  async decrypt<T extends ItemDefinition>(\n    body: T,\n  ): Promise<{ body: T; propertiesDecryptedCount: number }> {\n    let propertiesDecryptedCount = 0;\n    if (body == null) {\n      return { body, propertiesDecryptedCount };\n    }\n    const encryptionSettings = await this.getEncryptionSetting();\n    if (!encryptionSettings) return { body, propertiesDecryptedCount };\n    for (const pathToEncrypt of encryptionSettings.pathsToEncrypt) {\n      const propertyName = pathToEncrypt.slice(1);\n      if (!Object.prototype.hasOwnProperty.call(body, propertyName)) {\n        continue;\n      }\n      const settingForProperty = encryptionSettings.getEncryptionSettingForProperty(pathToEncrypt);\n      if (settingForProperty == null) {\n        throw new ErrorResponse(\"Invalid Encryption Setting for the Path: \" + pathToEncrypt);\n      }\n\n      body[propertyName as keyof T] = await this.decryptToken(\n        body[propertyName],\n        settingForProperty,\n        propertyName === \"id\",\n      );\n      propertiesDecryptedCount++;\n    }\n    return { body, propertiesDecryptedCount };\n  }\n\n  private async decryptToken(\n    valueToDecrypt: any,\n    propertySetting: EncryptionSettingForProperty,\n    isValueId: boolean,\n  ): Promise<any> {\n    if (typeof valueToDecrypt === \"object\") {\n      for (const key in valueToDecrypt) {\n        if (Object.prototype.hasOwnProperty.call(valueToDecrypt, key)) {\n          valueToDecrypt[key] = await this.decryptToken(\n            valueToDecrypt[key],\n            propertySetting,\n            isValueId,\n          );\n        }\n      }\n    } else if (Array.isArray(valueToDecrypt)) {\n      for (let i = 0; i < valueToDecrypt.length; i++) {\n        valueToDecrypt[i] = await this.decryptToken(valueToDecrypt[i], propertySetting, isValueId);\n      }\n    } else {\n      valueToDecrypt = await this.deserializeAndDecryptValue(\n        valueToDecrypt,\n        propertySetting,\n        isValueId,\n      );\n    }\n    return valueToDecrypt;\n  }\n\n  private async deserializeAndDecryptValue(\n    valueToDecrypt: string,\n    propertySetting: EncryptionSettingForProperty,\n    isValueId: boolean,\n  ): Promise<any> {\n    if (isValueId) {\n      valueToDecrypt = valueToDecrypt.replace(/_/g, \"/\").replace(/-/g, \"+\");\n    }\n    const cipherTextWithTypeMarker = Buffer.from(valueToDecrypt, \"base64\");\n    if (cipherTextWithTypeMarker === null) {\n      return null;\n    }\n\n    let cipherText = Buffer.alloc(cipherTextWithTypeMarker.length - 1);\n    cipherText = Buffer.from(cipherTextWithTypeMarker.slice(1));\n\n    const encryptionAlgorithm = await this.buildEncryptionAlgorithm(propertySetting);\n    const plainText = encryptionAlgorithm.decrypt(cipherText);\n    if (plainText === null) {\n      throw new ErrorResponse(\"returned null plain text\");\n    }\n\n    const serializer = createDeserializer(cipherTextWithTypeMarker[0] as TypeMarker);\n    return serializer.deserialize(plainText);\n  }\n\n  async getEncryptionSetting(forceRefresh?: boolean): Promise<EncryptionSettings> {\n    const key = this.database._rid + \"/\" + this.containerRid;\n    const encryptionSetting = this.encryptionManager.encryptionSettingsCache.get(key);\n    if (forceRefresh || !encryptionSetting) {\n      return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n        const path = `/dbs/${this.database.id}/colls/${this.containerId}`;\n        const id = `dbs/${this.database.id}/colls/${this.containerId}`;\n        const response = await this.clientContext.read<ContainerDefinition>({\n          path,\n          resourceType: ResourceType.container,\n          resourceId: id,\n          diagnosticNode,\n        });\n        if (!response || !response.result) {\n          throw new ErrorResponse(\"Failed to fetch container definition\");\n        }\n        const containerRid = response.result._rid;\n        const clientEncryptionPolicy = response.result.clientEncryptionPolicy;\n        const partitionKeyPaths = response.result.partitionKey.paths;\n        const updatedEncryptionSetting =\n          await this.encryptionManager.encryptionSettingsCache.create(\n            key,\n            containerRid,\n            partitionKeyPaths,\n            clientEncryptionPolicy,\n          );\n        return updatedEncryptionSetting;\n      }, this.clientContext);\n    }\n    return encryptionSetting;\n  }\n\n  private async buildEncryptionAlgorithm(\n    propertySetting: EncryptionSettingForProperty,\n  ): Promise<AeadAes256CbcHmacSha256Algorithm> {\n    const key = `${this.database._rid}/${propertySetting.encryptionKeyId}`;\n    let clientEncryptionKeyProperties =\n      this.encryptionManager.clientEncryptionKeyPropertiesCache.get(key);\n    if (!clientEncryptionKeyProperties) {\n      clientEncryptionKeyProperties = await this.fetchClientEncryptionKey(\n        propertySetting.encryptionKeyId,\n      );\n    }\n    try {\n      // the buildEncryptionAlgorithm will build ProtectedDEK which calls unwrapKey  using the masterKey configured in\n      // KeyEncryptionKey(created before creating Protected DEK)\n      // we get wrapped key and key wrap metadata info from clientEncryptionKeyProperties.\n      return await propertySetting.buildEncryptionAlgorithm(\n        clientEncryptionKeyProperties,\n        this.encryptionManager,\n      );\n    } catch (err) {\n      if (err.statusCode !== StatusCodes.Forbidden) throw err;\n      // if access to key is revoked, and in case there's stale value in cache\n      clientEncryptionKeyProperties = await this.fetchClientEncryptionKey(\n        propertySetting.encryptionKeyId,\n      );\n\n      try {\n        // This will succeed after if client has rewrapped CEK and gateway cache has updated value.\n        return await propertySetting.buildEncryptionAlgorithm(\n          clientEncryptionKeyProperties,\n          this.encryptionManager,\n          true,\n        );\n      } catch (retryErr) {\n        if (retryErr.statusCode !== StatusCodes.Forbidden) throw retryErr;\n\n        // in case there's stale value in gateway cache. get fresh value from backend\n        clientEncryptionKeyProperties = await this.fetchClientEncryptionKey(\n          propertySetting.encryptionKeyId,\n          clientEncryptionKeyProperties.etag,\n        );\n        return propertySetting.buildEncryptionAlgorithm(\n          clientEncryptionKeyProperties,\n          this.encryptionManager,\n        );\n      }\n    }\n  }\n\n  private async fetchClientEncryptionKey(\n    cekId: string,\n    cekEtag?: string,\n  ): Promise<ClientEncryptionKeyProperties> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      const path = `/dbs/${this.database.id}/clientencryptionkeys/${cekId}`;\n      const id = `dbs/${this.database.id}/clientencryptionkeys/${cekId}`;\n      const options: RequestOptions = {};\n      if (cekEtag) {\n        options.accessCondition = {\n          type: Constants.HttpHeaders.IfNoneMatch,\n          condition: cekEtag,\n        };\n      }\n      options.databaseRid = this.database._rid;\n      const response = await this.clientContext.read<ClientEncryptionKeyRequest>({\n        path: path,\n        resourceType: ResourceType.clientencryptionkey,\n        resourceId: id,\n        options: options,\n        diagnosticNode,\n      });\n      if (!response) {\n        throw new ErrorResponse(`Failed to fetch client encryption key ${cekId}`);\n      }\n      if (response.code === StatusCodes.NotModified) {\n        throw new ErrorResponse(\n          `The Client Encryption Key with key id: ${cekId} on database: ${this.database.id} needs to be rewrapped with a valid Key Encryption Key using rewrapClientEncryptionKey. The Key Encryption Key used to wrap the Client Encryption Key has been revoked`,\n        );\n      }\n      const clientEncryptionKeyProperties: ClientEncryptionKeyProperties = {\n        id: response.result.id,\n        encryptionAlgorithm: response.result.encryptionAlgorithm,\n        wrappedDataEncryptionKey: new Uint8Array(\n          Buffer.from(response.result.wrappedDataEncryptionKey, \"base64\"),\n        ),\n        encryptionKeyWrapMetadata: response.result.keyWrapMetadata,\n        etag: response.result._etag,\n      };\n      const key = this.database._rid + \"/\" + cekId;\n      this.encryptionManager.clientEncryptionKeyPropertiesCache.set(\n        key,\n        clientEncryptionKeyProperties,\n      );\n      return clientEncryptionKeyProperties;\n    }, this.clientContext);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}