{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { Database, Databases } from \"./client/Database\";\nimport { Offer, Offers } from \"./client/Offer\";\nimport { ClientContext } from \"./ClientContext\";\nimport { parseConnectionString } from \"./common\";\nimport { Constants } from \"./common/constants\";\nimport { getUserAgent } from \"./common/platform\";\nimport { determineDiagnosticLevel, getDiagnosticLevelFromEnvironment } from \"./diagnostics\";\nimport { DiagnosticNodeType } from \"./diagnostics/DiagnosticNodeInternal\";\nimport { defaultConnectionPolicy } from \"./documents\";\nimport { EncryptionManager } from \"./encryption/EncryptionManager\";\nimport { GlobalEndpointManager } from \"./globalEndpointManager\";\nimport { ResourceResponse } from \"./request\";\nimport { checkURL } from \"./utils/checkURL\";\nimport { getEmptyCosmosDiagnostics, withDiagnostics } from \"./utils/diagnostics\";\n/**\n * Provides a client-side logical representation of the Azure Cosmos DB database account.\n * This client is used to configure and execute requests in the Azure Cosmos DB database service.\n * @example Instantiate a client and create a new database\n * ```typescript\n * const client = new CosmosClient({endpoint: \"<URL HERE>\", key: \"<KEY HERE>\"});\n * await client.databases.create({id: \"<database name here>\"});\n * ```\n * @example Instantiate a client with custom Connection Policy\n * ```typescript\n * const client = new CosmosClient({\n *    endpoint: \"<URL HERE>\",\n *    key: \"<KEY HERE>\",\n *    connectionPolicy: {\n *     requestTimeout: 10000,\n *    },\n * });\n * ```\n */\nexport class CosmosClient {\n  constructor(optionsOrConnectionString) {\n    var _a, _b;\n    if (typeof optionsOrConnectionString === \"string\") {\n      optionsOrConnectionString = parseConnectionString(optionsOrConnectionString);\n    } else if (optionsOrConnectionString.connectionString) {\n      const {\n        endpoint,\n        key\n      } = parseConnectionString(optionsOrConnectionString.connectionString);\n      optionsOrConnectionString.endpoint = endpoint;\n      optionsOrConnectionString.key = key;\n    }\n    const endpoint = checkURL(optionsOrConnectionString.endpoint);\n    if (!endpoint) {\n      throw new Error(\"Invalid endpoint specified\");\n    }\n    if (optionsOrConnectionString.clientEncryptionOptions) {\n      if (!optionsOrConnectionString.clientEncryptionOptions.keyEncryptionKeyResolver) {\n        throw new Error(\"KeyEncryptionKeyResolver needs to be provided to enable client-side encryption.\");\n      }\n      if (optionsOrConnectionString.clientEncryptionOptions.encryptionKeyTimeToLiveInSeconds && optionsOrConnectionString.clientEncryptionOptions.encryptionKeyTimeToLiveInSeconds < 60) {\n        throw new Error(\"EncryptionKeyTimeToLiveInSeconds needs to be >= 60 seconds.\");\n      }\n      this.encryptionManager = new EncryptionManager(optionsOrConnectionString.clientEncryptionOptions.keyEncryptionKeyResolver, optionsOrConnectionString.clientEncryptionOptions.encryptionKeyTimeToLiveInSeconds);\n    }\n    const clientConfig = this.initializeClientConfigDiagnostic(optionsOrConnectionString);\n    optionsOrConnectionString.connectionPolicy = Object.assign({}, defaultConnectionPolicy, optionsOrConnectionString.connectionPolicy);\n    optionsOrConnectionString.defaultHeaders = optionsOrConnectionString.defaultHeaders || {};\n    optionsOrConnectionString.defaultHeaders[Constants.HttpHeaders.CacheControl] = \"no-cache\";\n    optionsOrConnectionString.defaultHeaders[Constants.HttpHeaders.Version] = Constants.CurrentVersion;\n    if (optionsOrConnectionString.consistencyLevel !== undefined) {\n      optionsOrConnectionString.defaultHeaders[Constants.HttpHeaders.ConsistencyLevel] = optionsOrConnectionString.consistencyLevel;\n    }\n    if (optionsOrConnectionString.throughputBucket !== undefined) {\n      optionsOrConnectionString.defaultHeaders[Constants.HttpHeaders.ThroughputBucket] = optionsOrConnectionString.throughputBucket;\n    }\n    const userAgent = getUserAgent(optionsOrConnectionString.userAgentSuffix);\n    optionsOrConnectionString.defaultHeaders[Constants.HttpHeaders.UserAgent] = userAgent;\n    optionsOrConnectionString.defaultHeaders[Constants.HttpHeaders.CustomUserAgent] = userAgent;\n    const globalEndpointManager = new GlobalEndpointManager(optionsOrConnectionString, async (diagnosticNode, opts) => this.getDatabaseAccountInternal(diagnosticNode, opts));\n    this.clientContext = new ClientContext(optionsOrConnectionString, globalEndpointManager, clientConfig, determineDiagnosticLevel(optionsOrConnectionString.diagnosticLevel, getDiagnosticLevelFromEnvironment()));\n    if (((_a = optionsOrConnectionString.connectionPolicy) === null || _a === void 0 ? void 0 : _a.enableEndpointDiscovery) && ((_b = optionsOrConnectionString.connectionPolicy) === null || _b === void 0 ? void 0 : _b.enableBackgroundEndpointRefreshing)) {\n      this.backgroundRefreshEndpointList(globalEndpointManager, optionsOrConnectionString.connectionPolicy.endpointRefreshRateInMs || defaultConnectionPolicy.endpointRefreshRateInMs);\n    }\n    this.databases = new Databases(this, this.clientContext, this.encryptionManager);\n    this.offers = new Offers(this, this.clientContext);\n  }\n  initializeClientConfigDiagnostic(optionsOrConnectionString) {\n    return {\n      endpoint: optionsOrConnectionString.endpoint,\n      resourceTokensConfigured: optionsOrConnectionString.resourceTokens !== undefined,\n      tokenProviderConfigured: optionsOrConnectionString.tokenProvider !== undefined,\n      aadCredentialsConfigured: optionsOrConnectionString.aadCredentials !== undefined,\n      connectionPolicyConfigured: optionsOrConnectionString.connectionPolicy !== undefined,\n      consistencyLevel: optionsOrConnectionString.consistencyLevel,\n      defaultHeaders: optionsOrConnectionString.defaultHeaders,\n      agentConfigured: optionsOrConnectionString.agent !== undefined,\n      userAgentSuffix: optionsOrConnectionString.userAgentSuffix,\n      diagnosticLevel: optionsOrConnectionString.diagnosticLevel,\n      pluginsConfigured: optionsOrConnectionString.plugins !== undefined,\n      sDKVersion: Constants.SDKVersion\n    };\n  }\n  /**\n   * Get information about the current {@link DatabaseAccount} (including which regions are supported, etc.)\n   */\n  async getDatabaseAccount(options) {\n    return withDiagnostics(async diagnosticNode => {\n      return this.getDatabaseAccountInternal(diagnosticNode, options);\n    }, this.clientContext);\n  }\n  /**\n   * @hidden\n   */\n  async getDatabaseAccountInternal(diagnosticNode, options) {\n    const response = await this.clientContext.getDatabaseAccount(diagnosticNode, options);\n    return new ResourceResponse(response.result, response.headers, response.code, getEmptyCosmosDiagnostics(), response.substatus);\n  }\n  /**\n   * Gets the currently used write endpoint url. Useful for troubleshooting purposes.\n   *\n   * The url may contain a region suffix (e.g. \"-eastus\") if we're using location specific endpoints.\n   */\n  async getWriteEndpoint() {\n    return withDiagnostics(async diagnosticNode => {\n      return this.clientContext.getWriteEndpoint(diagnosticNode);\n    }, this.clientContext);\n  }\n  /**\n   * Gets the currently used read endpoint. Useful for troubleshooting purposes.\n   *\n   * The url may contain a region suffix (e.g. \"-eastus\") if we're using location specific endpoints.\n   */\n  async getReadEndpoint() {\n    return withDiagnostics(async diagnosticNode => {\n      return this.clientContext.getReadEndpoint(diagnosticNode);\n    }, this.clientContext);\n  }\n  /**\n   * Gets the known write endpoints. Useful for troubleshooting purposes.\n   *\n   * The urls may contain a region suffix (e.g. \"-eastus\") if we're using location specific endpoints.\n   */\n  getWriteEndpoints() {\n    return this.clientContext.getWriteEndpoints();\n  }\n  /**\n   * Gets the currently used read endpoint. Useful for troubleshooting purposes.\n   *\n   * The url may contain a region suffix (e.g. \"-eastus\") if we're using location specific endpoints.\n   */\n  getReadEndpoints() {\n    return this.clientContext.getReadEndpoints();\n  }\n  /**\n   * Used for reading, updating, or deleting a existing database by id or accessing containers belonging to that database.\n   *\n   * This does not make a network call. Use `.read` to get info about the database after getting the {@link Database} object.\n   *\n   * @param id - The id of the database.\n   * @example Create a new container off of an existing database\n   * ```typescript\n   * const container = client.database(\"<database id>\").containers.create(\"<container id>\");\n   * ```\n   *\n   * @example Delete an existing database\n   * ```typescript\n   * await client.database(\"<id here>\").delete();\n   * ```\n   */\n  database(id) {\n    return new Database(this, id, this.clientContext, this.encryptionManager);\n  }\n  /**\n   * Used for reading, or updating a existing offer by id.\n   * @param id - The id of the offer.\n   */\n  offer(id) {\n    return new Offer(this, id, this.clientContext);\n  }\n  /**\n   * Clears background endpoint refresher. Use client.dispose() when destroying the CosmosClient within another process.\n   */\n  dispose() {\n    clearTimeout(this.endpointRefresher);\n    if (this.clientContext.enableEncryption) {\n      clearTimeout(this.encryptionManager.encryptionKeyStoreProvider.cacheRefresher);\n      clearTimeout(this.encryptionManager.protectedDataEncryptionKeyCache.cacheRefresher);\n    }\n  }\n  async backgroundRefreshEndpointList(globalEndpointManager, refreshRate) {\n    this.endpointRefresher = setInterval(() => {\n      try {\n        return withDiagnostics(async diagnosticNode => {\n          return globalEndpointManager.refreshEndpointList(diagnosticNode);\n        }, this.clientContext, DiagnosticNodeType.BACKGROUND_REFRESH_THREAD);\n      } catch (e) {\n        console.warn(\"Failed to refresh endpoints\", e);\n      }\n    }, refreshRate);\n    if (this.endpointRefresher.unref && typeof this.endpointRefresher.unref === \"function\") {\n      this.endpointRefresher.unref();\n    }\n  }\n  /**\n   * Update the host framework. If provided host framework will be used to generate the defualt SDK user agent.\n   * @param hostFramework - A custom string.\n   * @internal\n   */\n  async updateHostFramework(hostFramework) {\n    this.clientContext.refreshUserAgent(hostFramework);\n  }\n}","map":{"version":3,"names":["Database","Databases","Offer","Offers","ClientContext","parseConnectionString","Constants","getUserAgent","determineDiagnosticLevel","getDiagnosticLevelFromEnvironment","DiagnosticNodeType","defaultConnectionPolicy","EncryptionManager","GlobalEndpointManager","ResourceResponse","checkURL","getEmptyCosmosDiagnostics","withDiagnostics","CosmosClient","constructor","optionsOrConnectionString","connectionString","endpoint","key","Error","clientEncryptionOptions","keyEncryptionKeyResolver","encryptionKeyTimeToLiveInSeconds","encryptionManager","clientConfig","initializeClientConfigDiagnostic","connectionPolicy","Object","assign","defaultHeaders","HttpHeaders","CacheControl","Version","CurrentVersion","consistencyLevel","undefined","ConsistencyLevel","throughputBucket","ThroughputBucket","userAgent","userAgentSuffix","UserAgent","CustomUserAgent","globalEndpointManager","diagnosticNode","opts","getDatabaseAccountInternal","clientContext","diagnosticLevel","_a","enableEndpointDiscovery","_b","enableBackgroundEndpointRefreshing","backgroundRefreshEndpointList","endpointRefreshRateInMs","databases","offers","resourceTokensConfigured","resourceTokens","tokenProviderConfigured","tokenProvider","aadCredentialsConfigured","aadCredentials","connectionPolicyConfigured","agentConfigured","agent","pluginsConfigured","plugins","sDKVersion","SDKVersion","getDatabaseAccount","options","response","result","headers","code","substatus","getWriteEndpoint","getReadEndpoint","getWriteEndpoints","getReadEndpoints","database","id","offer","dispose","clearTimeout","endpointRefresher","enableEncryption","encryptionKeyStoreProvider","cacheRefresher","protectedDataEncryptionKeyCache","refreshRate","setInterval","refreshEndpointList","BACKGROUND_REFRESH_THREAD","e","console","warn","unref","updateHostFramework","hostFramework","refreshUserAgent"],"sources":["/Users/eimis/test-server/Azure Hackthons/azure-cloud-architecture-game /node_modules/@azure/cosmos/src/CosmosClient.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { Database, Databases } from \"./client/Database\";\nimport { Offer, Offers } from \"./client/Offer\";\nimport { ClientContext } from \"./ClientContext\";\nimport { parseConnectionString } from \"./common\";\nimport { Constants } from \"./common/constants\";\nimport { getUserAgent } from \"./common/platform\";\nimport type { CosmosClientOptions } from \"./CosmosClientOptions\";\nimport type { ClientConfigDiagnostic } from \"./CosmosDiagnostics\";\nimport { determineDiagnosticLevel, getDiagnosticLevelFromEnvironment } from \"./diagnostics\";\nimport { DiagnosticNodeInternal, DiagnosticNodeType } from \"./diagnostics/DiagnosticNodeInternal\";\nimport { DatabaseAccount, defaultConnectionPolicy } from \"./documents\";\nimport { EncryptionManager } from \"./encryption/EncryptionManager\";\nimport { GlobalEndpointManager } from \"./globalEndpointManager\";\nimport type { RequestOptions } from \"./request\";\nimport { ResourceResponse } from \"./request\";\nimport { checkURL } from \"./utils/checkURL\";\nimport { getEmptyCosmosDiagnostics, withDiagnostics } from \"./utils/diagnostics\";\n\n/**\n * Provides a client-side logical representation of the Azure Cosmos DB database account.\n * This client is used to configure and execute requests in the Azure Cosmos DB database service.\n * @example Instantiate a client and create a new database\n * ```typescript\n * const client = new CosmosClient({endpoint: \"<URL HERE>\", key: \"<KEY HERE>\"});\n * await client.databases.create({id: \"<database name here>\"});\n * ```\n * @example Instantiate a client with custom Connection Policy\n * ```typescript\n * const client = new CosmosClient({\n *    endpoint: \"<URL HERE>\",\n *    key: \"<KEY HERE>\",\n *    connectionPolicy: {\n *     requestTimeout: 10000,\n *    },\n * });\n * ```\n */\nexport class CosmosClient {\n  /**\n   * Used for creating new databases, or querying/reading all databases.\n   *\n   * Use `.database(id)` to read, replace, or delete a specific, existing database by id.\n   *\n   * @example Create a new database\n   * ```typescript\n   * const {resource: databaseDefinition, database} = await client.databases.create({id: \"<name here>\"});\n   * ```\n   */\n  public readonly databases: Databases;\n  /**\n   * Used for querying & reading all offers.\n   *\n   * Use `.offer(id)` to read, or replace existing offers.\n   */\n  public readonly offers: Offers;\n  private clientContext: ClientContext;\n  private endpointRefresher: NodeJS.Timeout;\n  /**\n   * @internal\n   */\n  private encryptionManager: EncryptionManager;\n  /**\n   * Creates a new {@link CosmosClient} object from a connection string. Your database connection string can be found in the Azure Portal\n   */\n  constructor(connectionString: string);\n  /**\n   * Creates a new {@link CosmosClient} object. See {@link CosmosClientOptions} for more details on what options you can use.\n   * @param options - bag of options; require at least endpoint and auth to be configured\n   */\n  constructor(options: CosmosClientOptions);\n  constructor(optionsOrConnectionString: string | CosmosClientOptions) {\n    if (typeof optionsOrConnectionString === \"string\") {\n      optionsOrConnectionString = parseConnectionString(optionsOrConnectionString);\n    } else if (optionsOrConnectionString.connectionString) {\n      const { endpoint, key } = parseConnectionString(optionsOrConnectionString.connectionString);\n      optionsOrConnectionString.endpoint = endpoint;\n      optionsOrConnectionString.key = key;\n    }\n\n    const endpoint = checkURL(optionsOrConnectionString.endpoint);\n    if (!endpoint) {\n      throw new Error(\"Invalid endpoint specified\");\n    }\n\n    if (optionsOrConnectionString.clientEncryptionOptions) {\n      if (!optionsOrConnectionString.clientEncryptionOptions.keyEncryptionKeyResolver) {\n        throw new Error(\n          \"KeyEncryptionKeyResolver needs to be provided to enable client-side encryption.\",\n        );\n      }\n      if (\n        optionsOrConnectionString.clientEncryptionOptions.encryptionKeyTimeToLiveInSeconds &&\n        optionsOrConnectionString.clientEncryptionOptions.encryptionKeyTimeToLiveInSeconds < 60\n      ) {\n        throw new Error(\"EncryptionKeyTimeToLiveInSeconds needs to be >= 60 seconds.\");\n      }\n      this.encryptionManager = new EncryptionManager(\n        optionsOrConnectionString.clientEncryptionOptions.keyEncryptionKeyResolver,\n        optionsOrConnectionString.clientEncryptionOptions.encryptionKeyTimeToLiveInSeconds,\n      );\n    }\n\n    const clientConfig: ClientConfigDiagnostic =\n      this.initializeClientConfigDiagnostic(optionsOrConnectionString);\n\n    optionsOrConnectionString.connectionPolicy = Object.assign(\n      {},\n      defaultConnectionPolicy,\n      optionsOrConnectionString.connectionPolicy,\n    );\n\n    optionsOrConnectionString.defaultHeaders = optionsOrConnectionString.defaultHeaders || {};\n    optionsOrConnectionString.defaultHeaders[Constants.HttpHeaders.CacheControl] = \"no-cache\";\n    optionsOrConnectionString.defaultHeaders[Constants.HttpHeaders.Version] =\n      Constants.CurrentVersion;\n    if (optionsOrConnectionString.consistencyLevel !== undefined) {\n      optionsOrConnectionString.defaultHeaders[Constants.HttpHeaders.ConsistencyLevel] =\n        optionsOrConnectionString.consistencyLevel;\n    }\n\n    if (optionsOrConnectionString.throughputBucket !== undefined) {\n      optionsOrConnectionString.defaultHeaders[Constants.HttpHeaders.ThroughputBucket] =\n        optionsOrConnectionString.throughputBucket;\n    }\n\n    const userAgent = getUserAgent(optionsOrConnectionString.userAgentSuffix);\n    optionsOrConnectionString.defaultHeaders[Constants.HttpHeaders.UserAgent] = userAgent;\n    optionsOrConnectionString.defaultHeaders[Constants.HttpHeaders.CustomUserAgent] = userAgent;\n\n    const globalEndpointManager = new GlobalEndpointManager(\n      optionsOrConnectionString,\n      async (diagnosticNode: DiagnosticNodeInternal, opts: RequestOptions) =>\n        this.getDatabaseAccountInternal(diagnosticNode, opts),\n    );\n\n    this.clientContext = new ClientContext(\n      optionsOrConnectionString,\n      globalEndpointManager,\n      clientConfig,\n      determineDiagnosticLevel(\n        optionsOrConnectionString.diagnosticLevel,\n        getDiagnosticLevelFromEnvironment(),\n      ),\n    );\n    if (\n      optionsOrConnectionString.connectionPolicy?.enableEndpointDiscovery &&\n      optionsOrConnectionString.connectionPolicy?.enableBackgroundEndpointRefreshing\n    ) {\n      this.backgroundRefreshEndpointList(\n        globalEndpointManager,\n        optionsOrConnectionString.connectionPolicy.endpointRefreshRateInMs ||\n          defaultConnectionPolicy.endpointRefreshRateInMs,\n      );\n    }\n\n    this.databases = new Databases(this, this.clientContext, this.encryptionManager);\n    this.offers = new Offers(this, this.clientContext);\n  }\n\n  private initializeClientConfigDiagnostic(\n    optionsOrConnectionString: CosmosClientOptions,\n  ): ClientConfigDiagnostic {\n    return {\n      endpoint: optionsOrConnectionString.endpoint,\n      resourceTokensConfigured: optionsOrConnectionString.resourceTokens !== undefined,\n      tokenProviderConfigured: optionsOrConnectionString.tokenProvider !== undefined,\n      aadCredentialsConfigured: optionsOrConnectionString.aadCredentials !== undefined,\n      connectionPolicyConfigured: optionsOrConnectionString.connectionPolicy !== undefined,\n      consistencyLevel: optionsOrConnectionString.consistencyLevel,\n      defaultHeaders: optionsOrConnectionString.defaultHeaders,\n      agentConfigured: optionsOrConnectionString.agent !== undefined,\n      userAgentSuffix: optionsOrConnectionString.userAgentSuffix,\n      diagnosticLevel: optionsOrConnectionString.diagnosticLevel,\n      pluginsConfigured: optionsOrConnectionString.plugins !== undefined,\n      sDKVersion: Constants.SDKVersion,\n    };\n  }\n\n  /**\n   * Get information about the current {@link DatabaseAccount} (including which regions are supported, etc.)\n   */\n  public async getDatabaseAccount(\n    options?: RequestOptions,\n  ): Promise<ResourceResponse<DatabaseAccount>> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      return this.getDatabaseAccountInternal(diagnosticNode, options);\n    }, this.clientContext);\n  }\n\n  /**\n   * @hidden\n   */\n  public async getDatabaseAccountInternal(\n    diagnosticNode: DiagnosticNodeInternal,\n    options?: RequestOptions,\n  ): Promise<ResourceResponse<DatabaseAccount>> {\n    const response = await this.clientContext.getDatabaseAccount(diagnosticNode, options);\n    return new ResourceResponse<DatabaseAccount>(\n      response.result,\n      response.headers,\n      response.code,\n      getEmptyCosmosDiagnostics(),\n      response.substatus,\n    );\n  }\n\n  /**\n   * Gets the currently used write endpoint url. Useful for troubleshooting purposes.\n   *\n   * The url may contain a region suffix (e.g. \"-eastus\") if we're using location specific endpoints.\n   */\n  public async getWriteEndpoint(): Promise<string> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      return this.clientContext.getWriteEndpoint(diagnosticNode);\n    }, this.clientContext);\n  }\n\n  /**\n   * Gets the currently used read endpoint. Useful for troubleshooting purposes.\n   *\n   * The url may contain a region suffix (e.g. \"-eastus\") if we're using location specific endpoints.\n   */\n  public async getReadEndpoint(): Promise<string> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      return this.clientContext.getReadEndpoint(diagnosticNode);\n    }, this.clientContext);\n  }\n\n  /**\n   * Gets the known write endpoints. Useful for troubleshooting purposes.\n   *\n   * The urls may contain a region suffix (e.g. \"-eastus\") if we're using location specific endpoints.\n   */\n  public getWriteEndpoints(): Promise<readonly string[]> {\n    return this.clientContext.getWriteEndpoints();\n  }\n\n  /**\n   * Gets the currently used read endpoint. Useful for troubleshooting purposes.\n   *\n   * The url may contain a region suffix (e.g. \"-eastus\") if we're using location specific endpoints.\n   */\n  public getReadEndpoints(): Promise<readonly string[]> {\n    return this.clientContext.getReadEndpoints();\n  }\n\n  /**\n   * Used for reading, updating, or deleting a existing database by id or accessing containers belonging to that database.\n   *\n   * This does not make a network call. Use `.read` to get info about the database after getting the {@link Database} object.\n   *\n   * @param id - The id of the database.\n   * @example Create a new container off of an existing database\n   * ```typescript\n   * const container = client.database(\"<database id>\").containers.create(\"<container id>\");\n   * ```\n   *\n   * @example Delete an existing database\n   * ```typescript\n   * await client.database(\"<id here>\").delete();\n   * ```\n   */\n  public database(id: string): Database {\n    return new Database(this, id, this.clientContext, this.encryptionManager);\n  }\n\n  /**\n   * Used for reading, or updating a existing offer by id.\n   * @param id - The id of the offer.\n   */\n  public offer(id: string): Offer {\n    return new Offer(this, id, this.clientContext);\n  }\n\n  /**\n   * Clears background endpoint refresher. Use client.dispose() when destroying the CosmosClient within another process.\n   */\n  public dispose(): void {\n    clearTimeout(this.endpointRefresher);\n    if (this.clientContext.enableEncryption) {\n      clearTimeout(this.encryptionManager.encryptionKeyStoreProvider.cacheRefresher);\n      clearTimeout(this.encryptionManager.protectedDataEncryptionKeyCache.cacheRefresher);\n    }\n  }\n\n  private async backgroundRefreshEndpointList(\n    globalEndpointManager: GlobalEndpointManager,\n    refreshRate: number,\n  ) {\n    this.endpointRefresher = setInterval(() => {\n      try {\n        return withDiagnostics(\n          async (diagnosticNode: DiagnosticNodeInternal) => {\n            return globalEndpointManager.refreshEndpointList(diagnosticNode);\n          },\n          this.clientContext,\n          DiagnosticNodeType.BACKGROUND_REFRESH_THREAD,\n        );\n      } catch (e: any) {\n        console.warn(\"Failed to refresh endpoints\", e);\n      }\n    }, refreshRate);\n    if (this.endpointRefresher.unref && typeof this.endpointRefresher.unref === \"function\") {\n      this.endpointRefresher.unref();\n    }\n  }\n\n  /**\n   * Update the host framework. If provided host framework will be used to generate the defualt SDK user agent.\n   * @param hostFramework - A custom string.\n   * @internal\n   */\n  public async updateHostFramework(hostFramework: string): Promise<void> {\n    this.clientContext.refreshUserAgent(hostFramework);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}