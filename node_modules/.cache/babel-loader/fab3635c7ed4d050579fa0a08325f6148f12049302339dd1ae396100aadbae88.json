{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { CosmosDiagnosticContext } from \"./CosmosDiagnosticsContext\";\nimport { ErrorResponse } from \"../request\";\nimport { CosmosDiagnostics, getRootNode } from \"../CosmosDiagnostics\";\nimport { getCurrentTimestampInMs } from \"../utils/time\";\nimport { CosmosDbDiagnosticLevel } from \"./CosmosDbDiagnosticLevel\";\nimport { Constants, prepareURL } from \"../common\";\nimport { allowTracing } from \"./diagnosticLevelComparator\";\nimport { randomUUID } from \"@azure/core-util\";\n/**\n * @hidden\n * This is Internal Representation for DiagnosticNode. It contains useful helper functions to collect\n * diagnostic information throughout the lifetime of Diagnostic session.\n * The functions toDiagnosticNode() & toDiagnostic() are given to convert it to public facing counterpart.\n */\nexport class DiagnosticNodeInternal {\n  /**\n   * @internal\n   */\n  constructor(diagnosticLevel, type, parent, data = {}, startTimeUTCInMs = getCurrentTimestampInMs(), ctx = new CosmosDiagnosticContext()) {\n    this.id = randomUUID();\n    this.nodeType = type;\n    this.startTimeUTCInMs = startTimeUTCInMs;\n    this.data = data;\n    this.children = [];\n    this.durationInMs = 0;\n    this.parent = parent;\n    this.diagnosticCtx = ctx;\n    this.diagnosticLevel = diagnosticLevel;\n    // Initialize EncryptionDiagnostics\n    this.encryptionDiagnostics = {\n      encryptContent: {},\n      decryptContent: {},\n      processingDurationInMs: 0\n    };\n  }\n  /**\n   * @internal\n   */\n  addLog(msg) {\n    if (!this.data.log) {\n      this.data.log = [];\n    }\n    this.data.log.push(msg);\n  }\n  /**\n   * @internal\n   */\n  sanitizeHeaders(headers) {\n    return headers;\n  }\n  /**\n   * Updated durationInMs for node, based on endTimeUTCInMs provided.\n   * @internal\n   */\n  updateTimestamp(endTimeUTCInMs = getCurrentTimestampInMs()) {\n    this.durationInMs = endTimeUTCInMs - this.startTimeUTCInMs;\n  }\n  /**\n   * @internal\n   */\n  recordSuccessfulNetworkCall(startTimeUTCInMs, requestContext, pipelineResponse, substatus, url) {\n    const responseHeaders = pipelineResponse.headers.toJSON();\n    const gatewayRequest = {\n      activityId: responseHeaders[Constants.HttpHeaders.ActivityId],\n      correlateActivityId: requestContext.headers[Constants.HttpHeaders.CorrelatedActivityId],\n      startTimeUTCInMs,\n      durationInMs: getCurrentTimestampInMs() - startTimeUTCInMs,\n      statusCode: pipelineResponse.status,\n      subStatusCode: substatus,\n      requestPayloadLengthInBytes: calculateRequestPayloadLength(requestContext),\n      responsePayloadLengthInBytes: calculateResponsePayloadLength(pipelineResponse),\n      operationType: requestContext.operationType,\n      resourceType: requestContext.resourceType,\n      partitionKeyRangeId: requestContext.partitionKeyRangeId\n    };\n    let requestData = {\n      OperationType: gatewayRequest.operationType,\n      resourceType: gatewayRequest.resourceType,\n      requestPayloadLengthInBytes: gatewayRequest.requestPayloadLengthInBytes\n    };\n    if (allowTracing(CosmosDbDiagnosticLevel.debugUnsafe, this.diagnosticLevel)) {\n      requestData = Object.assign(Object.assign({}, requestData), {\n        headers: this.sanitizeHeaders(requestContext.headers),\n        requestBody: requestContext.body,\n        responseBody: pipelineResponse.bodyAsText,\n        url: url\n      });\n    }\n    this.addData({\n      requestPayloadLengthInBytes: gatewayRequest.requestPayloadLengthInBytes,\n      responsePayloadLengthInBytes: gatewayRequest.responsePayloadLengthInBytes,\n      startTimeUTCInMs: gatewayRequest.startTimeUTCInMs,\n      durationInMs: gatewayRequest.durationInMs,\n      requestData\n    });\n    this.diagnosticCtx.recordNetworkCall(gatewayRequest);\n  }\n  /**\n   * @internal\n   */\n  recordFailedNetworkCall(startTimeUTCInMs, requestContext, retryAttemptNumber, statusCode, substatusCode, responseHeaders) {\n    this.addData({\n      failedAttempty: true\n    });\n    const requestPayloadLengthInBytes = calculateRequestPayloadLength(requestContext);\n    this.diagnosticCtx.recordFailedAttempt({\n      activityId: responseHeaders[Constants.HttpHeaders.ActivityId],\n      correlatedActivityId: requestContext.headers[Constants.HttpHeaders.CorrelatedActivityId],\n      startTimeUTCInMs,\n      durationInMs: getCurrentTimestampInMs() - startTimeUTCInMs,\n      statusCode,\n      subStatusCode: substatusCode,\n      requestPayloadLengthInBytes,\n      responsePayloadLengthInBytes: 0,\n      operationType: requestContext.operationType,\n      resourceType: requestContext.resourceType\n    }, retryAttemptNumber);\n    let requestData = {\n      OperationType: requestContext.operationType,\n      resourceType: requestContext.resourceType,\n      requestPayloadLengthInBytes\n    };\n    if (allowTracing(CosmosDbDiagnosticLevel.debugUnsafe, this.diagnosticLevel)) {\n      requestData = Object.assign(Object.assign({}, requestData), {\n        headers: this.sanitizeHeaders(requestContext.headers),\n        requestBody: requestContext.body,\n        url: prepareURL(requestContext.endpoint, requestContext.path)\n      });\n    }\n    this.addData({\n      failedAttempty: true,\n      requestData\n    });\n  }\n  /**\n   * @internal\n   */\n  recordEndpointResolution(location) {\n    this.addData({\n      selectedLocation: location\n    });\n    this.diagnosticCtx.recordEndpointResolution(location);\n  }\n  /**\n   * @internal\n   */\n  addData(data, msg, level = this.diagnosticLevel) {\n    if (level !== CosmosDbDiagnosticLevel.info) {\n      this.data = Object.assign(Object.assign({}, this.data), data);\n      if (msg) {\n        this.addLog(msg);\n      }\n    }\n  }\n  /**\n   * Merge given DiagnosticNodeInternal's context to current node's DiagnosticContext, Treating GatewayRequests of\n   * given DiagnosticContext, as metadata requests. Given DiagnosticNodeInternal becomes a child of this node.\n   * @internal\n   */\n  addChildNode(child, level, metadataType) {\n    this.diagnosticCtx.mergeDiagnostics(child.diagnosticCtx, metadataType);\n    if (allowTracing(level, this.diagnosticLevel)) {\n      child.parent = this;\n      this.children.push(child);\n    }\n    return child;\n  }\n  /**\n   * @internal\n   */\n  initializeChildNode(type, level, data = {}) {\n    if (allowTracing(level, this.diagnosticLevel)) {\n      const child = new DiagnosticNodeInternal(this.diagnosticLevel, type, this, data, getCurrentTimestampInMs(), this.diagnosticCtx);\n      this.children.push(child);\n      return child;\n    } else {\n      return this;\n    }\n  }\n  /**\n   * @internal\n   */\n  recordQueryResult(resources, level) {\n    var _a;\n    if (allowTracing(level, this.diagnosticLevel)) {\n      const previousCount = (_a = this.data.queryRecordsRead) !== null && _a !== void 0 ? _a : 0;\n      if (Array.isArray(resources)) {\n        this.data.queryRecordsRead = previousCount + resources.length;\n      }\n    }\n  }\n  /**\n   * @internal\n   * record startTime for encryption in an operation\n   */\n  beginEncryptionDiagnostics(operation) {\n    const startTime = getCurrentTimestampInMs();\n    switch (operation) {\n      case Constants.Encryption.DiagnosticsEncryptOperation:\n        this.encryptionDiagnostics.encryptContent[Constants.Encryption.DiagnosticsStartTime] = startTime;\n        break;\n      case Constants.Encryption.DiagnosticsDecryptOperation:\n        this.encryptionDiagnostics.decryptContent[Constants.Encryption.DiagnosticsStartTime] = startTime;\n        break;\n      default:\n        throw new ErrorResponse(\"Invalid operation type for encryption diagnostics\");\n    }\n  }\n  /**\n   * @internal\n   * record duration from startTime and properties count for encryption in an operation\n   */\n  endEncryptionDiagnostics(operation, propertiesCount) {\n    const endTime = getCurrentTimestampInMs();\n    let processingDuration = 0;\n    switch (operation) {\n      case Constants.Encryption.DiagnosticsEncryptOperation:\n        processingDuration = endTime - this.encryptionDiagnostics.encryptContent[Constants.Encryption.DiagnosticsStartTime];\n        this.encryptionDiagnostics.encryptContent[Constants.Encryption.DiagnosticsDuration] = processingDuration;\n        // will be undefined in case of bulk/batch\n        if (propertiesCount !== undefined) {\n          this.encryptionDiagnostics.encryptContent[Constants.Encryption.DiagnosticsPropertiesEncryptedCount] = propertiesCount;\n        }\n        break;\n      case Constants.Encryption.DiagnosticsDecryptOperation:\n        processingDuration = endTime - this.encryptionDiagnostics.decryptContent[Constants.Encryption.DiagnosticsStartTime];\n        this.encryptionDiagnostics.decryptContent[Constants.Encryption.DiagnosticsDuration] = processingDuration;\n        if (propertiesCount !== undefined) {\n          this.encryptionDiagnostics.decryptContent[Constants.Encryption.DiagnosticsPropertiesDecryptedCount] = propertiesCount;\n        }\n        break;\n      default:\n        throw new ErrorResponse(\"Invalid operation type for encryption diagnostics\");\n    }\n    this.diagnosticCtx.recordEncryptionDiagnostics(this.encryptionDiagnostics);\n  }\n  /**\n   * Convert DiagnosticNodeInternal (internal representation) to DiagnosticNode (public, sanitized representation)\n   * @internal\n   */\n  toDiagnosticNode() {\n    return {\n      id: this.id,\n      nodeType: this.nodeType,\n      children: this.children.map(child => child.toDiagnosticNode()),\n      data: this.data,\n      startTimeUTCInMs: this.startTimeUTCInMs,\n      durationInMs: this.durationInMs\n    };\n  }\n  /**\n   * Convert to CosmosDiagnostics\n   * @internal\n   */\n  toDiagnostic(clientConfigDiagnostic) {\n    const rootNode = getRootNode(this);\n    const diagnostiNode = allowTracing(CosmosDbDiagnosticLevel.debug, this.diagnosticLevel) ? rootNode.toDiagnosticNode() : undefined;\n    const clientConfig = allowTracing(CosmosDbDiagnosticLevel.debug, this.diagnosticLevel) ? clientConfigDiagnostic : undefined;\n    const cosmosDiagnostic = new CosmosDiagnostics(this.diagnosticCtx.getClientSideStats(), diagnostiNode, clientConfig);\n    return cosmosDiagnostic;\n  }\n}\n/**\n * @hidden\n */\nexport var DiagnosticNodeType;\n(function (DiagnosticNodeType) {\n  DiagnosticNodeType[\"CLIENT_REQUEST_NODE\"] = \"CLIENT_REQUEST_NODE\";\n  DiagnosticNodeType[\"METADATA_REQUEST_NODE\"] = \"METADATA_REQUEST_NODE\";\n  DiagnosticNodeType[\"HTTP_REQUEST\"] = \"HTTP_REQUEST\";\n  DiagnosticNodeType[\"BATCH_REQUEST\"] = \"BATCH_REQUEST\";\n  DiagnosticNodeType[\"PARALLEL_QUERY_NODE\"] = \"PARALLEL_QUERY_NODE\";\n  DiagnosticNodeType[\"DEFAULT_QUERY_NODE\"] = \"DEFAULT_QUERY_NODE\";\n  DiagnosticNodeType[\"QUERY_REPAIR_NODE\"] = \"QUERY_REPAIR_NODE\";\n  DiagnosticNodeType[\"BACKGROUND_REFRESH_THREAD\"] = \"BACKGROUND_REFRESH_THREAD\";\n  DiagnosticNodeType[\"REQUEST_ATTEMPTS\"] = \"REQUEST_ATTEMPTS\";\n})(DiagnosticNodeType || (DiagnosticNodeType = {}));\nfunction calculateResponsePayloadLength(response) {\n  var _a;\n  return ((_a = response === null || response === void 0 ? void 0 : response.bodyAsText) === null || _a === void 0 ? void 0 : _a.length) || 0;\n}\nfunction calculateRequestPayloadLength(requestContext) {\n  return requestContext.body ? requestContext.body.length : 0;\n}","map":{"version":3,"names":["CosmosDiagnosticContext","ErrorResponse","CosmosDiagnostics","getRootNode","getCurrentTimestampInMs","CosmosDbDiagnosticLevel","Constants","prepareURL","allowTracing","randomUUID","DiagnosticNodeInternal","constructor","diagnosticLevel","type","parent","data","startTimeUTCInMs","ctx","id","nodeType","children","durationInMs","diagnosticCtx","encryptionDiagnostics","encryptContent","decryptContent","processingDurationInMs","addLog","msg","log","push","sanitizeHeaders","headers","updateTimestamp","endTimeUTCInMs","recordSuccessfulNetworkCall","requestContext","pipelineResponse","substatus","url","responseHeaders","toJSON","gatewayRequest","activityId","HttpHeaders","ActivityId","correlateActivityId","CorrelatedActivityId","statusCode","status","subStatusCode","requestPayloadLengthInBytes","calculateRequestPayloadLength","responsePayloadLengthInBytes","calculateResponsePayloadLength","operationType","resourceType","partitionKeyRangeId","requestData","OperationType","debugUnsafe","Object","assign","requestBody","body","responseBody","bodyAsText","addData","recordNetworkCall","recordFailedNetworkCall","retryAttemptNumber","substatusCode","failedAttempty","recordFailedAttempt","correlatedActivityId","endpoint","path","recordEndpointResolution","location","selectedLocation","level","info","addChildNode","child","metadataType","mergeDiagnostics","initializeChildNode","recordQueryResult","resources","previousCount","_a","queryRecordsRead","Array","isArray","length","beginEncryptionDiagnostics","operation","startTime","Encryption","DiagnosticsEncryptOperation","DiagnosticsStartTime","DiagnosticsDecryptOperation","endEncryptionDiagnostics","propertiesCount","endTime","processingDuration","DiagnosticsDuration","undefined","DiagnosticsPropertiesEncryptedCount","DiagnosticsPropertiesDecryptedCount","recordEncryptionDiagnostics","toDiagnosticNode","map","toDiagnostic","clientConfigDiagnostic","rootNode","diagnostiNode","debug","clientConfig","cosmosDiagnostic","getClientSideStats","DiagnosticNodeType","response"],"sources":["/Users/eimis/test-server/Azure Hackthons/azure-cloud-architecture-game /node_modules/@azure/cosmos/src/diagnostics/DiagnosticNodeInternal.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { CosmosDiagnosticContext } from \"./CosmosDiagnosticsContext\";\nimport { ErrorResponse, RequestContext } from \"../request\";\nimport {\n  DiagnosticNode,\n  EncryptionDiagnostics,\n  MetadataLookUpType,\n  ClientConfigDiagnostic,\n} from \"../CosmosDiagnostics\";\nimport { CosmosDiagnostics, getRootNode } from \"../CosmosDiagnostics\";\nimport { getCurrentTimestampInMs } from \"../utils/time\";\nimport { CosmosDbDiagnosticLevel } from \"./CosmosDbDiagnosticLevel\";\nimport type { CosmosHeaders } from \"../queryExecutionContext/CosmosHeaders\";\nimport type { HttpHeaders, PipelineResponse } from \"@azure/core-rest-pipeline\";\nimport type { OperationType, ResourceType } from \"../common\";\nimport { Constants, prepareURL } from \"../common\";\nimport { allowTracing } from \"./diagnosticLevelComparator\";\nimport { randomUUID } from \"@azure/core-util\";\n\n/**\n * @hidden\n * This is Internal Representation for DiagnosticNode. It contains useful helper functions to collect\n * diagnostic information throughout the lifetime of Diagnostic session.\n * The functions toDiagnosticNode() & toDiagnostic() are given to convert it to public facing counterpart.\n */\nexport class DiagnosticNodeInternal implements DiagnosticNode {\n  public id: string;\n  public nodeType: DiagnosticNodeType;\n  public parent: DiagnosticNodeInternal;\n  public children: DiagnosticNodeInternal[];\n  public data: Partial<DiagnosticDataValue>;\n  public startTimeUTCInMs: number;\n  public durationInMs: number;\n  public diagnosticLevel: CosmosDbDiagnosticLevel;\n  private diagnosticCtx: CosmosDiagnosticContext;\n  private encryptionDiagnostics: EncryptionDiagnostics;\n\n  /**\n   * @internal\n   */\n  constructor(\n    diagnosticLevel: CosmosDbDiagnosticLevel,\n    type: DiagnosticNodeType,\n    parent: DiagnosticNodeInternal,\n    data: Partial<DiagnosticDataValue> = {},\n    startTimeUTCInMs: number = getCurrentTimestampInMs(),\n    ctx: CosmosDiagnosticContext = new CosmosDiagnosticContext(),\n  ) {\n    this.id = randomUUID();\n    this.nodeType = type;\n    this.startTimeUTCInMs = startTimeUTCInMs;\n    this.data = data;\n    this.children = [];\n    this.durationInMs = 0;\n    this.parent = parent;\n    this.diagnosticCtx = ctx;\n    this.diagnosticLevel = diagnosticLevel;\n\n    // Initialize EncryptionDiagnostics\n    this.encryptionDiagnostics = {\n      encryptContent: {},\n      decryptContent: {},\n      processingDurationInMs: 0,\n    };\n  }\n\n  /**\n   * @internal\n   */\n  private addLog(msg: string): void {\n    if (!this.data.log) {\n      this.data.log = [];\n    }\n    this.data.log.push(msg);\n  }\n\n  /**\n   * @internal\n   */\n  private sanitizeHeaders(headers?: CosmosHeaders | HttpHeaders): CosmosHeaders | HttpHeaders {\n    return headers;\n  }\n\n  /**\n   * Updated durationInMs for node, based on endTimeUTCInMs provided.\n   * @internal\n   */\n  public updateTimestamp(endTimeUTCInMs: number = getCurrentTimestampInMs()): void {\n    this.durationInMs = endTimeUTCInMs - this.startTimeUTCInMs;\n  }\n\n  /**\n   * @internal\n   */\n  public recordSuccessfulNetworkCall(\n    startTimeUTCInMs: number,\n    requestContext: RequestContext,\n    pipelineResponse: PipelineResponse,\n    substatus: number,\n    url: string,\n  ): void {\n    const responseHeaders = pipelineResponse.headers.toJSON();\n    const gatewayRequest = {\n      activityId: responseHeaders[Constants.HttpHeaders.ActivityId],\n      correlateActivityId: requestContext.headers[Constants.HttpHeaders.CorrelatedActivityId],\n      startTimeUTCInMs,\n      durationInMs: getCurrentTimestampInMs() - startTimeUTCInMs,\n      statusCode: pipelineResponse.status,\n      subStatusCode: substatus,\n      requestPayloadLengthInBytes: calculateRequestPayloadLength(requestContext),\n      responsePayloadLengthInBytes: calculateResponsePayloadLength(pipelineResponse),\n      operationType: requestContext.operationType,\n      resourceType: requestContext.resourceType,\n      partitionKeyRangeId: requestContext.partitionKeyRangeId,\n    };\n    let requestData: any = {\n      OperationType: gatewayRequest.operationType,\n      resourceType: gatewayRequest.resourceType,\n      requestPayloadLengthInBytes: gatewayRequest.requestPayloadLengthInBytes,\n    };\n\n    if (allowTracing(CosmosDbDiagnosticLevel.debugUnsafe, this.diagnosticLevel)) {\n      requestData = {\n        ...requestData,\n        headers: this.sanitizeHeaders(requestContext.headers),\n        requestBody: requestContext.body,\n        responseBody: pipelineResponse.bodyAsText,\n        url: url,\n      };\n    }\n    this.addData({\n      requestPayloadLengthInBytes: gatewayRequest.requestPayloadLengthInBytes,\n      responsePayloadLengthInBytes: gatewayRequest.responsePayloadLengthInBytes,\n      startTimeUTCInMs: gatewayRequest.startTimeUTCInMs,\n      durationInMs: gatewayRequest.durationInMs,\n      requestData,\n    });\n    this.diagnosticCtx.recordNetworkCall(gatewayRequest);\n  }\n\n  /**\n   * @internal\n   */\n  public recordFailedNetworkCall(\n    startTimeUTCInMs: number,\n    requestContext: RequestContext,\n    retryAttemptNumber: number,\n    statusCode: number,\n    substatusCode: number,\n    responseHeaders: CosmosHeaders,\n  ): void {\n    this.addData({ failedAttempty: true });\n    const requestPayloadLengthInBytes = calculateRequestPayloadLength(requestContext);\n    this.diagnosticCtx.recordFailedAttempt(\n      {\n        activityId: responseHeaders[Constants.HttpHeaders.ActivityId] as string,\n        correlatedActivityId: requestContext.headers[\n          Constants.HttpHeaders.CorrelatedActivityId\n        ] as string,\n        startTimeUTCInMs,\n        durationInMs: getCurrentTimestampInMs() - startTimeUTCInMs,\n        statusCode,\n        subStatusCode: substatusCode,\n        requestPayloadLengthInBytes,\n        responsePayloadLengthInBytes: 0,\n        operationType: requestContext.operationType,\n        resourceType: requestContext.resourceType,\n      },\n      retryAttemptNumber,\n    );\n    let requestData: any = {\n      OperationType: requestContext.operationType,\n      resourceType: requestContext.resourceType,\n      requestPayloadLengthInBytes,\n    };\n    if (allowTracing(CosmosDbDiagnosticLevel.debugUnsafe, this.diagnosticLevel)) {\n      requestData = {\n        ...requestData,\n        headers: this.sanitizeHeaders(requestContext.headers),\n        requestBody: requestContext.body,\n        url: prepareURL(requestContext.endpoint, requestContext.path),\n      };\n    }\n    this.addData({\n      failedAttempty: true,\n      requestData,\n    });\n  }\n\n  /**\n   * @internal\n   */\n  public recordEndpointResolution(location: string): void {\n    this.addData({ selectedLocation: location });\n    this.diagnosticCtx.recordEndpointResolution(location);\n  }\n\n  /**\n   * @internal\n   */\n  public addData(\n    data: Partial<DiagnosticDataValue>,\n    msg?: string,\n    level: CosmosDbDiagnosticLevel = this.diagnosticLevel,\n  ): void {\n    if (level !== CosmosDbDiagnosticLevel.info) {\n      this.data = { ...this.data, ...data };\n      if (msg) {\n        this.addLog(msg);\n      }\n    }\n  }\n\n  /**\n   * Merge given DiagnosticNodeInternal's context to current node's DiagnosticContext, Treating GatewayRequests of\n   * given DiagnosticContext, as metadata requests. Given DiagnosticNodeInternal becomes a child of this node.\n   * @internal\n   */\n  public addChildNode(\n    child: DiagnosticNodeInternal,\n    level: CosmosDbDiagnosticLevel,\n    metadataType?: MetadataLookUpType,\n  ): DiagnosticNodeInternal {\n    this.diagnosticCtx.mergeDiagnostics(child.diagnosticCtx, metadataType);\n    if (allowTracing(level, this.diagnosticLevel)) {\n      child.parent = this;\n      this.children.push(child);\n    }\n    return child;\n  }\n\n  /**\n   * @internal\n   */\n  public initializeChildNode(\n    type: DiagnosticNodeType,\n    level: CosmosDbDiagnosticLevel,\n    data: Partial<DiagnosticDataValue> = {},\n  ): DiagnosticNodeInternal {\n    if (allowTracing(level, this.diagnosticLevel)) {\n      const child = new DiagnosticNodeInternal(\n        this.diagnosticLevel,\n        type,\n        this,\n        data,\n        getCurrentTimestampInMs(),\n        this.diagnosticCtx,\n      );\n      this.children.push(child);\n      return child;\n    } else {\n      return this;\n    }\n  }\n\n  /**\n   * @internal\n   */\n  public recordQueryResult(resources: unknown, level: CosmosDbDiagnosticLevel): void {\n    if (allowTracing(level, this.diagnosticLevel)) {\n      const previousCount = this.data.queryRecordsRead ?? 0;\n      if (Array.isArray(resources)) {\n        this.data.queryRecordsRead = previousCount + resources.length;\n      }\n    }\n  }\n\n  /**\n   * @internal\n   * record startTime for encryption in an operation\n   */\n  public beginEncryptionDiagnostics(operation: string): void {\n    const startTime = getCurrentTimestampInMs();\n    switch (operation) {\n      case Constants.Encryption.DiagnosticsEncryptOperation:\n        this.encryptionDiagnostics.encryptContent[Constants.Encryption.DiagnosticsStartTime] =\n          startTime;\n        break;\n      case Constants.Encryption.DiagnosticsDecryptOperation:\n        this.encryptionDiagnostics.decryptContent[Constants.Encryption.DiagnosticsStartTime] =\n          startTime;\n        break;\n      default:\n        throw new ErrorResponse(\"Invalid operation type for encryption diagnostics\");\n    }\n  }\n  /**\n   * @internal\n   * record duration from startTime and properties count for encryption in an operation\n   */\n  public endEncryptionDiagnostics(operation: string, propertiesCount?: number): void {\n    const endTime = getCurrentTimestampInMs();\n    let processingDuration = 0;\n    switch (operation) {\n      case Constants.Encryption.DiagnosticsEncryptOperation:\n        processingDuration =\n          endTime -\n          this.encryptionDiagnostics.encryptContent[Constants.Encryption.DiagnosticsStartTime];\n        this.encryptionDiagnostics.encryptContent[Constants.Encryption.DiagnosticsDuration] =\n          processingDuration;\n        // will be undefined in case of bulk/batch\n        if (propertiesCount !== undefined) {\n          this.encryptionDiagnostics.encryptContent[\n            Constants.Encryption.DiagnosticsPropertiesEncryptedCount\n          ] = propertiesCount;\n        }\n        break;\n\n      case Constants.Encryption.DiagnosticsDecryptOperation:\n        processingDuration =\n          endTime -\n          this.encryptionDiagnostics.decryptContent[Constants.Encryption.DiagnosticsStartTime];\n        this.encryptionDiagnostics.decryptContent[Constants.Encryption.DiagnosticsDuration] =\n          processingDuration;\n        if (propertiesCount !== undefined) {\n          this.encryptionDiagnostics.decryptContent[\n            Constants.Encryption.DiagnosticsPropertiesDecryptedCount\n          ] = propertiesCount;\n        }\n        break;\n      default:\n        throw new ErrorResponse(\"Invalid operation type for encryption diagnostics\");\n    }\n    this.diagnosticCtx.recordEncryptionDiagnostics(this.encryptionDiagnostics);\n  }\n\n  /**\n   * Convert DiagnosticNodeInternal (internal representation) to DiagnosticNode (public, sanitized representation)\n   * @internal\n   */\n  public toDiagnosticNode(): DiagnosticNode {\n    return {\n      id: this.id,\n      nodeType: this.nodeType,\n      children: this.children.map((child) => child.toDiagnosticNode()),\n      data: this.data,\n      startTimeUTCInMs: this.startTimeUTCInMs,\n      durationInMs: this.durationInMs,\n    };\n  }\n\n  /**\n   * Convert to CosmosDiagnostics\n   * @internal\n   */\n  public toDiagnostic(clientConfigDiagnostic: ClientConfigDiagnostic): CosmosDiagnostics {\n    const rootNode = getRootNode(this);\n    const diagnostiNode = allowTracing(CosmosDbDiagnosticLevel.debug, this.diagnosticLevel)\n      ? rootNode.toDiagnosticNode()\n      : undefined;\n    const clientConfig = allowTracing(CosmosDbDiagnosticLevel.debug, this.diagnosticLevel)\n      ? clientConfigDiagnostic\n      : undefined;\n    const cosmosDiagnostic = new CosmosDiagnostics(\n      this.diagnosticCtx.getClientSideStats(),\n      diagnostiNode,\n      clientConfig,\n    );\n    return cosmosDiagnostic;\n  }\n}\n\n/**\n * @hidden\n */\nexport type DiagnosticDataValue = {\n  selectedLocation: string;\n  activityId: string;\n  requestAttempNumber: number;\n  requestPayloadLengthInBytes: number;\n  responsePayloadLengthInBytes: number;\n  responseStatus: number;\n  readFromCache: boolean;\n  operationType: OperationType;\n  metadatOperationType: MetadataLookUpType;\n  resourceType: ResourceType;\n  failedAttempty: boolean;\n  successfulRetryPolicy: string;\n  partitionKeyRangeId: string;\n  stateful: boolean;\n  queryRecordsRead: number;\n  queryMethodIdentifier: string;\n  log: string[];\n  failure: boolean;\n  startTimeUTCInMs: number;\n  durationInMs: number;\n  requestData: Partial<{\n    requestPayloadLengthInBytes: number;\n    responsePayloadLengthInBytes: number;\n    operationType: OperationType;\n    resourceType: ResourceType;\n    headers: CosmosHeaders;\n    requestBody: any;\n    responseBody: any;\n    url: string;\n  }>;\n};\n\n/**\n * @hidden\n */\nexport enum DiagnosticNodeType {\n  CLIENT_REQUEST_NODE = \"CLIENT_REQUEST_NODE\", // Top most node representing client operations.\n  METADATA_REQUEST_NODE = \"METADATA_REQUEST_NODE\", // Node representing a metadata request.\n  HTTP_REQUEST = \"HTTP_REQUEST\", // Node representing REST call to backend services.\n  BATCH_REQUEST = \"BATCH_REQUEST\", // Node representing batch request.\n  PARALLEL_QUERY_NODE = \"PARALLEL_QUERY_NODE\", // Node representing parallel query execution.\n  DEFAULT_QUERY_NODE = \"DEFAULT_QUERY_NODE\", // Node representing default query execution.\n  QUERY_REPAIR_NODE = \"QUERY_REPAIR_NODE\", // Node representing query repair.\n  BACKGROUND_REFRESH_THREAD = \"BACKGROUND_REFRESH_THREAD\", // Node representing background refresh.\n  REQUEST_ATTEMPTS = \"REQUEST_ATTEMPTS\", // Node representing request attempts.\n}\n\nfunction calculateResponsePayloadLength(response: PipelineResponse) {\n  return response?.bodyAsText?.length || 0;\n}\n\nfunction calculateRequestPayloadLength(requestContext: RequestContext) {\n  return requestContext.body ? requestContext.body.length : 0;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}