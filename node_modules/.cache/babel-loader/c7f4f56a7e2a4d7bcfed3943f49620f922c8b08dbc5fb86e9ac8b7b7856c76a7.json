{"ast":null,"code":"import { Constants, copyObject, createDocumentUri, getIdFromLink, getPathFromLink, isItemResourceValid, ResourceType, StatusCodes } from \"../../common\";\nimport { convertToInternalPartitionKey } from \"../../documents\";\nimport { ErrorResponse } from \"../../request\";\nimport { PatchOperationType } from \"../../utils/patch\";\nimport { ItemResponse } from \"./ItemResponse\";\nimport { getEmptyCosmosDiagnostics, withDiagnostics } from \"../../utils/diagnostics\";\nimport { setPartitionKeyIfUndefined } from \"../../extractPartitionKey\";\n/**\n * Used to perform operations on a specific item.\n *\n * @see {@link Items} for operations on all items; see `container.items`.\n */\nexport class Item {\n  /**\n   * Returns a reference URL to the resource. Used for linking in Permissions.\n   */\n  get url() {\n    return createDocumentUri(this.container.database.id, this.container.id, this.id);\n  }\n  /**\n   * @hidden\n   * @param container - The parent {@link Container}.\n   * @param id - The id of the given {@link Item}.\n   * @param partitionKey - The primary key of the given {@link Item} (only for partitioned containers).\n   */\n  constructor(container, id, clientContext, partitionKey) {\n    this.container = container;\n    this.id = id;\n    this.clientContext = clientContext;\n    this.partitionKey = partitionKey === undefined ? undefined : convertToInternalPartitionKey(partitionKey);\n  }\n  /**\n   * Read the item's definition.\n   *\n   * Any provided type, T, is not necessarily enforced by the SDK.\n   * You may get more or less properties and it's up to your logic to enforce it.\n   * If the type, T, is a class, it won't pass `typeof` comparisons, because it won't have a match prototype.\n   * It's recommended to only use interfaces.\n   *\n   * There is no set schema for JSON items. They may contain any number of custom properties.\n   *\n   * @param options - Additional options for the request\n   *\n   * @example Using custom type for response\n   * ```typescript\n   * interface TodoItem {\n   *   title: string;\n   *   done: bool;\n   *   id: string;\n   * }\n   *\n   * let item: TodoItem;\n   * ({body: item} = await item.read<TodoItem>());\n   * ```\n   */\n  async read(options = {}) {\n    return withDiagnostics(async diagnosticNode => {\n      this.partitionKey = await setPartitionKeyIfUndefined(diagnosticNode, this.container, this.partitionKey);\n      let url = this.url;\n      let partitionKey = this.partitionKey;\n      let response;\n      try {\n        if (this.clientContext.enableEncryption) {\n          await this.container.checkAndInitializeEncryption();\n          options.containerRid = this.container._rid;\n          let count = 0;\n          diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsEncryptOperation);\n          const {\n            partitionKeyList: encryptedPartitionKey,\n            encryptedCount\n          } = await this.container.encryptionProcessor.getEncryptedPartitionKeyValue(this.partitionKey);\n          partitionKey = encryptedPartitionKey;\n          count += encryptedCount;\n          if (await this.container.encryptionProcessor.isPathEncrypted(\"/id\")) {\n            url = await this.container.encryptionProcessor.getEncryptedUrl(this.url);\n            count++;\n          }\n          diagnosticNode.endEncryptionDiagnostics(Constants.Encryption.DiagnosticsEncryptOperation, count);\n        }\n        const path = getPathFromLink(url);\n        const id = getIdFromLink(url);\n        response = await this.clientContext.read({\n          path,\n          resourceType: ResourceType.item,\n          resourceId: id,\n          options,\n          partitionKey: partitionKey,\n          diagnosticNode\n        });\n      } catch (error) {\n        if (this.clientContext.enableEncryption) {\n          await this.container.throwIfRequestNeedsARetryPostPolicyRefresh(error);\n        }\n        if (error.code !== StatusCodes.NotFound) {\n          throw error;\n        }\n        response = error;\n      }\n      if (this.clientContext.enableEncryption) {\n        diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsDecryptOperation);\n        const {\n          body,\n          propertiesDecryptedCount\n        } = await this.container.encryptionProcessor.decrypt(response.result);\n        diagnosticNode.endEncryptionDiagnostics(Constants.Encryption.DiagnosticsDecryptOperation, propertiesDecryptedCount);\n        response.result = body;\n      }\n      return new ItemResponse(response.result, response.headers, response.code, response.substatus, this, getEmptyCosmosDiagnostics());\n    }, this.clientContext);\n  }\n  async replace(body, options = {}) {\n    return withDiagnostics(async diagnosticNode => {\n      this.partitionKey = await setPartitionKeyIfUndefined(diagnosticNode, this.container, this.partitionKey);\n      let partitionKey = this.partitionKey;\n      const err = {};\n      if (!isItemResourceValid(body, err)) {\n        throw err;\n      }\n      let url = this.url;\n      let response;\n      try {\n        if (this.clientContext.enableEncryption) {\n          // returns copy to avoid encryption of original body passed\n          body = copyObject(body);\n          options = options || {};\n          await this.container.checkAndInitializeEncryption();\n          options.containerRid = this.container._rid;\n          let count = 0;\n          diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsEncryptOperation);\n          const {\n            body: encryptedBody,\n            propertiesEncryptedCount\n          } = await this.container.encryptionProcessor.encrypt(body);\n          body = encryptedBody;\n          count += propertiesEncryptedCount;\n          const {\n            partitionKeyList: encryptedPartitionKeyList,\n            encryptedCount\n          } = await this.container.encryptionProcessor.getEncryptedPartitionKeyValue(this.partitionKey);\n          partitionKey = encryptedPartitionKeyList;\n          count += encryptedCount;\n          if (await this.container.encryptionProcessor.isPathEncrypted(\"/id\")) {\n            url = await this.container.encryptionProcessor.getEncryptedUrl(this.url);\n            count++;\n          }\n          diagnosticNode.endEncryptionDiagnostics(Constants.Encryption.DiagnosticsEncryptOperation, count);\n        }\n        const path = getPathFromLink(url);\n        const id = getIdFromLink(url);\n        response = await this.clientContext.replace({\n          body,\n          path,\n          resourceType: ResourceType.item,\n          resourceId: id,\n          options,\n          partitionKey: partitionKey,\n          diagnosticNode\n        });\n      } catch (error) {\n        if (this.clientContext.enableEncryption) {\n          await this.container.throwIfRequestNeedsARetryPostPolicyRefresh(error);\n        }\n        throw error;\n      }\n      if (this.clientContext.enableEncryption) {\n        try {\n          // try block for decrypting response. This is done so that we can throw special error message in case of decryption failure\n          diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsDecryptOperation);\n          const {\n            body: result,\n            propertiesDecryptedCount\n          } = await this.container.encryptionProcessor.decrypt(response.result);\n          response.result = result;\n          diagnosticNode.endEncryptionDiagnostics(Constants.Encryption.DiagnosticsDecryptOperation, propertiesDecryptedCount);\n        } catch (error) {\n          const decryptionError = new ErrorResponse(`Item replace operation was successful but response decryption failed: + ${error.message}`);\n          decryptionError.code = StatusCodes.ServiceUnavailable;\n          throw decryptionError;\n        }\n      }\n      return new ItemResponse(response.result, response.headers, response.code, response.substatus, this, getEmptyCosmosDiagnostics());\n    }, this.clientContext);\n  }\n  /**\n   * Delete the item.\n   *\n   * Any provided type, T, is not necessarily enforced by the SDK.\n   * You may get more or less properties and it's up to your logic to enforce it.\n   *\n   * @param options - Additional options for the request\n   */\n  async delete(options = {}) {\n    return withDiagnostics(async diagnosticNode => {\n      this.partitionKey = await setPartitionKeyIfUndefined(diagnosticNode, this.container, this.partitionKey);\n      let partitionKey = this.partitionKey;\n      let url = this.url;\n      let response;\n      try {\n        if (this.clientContext.enableEncryption) {\n          await this.container.checkAndInitializeEncryption();\n          options.containerRid = this.container._rid;\n          let count = 0;\n          diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsEncryptOperation);\n          const {\n            partitionKeyList,\n            encryptedCount\n          } = await this.container.encryptionProcessor.getEncryptedPartitionKeyValue(this.partitionKey);\n          partitionKey = partitionKeyList;\n          count += encryptedCount;\n          if (await this.container.encryptionProcessor.isPathEncrypted(\"/id\")) {\n            url = await this.container.encryptionProcessor.getEncryptedUrl(this.url);\n            count++;\n          }\n          diagnosticNode.endEncryptionDiagnostics(Constants.Encryption.DiagnosticsEncryptOperation, count);\n        }\n        const path = getPathFromLink(url);\n        const id = getIdFromLink(url);\n        response = await this.clientContext.delete({\n          path,\n          resourceType: ResourceType.item,\n          resourceId: id,\n          options,\n          partitionKey: partitionKey,\n          diagnosticNode\n        });\n      } catch (error) {\n        if (this.clientContext.enableEncryption) {\n          await this.container.throwIfRequestNeedsARetryPostPolicyRefresh(error);\n        }\n        throw error;\n      }\n      return new ItemResponse(response.result, response.headers, response.code, response.substatus, this, getEmptyCosmosDiagnostics());\n    }, this.clientContext);\n  }\n  /**\n   * Perform a JSONPatch on the item.\n   *\n   * Any provided type, T, is not necessarily enforced by the SDK.\n   * You may get more or less properties and it's up to your logic to enforce it.\n   *\n   * @param options - Additional options for the request\n   */\n  async patch(body, options = {}) {\n    return withDiagnostics(async diagnosticNode => {\n      this.partitionKey = await setPartitionKeyIfUndefined(diagnosticNode, this.container, this.partitionKey);\n      let url = this.url;\n      let partitionKey = this.partitionKey;\n      let response;\n      try {\n        if (this.clientContext.enableEncryption) {\n          await this.container.checkAndInitializeEncryption();\n          options.containerRid = this.container._rid;\n          // returns copy to avoid encryption of original body passed\n          body = copyObject(body);\n          const operations = Array.isArray(body) ? body : body.operations;\n          diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsEncryptOperation);\n          let propertiesEncryptedCount = 0;\n          for (const operation of operations) {\n            if (operation.op === PatchOperationType.remove) {\n              continue;\n            }\n            const isPathEncrypted = await this.container.encryptionProcessor.isPathEncrypted(operation.path);\n            if (!isPathEncrypted) {\n              continue;\n            }\n            if (operation.op === PatchOperationType.incr) {\n              throw new ErrorResponse(`Increment patch operation is not allowed for encrypted path '${operation.path}'`);\n            }\n            if (\"value\" in operation) {\n              operation.value = await this.container.encryptionProcessor.encryptProperty(operation.path, operation.value);\n            }\n            propertiesEncryptedCount++;\n          }\n          const {\n            partitionKeyList,\n            encryptedCount\n          } = await this.container.encryptionProcessor.getEncryptedPartitionKeyValue(partitionKey);\n          partitionKey = partitionKeyList;\n          propertiesEncryptedCount += encryptedCount;\n          if (await this.container.encryptionProcessor.isPathEncrypted(\"/id\")) {\n            url = await this.container.encryptionProcessor.getEncryptedUrl(this.url);\n            propertiesEncryptedCount++;\n          }\n          diagnosticNode.endEncryptionDiagnostics(Constants.Encryption.DiagnosticsEncryptOperation, propertiesEncryptedCount);\n        }\n        const path = getPathFromLink(url);\n        const id = getIdFromLink(url);\n        response = await this.clientContext.patch({\n          body,\n          path,\n          resourceType: ResourceType.item,\n          resourceId: id,\n          options,\n          partitionKey: partitionKey,\n          diagnosticNode\n        });\n      } catch (error) {\n        if (this.clientContext.enableEncryption) {\n          await this.container.throwIfRequestNeedsARetryPostPolicyRefresh(error);\n        }\n        throw error;\n      }\n      if (this.clientContext.enableEncryption) {\n        try {\n          diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsDecryptOperation);\n          const {\n            body: result,\n            propertiesDecryptedCount\n          } = await this.container.encryptionProcessor.decrypt(response.result);\n          response.result = result;\n          diagnosticNode.endEncryptionDiagnostics(Constants.Encryption.DiagnosticsDecryptOperation, propertiesDecryptedCount);\n        } catch (error) {\n          const decryptionError = new ErrorResponse(`Item patch operation was successful but response decryption failed: + ${error.message}`);\n          decryptionError.code = StatusCodes.ServiceUnavailable;\n          throw decryptionError;\n        }\n      }\n      return new ItemResponse(response.result, response.headers, response.code, response.substatus, this, getEmptyCosmosDiagnostics());\n    }, this.clientContext);\n  }\n}","map":{"version":3,"names":["Constants","copyObject","createDocumentUri","getIdFromLink","getPathFromLink","isItemResourceValid","ResourceType","StatusCodes","convertToInternalPartitionKey","ErrorResponse","PatchOperationType","ItemResponse","getEmptyCosmosDiagnostics","withDiagnostics","setPartitionKeyIfUndefined","Item","url","container","database","id","constructor","clientContext","partitionKey","undefined","read","options","diagnosticNode","response","enableEncryption","checkAndInitializeEncryption","containerRid","_rid","count","beginEncryptionDiagnostics","Encryption","DiagnosticsEncryptOperation","partitionKeyList","encryptedPartitionKey","encryptedCount","encryptionProcessor","getEncryptedPartitionKeyValue","isPathEncrypted","getEncryptedUrl","endEncryptionDiagnostics","path","resourceType","item","resourceId","error","throwIfRequestNeedsARetryPostPolicyRefresh","code","NotFound","DiagnosticsDecryptOperation","body","propertiesDecryptedCount","decrypt","result","headers","substatus","replace","err","encryptedBody","propertiesEncryptedCount","encrypt","encryptedPartitionKeyList","decryptionError","message","ServiceUnavailable","delete","patch","operations","Array","isArray","operation","op","remove","incr","value","encryptProperty"],"sources":["/Users/eimis/test-server/Azure Hackthons/azure-cloud-architecture-game /node_modules/@azure/cosmos/src/client/Item/Item.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { ClientContext } from \"../../ClientContext\";\nimport type { DiagnosticNodeInternal } from \"../../diagnostics/DiagnosticNodeInternal\";\nimport {\n  Constants,\n  copyObject,\n  createDocumentUri,\n  getIdFromLink,\n  getPathFromLink,\n  isItemResourceValid,\n  ResourceType,\n  StatusCodes,\n} from \"../../common\";\nimport type { PartitionKey, PartitionKeyInternal } from \"../../documents\";\nimport { convertToInternalPartitionKey } from \"../../documents\";\nimport type { RequestOptions, Response } from \"../../request\";\nimport { ErrorResponse } from \"../../request\";\nimport type { PatchRequestBody } from \"../../utils/patch\";\nimport { PatchOperationType } from \"../../utils/patch\";\nimport type { Container } from \"../Container\";\nimport type { Resource } from \"../Resource\";\nimport type { ItemDefinition } from \"./ItemDefinition\";\nimport { ItemResponse } from \"./ItemResponse\";\nimport { getEmptyCosmosDiagnostics, withDiagnostics } from \"../../utils/diagnostics\";\nimport { setPartitionKeyIfUndefined } from \"../../extractPartitionKey\";\n\n/**\n * Used to perform operations on a specific item.\n *\n * @see {@link Items} for operations on all items; see `container.items`.\n */\nexport class Item {\n  private partitionKey: PartitionKeyInternal;\n  /**\n   * Returns a reference URL to the resource. Used for linking in Permissions.\n   */\n  public get url(): string {\n    return createDocumentUri(this.container.database.id, this.container.id, this.id);\n  }\n\n  /**\n   * @hidden\n   * @param container - The parent {@link Container}.\n   * @param id - The id of the given {@link Item}.\n   * @param partitionKey - The primary key of the given {@link Item} (only for partitioned containers).\n   */\n  constructor(\n    public readonly container: Container,\n    public readonly id: string,\n    private readonly clientContext: ClientContext,\n    partitionKey?: PartitionKey,\n  ) {\n    this.partitionKey =\n      partitionKey === undefined ? undefined : convertToInternalPartitionKey(partitionKey);\n  }\n\n  /**\n   * Read the item's definition.\n   *\n   * Any provided type, T, is not necessarily enforced by the SDK.\n   * You may get more or less properties and it's up to your logic to enforce it.\n   * If the type, T, is a class, it won't pass `typeof` comparisons, because it won't have a match prototype.\n   * It's recommended to only use interfaces.\n   *\n   * There is no set schema for JSON items. They may contain any number of custom properties.\n   *\n   * @param options - Additional options for the request\n   *\n   * @example Using custom type for response\n   * ```typescript\n   * interface TodoItem {\n   *   title: string;\n   *   done: bool;\n   *   id: string;\n   * }\n   *\n   * let item: TodoItem;\n   * ({body: item} = await item.read<TodoItem>());\n   * ```\n   */\n  public async read<T extends ItemDefinition = any>(\n    options: RequestOptions = {},\n  ): Promise<ItemResponse<T>> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      this.partitionKey = await setPartitionKeyIfUndefined(\n        diagnosticNode,\n        this.container,\n        this.partitionKey,\n      );\n      let url = this.url;\n      let partitionKey = this.partitionKey;\n      let response: Response<T & Resource>;\n      try {\n        if (this.clientContext.enableEncryption) {\n          await this.container.checkAndInitializeEncryption();\n          options.containerRid = this.container._rid;\n          let count = 0;\n          diagnosticNode.beginEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsEncryptOperation,\n          );\n          const { partitionKeyList: encryptedPartitionKey, encryptedCount } =\n            await this.container.encryptionProcessor.getEncryptedPartitionKeyValue(\n              this.partitionKey,\n            );\n          partitionKey = encryptedPartitionKey;\n          count += encryptedCount;\n          if (await this.container.encryptionProcessor.isPathEncrypted(\"/id\")) {\n            url = await this.container.encryptionProcessor.getEncryptedUrl(this.url);\n            count++;\n          }\n          diagnosticNode.endEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsEncryptOperation,\n            count,\n          );\n        }\n        const path = getPathFromLink(url);\n        const id = getIdFromLink(url);\n\n        response = await this.clientContext.read<T>({\n          path,\n          resourceType: ResourceType.item,\n          resourceId: id,\n          options,\n          partitionKey: partitionKey,\n          diagnosticNode,\n        });\n      } catch (error: any) {\n        if (this.clientContext.enableEncryption) {\n          await this.container.throwIfRequestNeedsARetryPostPolicyRefresh(error);\n        }\n        if (error.code !== StatusCodes.NotFound) {\n          throw error;\n        }\n        response = error;\n      }\n      if (this.clientContext.enableEncryption) {\n        diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsDecryptOperation);\n        const { body, propertiesDecryptedCount } = await this.container.encryptionProcessor.decrypt(\n          response.result,\n        );\n        diagnosticNode.endEncryptionDiagnostics(\n          Constants.Encryption.DiagnosticsDecryptOperation,\n          propertiesDecryptedCount,\n        );\n        response.result = body;\n      }\n      return new ItemResponse(\n        response.result,\n        response.headers,\n        response.code,\n        response.substatus,\n        this,\n        getEmptyCosmosDiagnostics(),\n      );\n    }, this.clientContext);\n  }\n\n  /**\n   * Replace the item's definition.\n   *\n   * There is no set schema for JSON items. They may contain any number of custom properties.\n   *\n   * @param body - The definition to replace the existing {@link Item}'s definition with.\n   * @param options - Additional options for the request\n   */\n  public replace(\n    body: ItemDefinition,\n    options?: RequestOptions,\n  ): Promise<ItemResponse<ItemDefinition>>;\n  /**\n   * Replace the item's definition.\n   *\n   * Any provided type, T, is not necessarily enforced by the SDK.\n   * You may get more or less properties and it's up to your logic to enforce it.\n   *\n   * There is no set schema for JSON items. They may contain any number of custom properties.\n   *\n   * @param body - The definition to replace the existing {@link Item}'s definition with.\n   * @param options - Additional options for the request\n   */\n  public replace<T extends ItemDefinition>(\n    body: T,\n    options?: RequestOptions,\n  ): Promise<ItemResponse<T>>;\n  public async replace<T extends ItemDefinition>(\n    body: T,\n    options: RequestOptions = {},\n  ): Promise<ItemResponse<T>> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      this.partitionKey = await setPartitionKeyIfUndefined(\n        diagnosticNode,\n        this.container,\n        this.partitionKey,\n      );\n      let partitionKey = this.partitionKey;\n      const err = {};\n      if (!isItemResourceValid(body, err)) {\n        throw err;\n      }\n      let url = this.url;\n\n      let response: Response<T & Resource>;\n      try {\n        if (this.clientContext.enableEncryption) {\n          // returns copy to avoid encryption of original body passed\n          body = copyObject(body);\n          options = options || {};\n          await this.container.checkAndInitializeEncryption();\n          options.containerRid = this.container._rid;\n          let count = 0;\n          diagnosticNode.beginEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsEncryptOperation,\n          );\n          const { body: encryptedBody, propertiesEncryptedCount } =\n            await this.container.encryptionProcessor.encrypt(body);\n          body = encryptedBody;\n          count += propertiesEncryptedCount;\n          const { partitionKeyList: encryptedPartitionKeyList, encryptedCount } =\n            await this.container.encryptionProcessor.getEncryptedPartitionKeyValue(\n              this.partitionKey,\n            );\n          partitionKey = encryptedPartitionKeyList;\n          count += encryptedCount;\n          if (await this.container.encryptionProcessor.isPathEncrypted(\"/id\")) {\n            url = await this.container.encryptionProcessor.getEncryptedUrl(this.url);\n            count++;\n          }\n          diagnosticNode.endEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsEncryptOperation,\n            count,\n          );\n        }\n        const path = getPathFromLink(url);\n        const id = getIdFromLink(url);\n\n        response = await this.clientContext.replace<T>({\n          body,\n          path,\n          resourceType: ResourceType.item,\n          resourceId: id,\n          options,\n          partitionKey: partitionKey,\n          diagnosticNode,\n        });\n      } catch (error: any) {\n        if (this.clientContext.enableEncryption) {\n          await this.container.throwIfRequestNeedsARetryPostPolicyRefresh(error);\n        }\n        throw error;\n      }\n      if (this.clientContext.enableEncryption) {\n        try {\n          // try block for decrypting response. This is done so that we can throw special error message in case of decryption failure\n          diagnosticNode.beginEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsDecryptOperation,\n          );\n          const { body: result, propertiesDecryptedCount } =\n            await this.container.encryptionProcessor.decrypt(response.result);\n          response.result = result;\n          diagnosticNode.endEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsDecryptOperation,\n            propertiesDecryptedCount,\n          );\n        } catch (error) {\n          const decryptionError = new ErrorResponse(\n            `Item replace operation was successful but response decryption failed: + ${error.message}`,\n          );\n          decryptionError.code = StatusCodes.ServiceUnavailable;\n          throw decryptionError;\n        }\n      }\n      return new ItemResponse(\n        response.result,\n        response.headers,\n        response.code,\n        response.substatus,\n        this,\n        getEmptyCosmosDiagnostics(),\n      );\n    }, this.clientContext);\n  }\n\n  /**\n   * Delete the item.\n   *\n   * Any provided type, T, is not necessarily enforced by the SDK.\n   * You may get more or less properties and it's up to your logic to enforce it.\n   *\n   * @param options - Additional options for the request\n   */\n  public async delete<T extends ItemDefinition = any>(\n    options: RequestOptions = {},\n  ): Promise<ItemResponse<T>> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      this.partitionKey = await setPartitionKeyIfUndefined(\n        diagnosticNode,\n        this.container,\n        this.partitionKey,\n      );\n      let partitionKey = this.partitionKey;\n      let url = this.url;\n      let response: Response<T & Resource>;\n      try {\n        if (this.clientContext.enableEncryption) {\n          await this.container.checkAndInitializeEncryption();\n          options.containerRid = this.container._rid;\n          let count = 0;\n          diagnosticNode.beginEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsEncryptOperation,\n          );\n          const { partitionKeyList, encryptedCount } =\n            await this.container.encryptionProcessor.getEncryptedPartitionKeyValue(\n              this.partitionKey,\n            );\n          partitionKey = partitionKeyList;\n          count += encryptedCount;\n          if (await this.container.encryptionProcessor.isPathEncrypted(\"/id\")) {\n            url = await this.container.encryptionProcessor.getEncryptedUrl(this.url);\n            count++;\n          }\n          diagnosticNode.endEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsEncryptOperation,\n            count,\n          );\n        }\n        const path = getPathFromLink(url);\n        const id = getIdFromLink(url);\n\n        response = await this.clientContext.delete<T>({\n          path,\n          resourceType: ResourceType.item,\n          resourceId: id,\n          options,\n          partitionKey: partitionKey,\n          diagnosticNode,\n        });\n      } catch (error: any) {\n        if (this.clientContext.enableEncryption) {\n          await this.container.throwIfRequestNeedsARetryPostPolicyRefresh(error);\n        }\n        throw error;\n      }\n\n      return new ItemResponse(\n        response.result,\n        response.headers,\n        response.code,\n        response.substatus,\n        this,\n        getEmptyCosmosDiagnostics(),\n      );\n    }, this.clientContext);\n  }\n\n  /**\n   * Perform a JSONPatch on the item.\n   *\n   * Any provided type, T, is not necessarily enforced by the SDK.\n   * You may get more or less properties and it's up to your logic to enforce it.\n   *\n   * @param options - Additional options for the request\n   */\n  public async patch<T extends ItemDefinition = any>(\n    body: PatchRequestBody,\n    options: RequestOptions = {},\n  ): Promise<ItemResponse<T>> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      this.partitionKey = await setPartitionKeyIfUndefined(\n        diagnosticNode,\n        this.container,\n        this.partitionKey,\n      );\n      let url = this.url;\n      let partitionKey = this.partitionKey;\n      let response: Response<T & Resource>;\n      try {\n        if (this.clientContext.enableEncryption) {\n          await this.container.checkAndInitializeEncryption();\n          options.containerRid = this.container._rid;\n          // returns copy to avoid encryption of original body passed\n          body = copyObject(body);\n          const operations = Array.isArray(body) ? body : body.operations;\n          diagnosticNode.beginEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsEncryptOperation,\n          );\n          let propertiesEncryptedCount = 0;\n          for (const operation of operations) {\n            if (operation.op === PatchOperationType.remove) {\n              continue;\n            }\n            const isPathEncrypted = await this.container.encryptionProcessor.isPathEncrypted(\n              operation.path,\n            );\n            if (!isPathEncrypted) {\n              continue;\n            }\n            if (operation.op === PatchOperationType.incr) {\n              throw new ErrorResponse(\n                `Increment patch operation is not allowed for encrypted path '${operation.path}'`,\n              );\n            }\n            if (\"value\" in operation) {\n              operation.value = await this.container.encryptionProcessor.encryptProperty(\n                operation.path,\n                operation.value,\n              );\n            }\n            propertiesEncryptedCount++;\n          }\n          const { partitionKeyList, encryptedCount } =\n            await this.container.encryptionProcessor.getEncryptedPartitionKeyValue(partitionKey);\n          partitionKey = partitionKeyList;\n          propertiesEncryptedCount += encryptedCount;\n          if (await this.container.encryptionProcessor.isPathEncrypted(\"/id\")) {\n            url = await this.container.encryptionProcessor.getEncryptedUrl(this.url);\n            propertiesEncryptedCount++;\n          }\n          diagnosticNode.endEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsEncryptOperation,\n            propertiesEncryptedCount,\n          );\n        }\n        const path = getPathFromLink(url);\n        const id = getIdFromLink(url);\n        response = await this.clientContext.patch<T>({\n          body,\n          path,\n          resourceType: ResourceType.item,\n          resourceId: id,\n          options,\n          partitionKey: partitionKey,\n          diagnosticNode,\n        });\n      } catch (error: any) {\n        if (this.clientContext.enableEncryption) {\n          await this.container.throwIfRequestNeedsARetryPostPolicyRefresh(error);\n        }\n        throw error;\n      }\n      if (this.clientContext.enableEncryption) {\n        try {\n          diagnosticNode.beginEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsDecryptOperation,\n          );\n          const { body: result, propertiesDecryptedCount } =\n            await this.container.encryptionProcessor.decrypt(response.result);\n          response.result = result;\n          diagnosticNode.endEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsDecryptOperation,\n            propertiesDecryptedCount,\n          );\n        } catch (error) {\n          const decryptionError = new ErrorResponse(\n            `Item patch operation was successful but response decryption failed: + ${error.message}`,\n          );\n          decryptionError.code = StatusCodes.ServiceUnavailable;\n          throw decryptionError;\n        }\n      }\n\n      return new ItemResponse(\n        response.result,\n        response.headers,\n        response.code,\n        response.substatus,\n        this,\n        getEmptyCosmosDiagnostics(),\n      );\n    }, this.clientContext);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}