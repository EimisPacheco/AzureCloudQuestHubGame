{"ast":null,"code":"import { ErrorResponse } from \"../request/ErrorResponse\";\nimport { OffsetLimitEndpointComponent } from \"./EndpointComponent/OffsetLimitEndpointComponent\";\nimport { OrderByEndpointComponent } from \"./EndpointComponent/OrderByEndpointComponent\";\nimport { OrderedDistinctEndpointComponent } from \"./EndpointComponent/OrderedDistinctEndpointComponent\";\nimport { UnorderedDistinctEndpointComponent } from \"./EndpointComponent/UnorderedDistinctEndpointComponent\";\nimport { GroupByEndpointComponent } from \"./EndpointComponent/GroupByEndpointComponent\";\nimport { getInitialHeader, mergeHeaders } from \"./headerUtils\";\nimport { OrderByQueryExecutionContext } from \"./orderByQueryExecutionContext\";\nimport { ParallelQueryExecutionContext } from \"./parallelQueryExecutionContext\";\nimport { GroupByValueEndpointComponent } from \"./EndpointComponent/GroupByValueEndpointComponent\";\nimport { NonStreamingOrderByDistinctEndpointComponent } from \"./EndpointComponent/NonStreamingOrderByDistinctEndpointComponent\";\nimport { NonStreamingOrderByEndpointComponent } from \"./EndpointComponent/NonStreamingOrderByEndpointComponent\";\n/** @hidden */\nexport class PipelinedQueryExecutionContext {\n  constructor(clientContext, collectionLink, query, options, partitionedQueryExecutionInfo, correlatedActivityId, emitRawOrderByPayload = false) {\n    this.clientContext = clientContext;\n    this.collectionLink = collectionLink;\n    this.query = query;\n    this.options = options;\n    this.partitionedQueryExecutionInfo = partitionedQueryExecutionInfo;\n    this.emitRawOrderByPayload = emitRawOrderByPayload;\n    this.vectorSearchBufferSize = 0;\n    this.nonStreamingOrderBy = false;\n    this.endpoint = null;\n    this.pageSize = options[\"maxItemCount\"];\n    if (this.pageSize === undefined) {\n      this.pageSize = PipelinedQueryExecutionContext.DEFAULT_PAGE_SIZE;\n    }\n    // Pick between Nonstreaming and streaming endpoints\n    this.nonStreamingOrderBy = partitionedQueryExecutionInfo.queryInfo.hasNonStreamingOrderBy;\n    // Pick between parallel vs order by execution context\n    const sortOrders = partitionedQueryExecutionInfo.queryInfo.orderBy;\n    // TODO: Currently we don't get any field from backend to determine streaming queries\n    if (this.nonStreamingOrderBy) {\n      if (!options.allowUnboundedNonStreamingQueries) {\n        this.checkQueryConstraints(partitionedQueryExecutionInfo.queryInfo);\n      }\n      this.vectorSearchBufferSize = this.calculateVectorSearchBufferSize(partitionedQueryExecutionInfo.queryInfo, options);\n      const maxBufferSize = options[\"vectorSearchBufferSize\"] ? options[\"vectorSearchBufferSize\"] : PipelinedQueryExecutionContext.DEFAULT_MAX_VECTOR_SEARCH_BUFFER_SIZE;\n      if (this.vectorSearchBufferSize > maxBufferSize) {\n        throw new ErrorResponse(`Executing a vector search query with TOP or OFFSET + LIMIT value ${this.vectorSearchBufferSize} larger than the vectorSearchBufferSize ${maxBufferSize} ` + `is not allowed`);\n      }\n      const distinctType = partitionedQueryExecutionInfo.queryInfo.distinctType;\n      const context = new ParallelQueryExecutionContext(this.clientContext, this.collectionLink, this.query, this.options, this.partitionedQueryExecutionInfo, correlatedActivityId);\n      if (distinctType === \"None\") {\n        this.endpoint = new NonStreamingOrderByEndpointComponent(context, sortOrders, this.vectorSearchBufferSize, partitionedQueryExecutionInfo.queryInfo.offset, this.emitRawOrderByPayload);\n      } else {\n        this.endpoint = new NonStreamingOrderByDistinctEndpointComponent(context, partitionedQueryExecutionInfo.queryInfo, this.vectorSearchBufferSize, this.emitRawOrderByPayload);\n      }\n    } else {\n      if (Array.isArray(sortOrders) && sortOrders.length > 0) {\n        // Need to wrap orderby execution context in endpoint component, since the data is nested as a \\\n        //      \"payload\" property.\n        this.endpoint = new OrderByEndpointComponent(new OrderByQueryExecutionContext(this.clientContext, this.collectionLink, this.query, this.options, this.partitionedQueryExecutionInfo, correlatedActivityId), this.emitRawOrderByPayload);\n      } else {\n        this.endpoint = new ParallelQueryExecutionContext(this.clientContext, this.collectionLink, this.query, this.options, this.partitionedQueryExecutionInfo, correlatedActivityId);\n      }\n      if (Object.keys(partitionedQueryExecutionInfo.queryInfo.groupByAliasToAggregateType).length > 0 || partitionedQueryExecutionInfo.queryInfo.aggregates.length > 0 || partitionedQueryExecutionInfo.queryInfo.groupByExpressions.length > 0) {\n        if (partitionedQueryExecutionInfo.queryInfo.hasSelectValue) {\n          this.endpoint = new GroupByValueEndpointComponent(this.endpoint, partitionedQueryExecutionInfo.queryInfo);\n        } else {\n          this.endpoint = new GroupByEndpointComponent(this.endpoint, partitionedQueryExecutionInfo.queryInfo);\n        }\n      }\n      // If distinct then add that to the pipeline\n      const distinctType = partitionedQueryExecutionInfo.queryInfo.distinctType;\n      if (distinctType === \"Ordered\") {\n        this.endpoint = new OrderedDistinctEndpointComponent(this.endpoint);\n      }\n      if (distinctType === \"Unordered\") {\n        this.endpoint = new UnorderedDistinctEndpointComponent(this.endpoint);\n      }\n      // If top then add that to the pipeline. TOP N is effectively OFFSET 0 LIMIT N\n      const top = partitionedQueryExecutionInfo.queryInfo.top;\n      if (typeof top === \"number\") {\n        this.endpoint = new OffsetLimitEndpointComponent(this.endpoint, 0, top);\n      }\n      // If offset+limit then add that to the pipeline\n      const limit = partitionedQueryExecutionInfo.queryInfo.limit;\n      const offset = partitionedQueryExecutionInfo.queryInfo.offset;\n      if (typeof limit === \"number\" && typeof offset === \"number\") {\n        this.endpoint = new OffsetLimitEndpointComponent(this.endpoint, offset, limit);\n      }\n    }\n    this.fetchBuffer = [];\n  }\n  hasMoreResults() {\n    return this.fetchBuffer.length !== 0 || this.endpoint.hasMoreResults();\n  }\n  async fetchMore(diagnosticNode) {\n    this.fetchMoreRespHeaders = getInitialHeader();\n    return this._fetchMoreImplementation(diagnosticNode);\n  }\n  async _fetchMoreImplementation(diagnosticNode) {\n    try {\n      if (this.fetchBuffer.length >= this.pageSize) {\n        const temp = this.fetchBuffer.slice(0, this.pageSize);\n        this.fetchBuffer = this.fetchBuffer.slice(this.pageSize);\n        return {\n          result: temp,\n          headers: this.fetchMoreRespHeaders\n        };\n      } else {\n        const response = await this.endpoint.fetchMore(diagnosticNode);\n        mergeHeaders(this.fetchMoreRespHeaders, response.headers);\n        if (response === undefined || response.result === undefined) {\n          if (this.fetchBuffer.length > 0) {\n            const temp = this.fetchBuffer;\n            this.fetchBuffer = [];\n            return {\n              result: temp,\n              headers: this.fetchMoreRespHeaders\n            };\n          } else {\n            return {\n              result: undefined,\n              headers: this.fetchMoreRespHeaders\n            };\n          }\n        }\n        this.fetchBuffer.push(...response.result);\n        if (this.options.enableQueryControl) {\n          if (this.fetchBuffer.length >= this.pageSize) {\n            const temp = this.fetchBuffer.slice(0, this.pageSize);\n            this.fetchBuffer = this.fetchBuffer.slice(this.pageSize);\n            return {\n              result: temp,\n              headers: this.fetchMoreRespHeaders\n            };\n          } else {\n            const temp = this.fetchBuffer;\n            this.fetchBuffer = [];\n            return {\n              result: temp,\n              headers: this.fetchMoreRespHeaders\n            };\n          }\n        }\n        // Recursively fetch more results to ensure the pageSize number of results are returned\n        // to maintain compatibility with the previous implementation\n        return this._fetchMoreImplementation(diagnosticNode);\n      }\n    } catch (err) {\n      mergeHeaders(this.fetchMoreRespHeaders, err.headers);\n      err.headers = this.fetchMoreRespHeaders;\n      if (err) {\n        throw err;\n      }\n    }\n  }\n  calculateVectorSearchBufferSize(queryInfo, options) {\n    if (queryInfo.top === 0 || queryInfo.limit === 0) return 0;\n    return queryInfo.top ? queryInfo.top : queryInfo.limit ? queryInfo.offset + queryInfo.limit : options[\"vectorSearchBufferSize\"] && options[\"vectorSearchBufferSize\"] > 0 ? options[\"vectorSearchBufferSize\"] : PipelinedQueryExecutionContext.DEFAULT_MAX_VECTOR_SEARCH_BUFFER_SIZE;\n  }\n  checkQueryConstraints(queryInfo) {\n    const hasTop = queryInfo.top || queryInfo.top === 0;\n    const hasLimit = queryInfo.limit || queryInfo.limit === 0;\n    if (!hasTop && !hasLimit) {\n      throw new ErrorResponse(\"Executing a non-streaming search query without TOP or LIMIT can consume a large number of RUs \" + \"very fast and have long runtimes. Please ensure you are using one of the above two filters \" + \"with your vector search query.\");\n    }\n    return;\n  }\n}\nPipelinedQueryExecutionContext.DEFAULT_PAGE_SIZE = 10;\nPipelinedQueryExecutionContext.DEFAULT_MAX_VECTOR_SEARCH_BUFFER_SIZE = 50000;","map":{"version":3,"names":["ErrorResponse","OffsetLimitEndpointComponent","OrderByEndpointComponent","OrderedDistinctEndpointComponent","UnorderedDistinctEndpointComponent","GroupByEndpointComponent","getInitialHeader","mergeHeaders","OrderByQueryExecutionContext","ParallelQueryExecutionContext","GroupByValueEndpointComponent","NonStreamingOrderByDistinctEndpointComponent","NonStreamingOrderByEndpointComponent","PipelinedQueryExecutionContext","constructor","clientContext","collectionLink","query","options","partitionedQueryExecutionInfo","correlatedActivityId","emitRawOrderByPayload","vectorSearchBufferSize","nonStreamingOrderBy","endpoint","pageSize","undefined","DEFAULT_PAGE_SIZE","queryInfo","hasNonStreamingOrderBy","sortOrders","orderBy","allowUnboundedNonStreamingQueries","checkQueryConstraints","calculateVectorSearchBufferSize","maxBufferSize","DEFAULT_MAX_VECTOR_SEARCH_BUFFER_SIZE","distinctType","context","offset","Array","isArray","length","Object","keys","groupByAliasToAggregateType","aggregates","groupByExpressions","hasSelectValue","top","limit","fetchBuffer","hasMoreResults","fetchMore","diagnosticNode","fetchMoreRespHeaders","_fetchMoreImplementation","temp","slice","result","headers","response","push","enableQueryControl","err","hasTop","hasLimit"],"sources":["/Users/eimis/test-server/Azure Hackthons/azure-cloud-architecture-game /node_modules/@azure/cosmos/src/queryExecutionContext/pipelinedQueryExecutionContext.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { ClientContext } from \"../ClientContext\";\nimport type { Response, FeedOptions } from \"../request\";\nimport type { PartitionedQueryExecutionInfo, QueryInfo } from \"../request/ErrorResponse\";\nimport { ErrorResponse } from \"../request/ErrorResponse\";\nimport type { CosmosHeaders } from \"./CosmosHeaders\";\nimport { OffsetLimitEndpointComponent } from \"./EndpointComponent/OffsetLimitEndpointComponent\";\nimport { OrderByEndpointComponent } from \"./EndpointComponent/OrderByEndpointComponent\";\nimport { OrderedDistinctEndpointComponent } from \"./EndpointComponent/OrderedDistinctEndpointComponent\";\nimport { UnorderedDistinctEndpointComponent } from \"./EndpointComponent/UnorderedDistinctEndpointComponent\";\nimport { GroupByEndpointComponent } from \"./EndpointComponent/GroupByEndpointComponent\";\nimport type { ExecutionContext } from \"./ExecutionContext\";\nimport { getInitialHeader, mergeHeaders } from \"./headerUtils\";\nimport { OrderByQueryExecutionContext } from \"./orderByQueryExecutionContext\";\nimport { ParallelQueryExecutionContext } from \"./parallelQueryExecutionContext\";\nimport { GroupByValueEndpointComponent } from \"./EndpointComponent/GroupByValueEndpointComponent\";\nimport type { SqlQuerySpec } from \"./SqlQuerySpec\";\nimport type { DiagnosticNodeInternal } from \"../diagnostics/DiagnosticNodeInternal\";\nimport { NonStreamingOrderByDistinctEndpointComponent } from \"./EndpointComponent/NonStreamingOrderByDistinctEndpointComponent\";\nimport { NonStreamingOrderByEndpointComponent } from \"./EndpointComponent/NonStreamingOrderByEndpointComponent\";\n\n/** @hidden */\nexport class PipelinedQueryExecutionContext implements ExecutionContext {\n  private fetchBuffer: any[];\n  private fetchMoreRespHeaders: CosmosHeaders;\n  private endpoint: ExecutionContext;\n  private pageSize: number;\n  private vectorSearchBufferSize: number = 0;\n  private static DEFAULT_PAGE_SIZE = 10;\n  private static DEFAULT_MAX_VECTOR_SEARCH_BUFFER_SIZE = 50000;\n  private nonStreamingOrderBy = false;\n\n  constructor(\n    private clientContext: ClientContext,\n    private collectionLink: string,\n    private query: string | SqlQuerySpec,\n    private options: FeedOptions,\n    private partitionedQueryExecutionInfo: PartitionedQueryExecutionInfo,\n    correlatedActivityId: string,\n    private emitRawOrderByPayload: boolean = false,\n  ) {\n    this.endpoint = null;\n    this.pageSize = options[\"maxItemCount\"];\n    if (this.pageSize === undefined) {\n      this.pageSize = PipelinedQueryExecutionContext.DEFAULT_PAGE_SIZE;\n    }\n    // Pick between Nonstreaming and streaming endpoints\n    this.nonStreamingOrderBy = partitionedQueryExecutionInfo.queryInfo.hasNonStreamingOrderBy;\n\n    // Pick between parallel vs order by execution context\n    const sortOrders = partitionedQueryExecutionInfo.queryInfo.orderBy;\n    // TODO: Currently we don't get any field from backend to determine streaming queries\n    if (this.nonStreamingOrderBy) {\n      if (!options.allowUnboundedNonStreamingQueries) {\n        this.checkQueryConstraints(partitionedQueryExecutionInfo.queryInfo);\n      }\n\n      this.vectorSearchBufferSize = this.calculateVectorSearchBufferSize(\n        partitionedQueryExecutionInfo.queryInfo,\n        options,\n      );\n      const maxBufferSize = options[\"vectorSearchBufferSize\"]\n        ? options[\"vectorSearchBufferSize\"]\n        : PipelinedQueryExecutionContext.DEFAULT_MAX_VECTOR_SEARCH_BUFFER_SIZE;\n\n      if (this.vectorSearchBufferSize > maxBufferSize) {\n        throw new ErrorResponse(\n          `Executing a vector search query with TOP or OFFSET + LIMIT value ${this.vectorSearchBufferSize} larger than the vectorSearchBufferSize ${maxBufferSize} ` +\n            `is not allowed`,\n        );\n      }\n\n      const distinctType = partitionedQueryExecutionInfo.queryInfo.distinctType;\n      const context: ExecutionContext = new ParallelQueryExecutionContext(\n        this.clientContext,\n        this.collectionLink,\n        this.query,\n        this.options,\n        this.partitionedQueryExecutionInfo,\n        correlatedActivityId,\n      );\n\n      if (distinctType === \"None\") {\n        this.endpoint = new NonStreamingOrderByEndpointComponent(\n          context,\n          sortOrders,\n          this.vectorSearchBufferSize,\n          partitionedQueryExecutionInfo.queryInfo.offset,\n          this.emitRawOrderByPayload,\n        );\n      } else {\n        this.endpoint = new NonStreamingOrderByDistinctEndpointComponent(\n          context,\n          partitionedQueryExecutionInfo.queryInfo,\n          this.vectorSearchBufferSize,\n          this.emitRawOrderByPayload,\n        );\n      }\n    } else {\n      if (Array.isArray(sortOrders) && sortOrders.length > 0) {\n        // Need to wrap orderby execution context in endpoint component, since the data is nested as a \\\n        //      \"payload\" property.\n        this.endpoint = new OrderByEndpointComponent(\n          new OrderByQueryExecutionContext(\n            this.clientContext,\n            this.collectionLink,\n            this.query,\n            this.options,\n            this.partitionedQueryExecutionInfo,\n            correlatedActivityId,\n          ),\n          this.emitRawOrderByPayload,\n        );\n      } else {\n        this.endpoint = new ParallelQueryExecutionContext(\n          this.clientContext,\n          this.collectionLink,\n          this.query,\n          this.options,\n          this.partitionedQueryExecutionInfo,\n          correlatedActivityId,\n        );\n      }\n      if (\n        Object.keys(partitionedQueryExecutionInfo.queryInfo.groupByAliasToAggregateType).length >\n          0 ||\n        partitionedQueryExecutionInfo.queryInfo.aggregates.length > 0 ||\n        partitionedQueryExecutionInfo.queryInfo.groupByExpressions.length > 0\n      ) {\n        if (partitionedQueryExecutionInfo.queryInfo.hasSelectValue) {\n          this.endpoint = new GroupByValueEndpointComponent(\n            this.endpoint,\n            partitionedQueryExecutionInfo.queryInfo,\n          );\n        } else {\n          this.endpoint = new GroupByEndpointComponent(\n            this.endpoint,\n            partitionedQueryExecutionInfo.queryInfo,\n          );\n        }\n      }\n\n      // If distinct then add that to the pipeline\n      const distinctType = partitionedQueryExecutionInfo.queryInfo.distinctType;\n      if (distinctType === \"Ordered\") {\n        this.endpoint = new OrderedDistinctEndpointComponent(this.endpoint);\n      }\n      if (distinctType === \"Unordered\") {\n        this.endpoint = new UnorderedDistinctEndpointComponent(this.endpoint);\n      }\n\n      // If top then add that to the pipeline. TOP N is effectively OFFSET 0 LIMIT N\n      const top = partitionedQueryExecutionInfo.queryInfo.top;\n      if (typeof top === \"number\") {\n        this.endpoint = new OffsetLimitEndpointComponent(this.endpoint, 0, top);\n      }\n\n      // If offset+limit then add that to the pipeline\n      const limit = partitionedQueryExecutionInfo.queryInfo.limit;\n      const offset = partitionedQueryExecutionInfo.queryInfo.offset;\n      if (typeof limit === \"number\" && typeof offset === \"number\") {\n        this.endpoint = new OffsetLimitEndpointComponent(this.endpoint, offset, limit);\n      }\n    }\n    this.fetchBuffer = [];\n  }\n\n  public hasMoreResults(): boolean {\n    return this.fetchBuffer.length !== 0 || this.endpoint.hasMoreResults();\n  }\n\n  public async fetchMore(diagnosticNode: DiagnosticNodeInternal): Promise<Response<any>> {\n    this.fetchMoreRespHeaders = getInitialHeader();\n    return this._fetchMoreImplementation(diagnosticNode);\n  }\n\n  private async _fetchMoreImplementation(\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<Response<any>> {\n    try {\n      if (this.fetchBuffer.length >= this.pageSize) {\n        const temp = this.fetchBuffer.slice(0, this.pageSize);\n        this.fetchBuffer = this.fetchBuffer.slice(this.pageSize);\n        return { result: temp, headers: this.fetchMoreRespHeaders };\n      } else {\n        const response = await this.endpoint.fetchMore(diagnosticNode);\n        mergeHeaders(this.fetchMoreRespHeaders, response.headers);\n        if (response === undefined || response.result === undefined) {\n          if (this.fetchBuffer.length > 0) {\n            const temp = this.fetchBuffer;\n            this.fetchBuffer = [];\n            return { result: temp, headers: this.fetchMoreRespHeaders };\n          } else {\n            return { result: undefined, headers: this.fetchMoreRespHeaders };\n          }\n        }\n        this.fetchBuffer.push(...response.result);\n\n        if (this.options.enableQueryControl) {\n          if (this.fetchBuffer.length >= this.pageSize) {\n            const temp = this.fetchBuffer.slice(0, this.pageSize);\n            this.fetchBuffer = this.fetchBuffer.slice(this.pageSize);\n            return { result: temp, headers: this.fetchMoreRespHeaders };\n          } else {\n            const temp = this.fetchBuffer;\n            this.fetchBuffer = [];\n            return { result: temp, headers: this.fetchMoreRespHeaders };\n          }\n        }\n        // Recursively fetch more results to ensure the pageSize number of results are returned\n        // to maintain compatibility with the previous implementation\n        return this._fetchMoreImplementation(diagnosticNode);\n      }\n    } catch (err: any) {\n      mergeHeaders(this.fetchMoreRespHeaders, err.headers);\n      err.headers = this.fetchMoreRespHeaders;\n      if (err) {\n        throw err;\n      }\n    }\n  }\n\n  private calculateVectorSearchBufferSize(queryInfo: QueryInfo, options: FeedOptions): number {\n    if (queryInfo.top === 0 || queryInfo.limit === 0) return 0;\n    return queryInfo.top\n      ? queryInfo.top\n      : queryInfo.limit\n        ? queryInfo.offset + queryInfo.limit\n        : options[\"vectorSearchBufferSize\"] && options[\"vectorSearchBufferSize\"] > 0\n          ? options[\"vectorSearchBufferSize\"]\n          : PipelinedQueryExecutionContext.DEFAULT_MAX_VECTOR_SEARCH_BUFFER_SIZE;\n  }\n\n  private checkQueryConstraints(queryInfo: QueryInfo): void {\n    const hasTop = queryInfo.top || queryInfo.top === 0;\n    const hasLimit = queryInfo.limit || queryInfo.limit === 0;\n    if (!hasTop && !hasLimit) {\n      throw new ErrorResponse(\n        \"Executing a non-streaming search query without TOP or LIMIT can consume a large number of RUs \" +\n          \"very fast and have long runtimes. Please ensure you are using one of the above two filters \" +\n          \"with your vector search query.\",\n      );\n    }\n    return;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}