{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createClientLogger } from \"@azure/logger\";\nimport { HybridSearchQueryResult } from \"../request/hybridSearchQueryResult\";\nimport { GlobalStatisticsAggregator } from \"./Aggregators/GlobalStatisticsAggregator\";\nimport { getInitialHeader, mergeHeaders } from \"./headerUtils\";\nimport { ParallelQueryExecutionContext } from \"./parallelQueryExecutionContext\";\nimport { PipelinedQueryExecutionContext } from \"./pipelinedQueryExecutionContext\";\n/** @hidden */\nexport var HybridQueryExecutionContextBaseStates;\n(function (HybridQueryExecutionContextBaseStates) {\n  HybridQueryExecutionContextBaseStates[\"uninitialized\"] = \"uninitialized\";\n  HybridQueryExecutionContextBaseStates[\"initialized\"] = \"initialized\";\n  HybridQueryExecutionContextBaseStates[\"draining\"] = \"draining\";\n  HybridQueryExecutionContextBaseStates[\"done\"] = \"done\";\n})(HybridQueryExecutionContextBaseStates || (HybridQueryExecutionContextBaseStates = {}));\nexport class HybridQueryExecutionContext {\n  constructor(clientContext, collectionLink, options, partitionedQueryExecutionInfo, correlatedActivityId, allPartitionsRanges) {\n    this.clientContext = clientContext;\n    this.collectionLink = collectionLink;\n    this.options = options;\n    this.partitionedQueryExecutionInfo = partitionedQueryExecutionInfo;\n    this.correlatedActivityId = correlatedActivityId;\n    this.allPartitionsRanges = allPartitionsRanges;\n    this.componentsExecutionContext = [];\n    this.emitRawOrderByPayload = true;\n    this.buffer = [];\n    this.DEFAULT_PAGE_SIZE = 10;\n    this.TOTAL_WORD_COUNT_PLACEHOLDER = \"documentdb-formattablehybridsearchquery-totalwordcount\";\n    this.HIT_COUNTS_ARRAY_PLACEHOLDER = \"documentdb-formattablehybridsearchquery-hitcountsarray\";\n    this.TOTAL_DOCUMENT_COUNT_PLACEHOLDER = \"documentdb-formattablehybridsearchquery-totaldocumentcount\";\n    this.RRF_CONSTANT = 60; // Constant for RRF score calculation\n    this.logger = createClientLogger(\"HybridQueryExecutionContext\");\n    this.hybridSearchResult = [];\n    this.uniqueItems = new Map();\n    this.isSingleComponent = false;\n    this.state = HybridQueryExecutionContextBaseStates.uninitialized;\n    this.pageSize = this.options.maxItemCount;\n    if (this.pageSize === undefined) {\n      this.pageSize = this.DEFAULT_PAGE_SIZE;\n    }\n    if (partitionedQueryExecutionInfo.hybridSearchQueryInfo.requiresGlobalStatistics) {\n      const globalStaticsQueryOptions = {\n        maxItemCount: this.pageSize\n      };\n      this.globalStatisticsAggregator = new GlobalStatisticsAggregator();\n      const globalStatisticsQuery = this.partitionedQueryExecutionInfo.hybridSearchQueryInfo.globalStatisticsQuery;\n      const globalStatisticsQueryExecutionInfo = {\n        partitionedQueryExecutionInfoVersion: 1,\n        queryInfo: {\n          distinctType: \"None\",\n          hasSelectValue: false,\n          groupByAliasToAggregateType: {},\n          rewrittenQuery: globalStatisticsQuery,\n          hasNonStreamingOrderBy: false\n        },\n        queryRanges: this.allPartitionsRanges\n      };\n      this.globalStatisticsExecutionContext = new ParallelQueryExecutionContext(this.clientContext, this.collectionLink, globalStatisticsQuery, globalStaticsQueryOptions, globalStatisticsQueryExecutionInfo, this.correlatedActivityId);\n    } else {\n      this.createComponentExecutionContexts();\n      this.state = HybridQueryExecutionContextBaseStates.initialized;\n    }\n  }\n  async nextItem(diagnosticNode) {\n    const nextItemRespHeaders = getInitialHeader();\n    while ((this.state === HybridQueryExecutionContextBaseStates.uninitialized || this.state === HybridQueryExecutionContextBaseStates.initialized) && this.buffer.length === 0) {\n      await this.fetchMoreInternal(diagnosticNode, nextItemRespHeaders);\n    }\n    if (this.state === HybridQueryExecutionContextBaseStates.draining && this.buffer.length > 0) {\n      return this.drainOne(nextItemRespHeaders);\n    } else {\n      return this.done(nextItemRespHeaders);\n    }\n  }\n  hasMoreResults() {\n    switch (this.state) {\n      case HybridQueryExecutionContextBaseStates.uninitialized:\n        return true;\n      case HybridQueryExecutionContextBaseStates.initialized:\n        return true;\n      case HybridQueryExecutionContextBaseStates.draining:\n        return this.buffer.length > 0;\n      case HybridQueryExecutionContextBaseStates.done:\n        return false;\n      default:\n        return false;\n    }\n  }\n  async fetchMore(diagnosticNode) {\n    const fetchMoreRespHeaders = getInitialHeader();\n    return this.fetchMoreInternal(diagnosticNode, fetchMoreRespHeaders);\n  }\n  async fetchMoreInternal(diagnosticNode, headers) {\n    switch (this.state) {\n      case HybridQueryExecutionContextBaseStates.uninitialized:\n        await this.initialize(diagnosticNode, headers);\n        return {\n          result: [],\n          headers: headers\n        };\n      case HybridQueryExecutionContextBaseStates.initialized:\n        await this.executeComponentQueries(diagnosticNode, headers);\n        return {\n          result: [],\n          headers: headers\n        };\n      case HybridQueryExecutionContextBaseStates.draining:\n        return this.drain(headers);\n      case HybridQueryExecutionContextBaseStates.done:\n        return this.done(headers);\n      default:\n        throw new Error(`Invalid state: ${this.state}`);\n    }\n  }\n  async initialize(diagnosticNode, fetchMoreRespHeaders) {\n    try {\n      while (this.globalStatisticsExecutionContext.hasMoreResults()) {\n        const result = await this.globalStatisticsExecutionContext.fetchMore(diagnosticNode);\n        mergeHeaders(fetchMoreRespHeaders, result.headers);\n        if (result && result.result) {\n          for (const item of result.result) {\n            const globalStatistics = item;\n            if (globalStatistics) {\n              // iterate over the components update placeholders from globalStatistics\n              this.globalStatisticsAggregator.aggregate(globalStatistics);\n            }\n          }\n        }\n      }\n    } catch (error) {\n      this.state = HybridQueryExecutionContextBaseStates.done;\n      throw error;\n    }\n    // create component execution contexts for each component query\n    this.createComponentExecutionContexts();\n    this.state = HybridQueryExecutionContextBaseStates.initialized;\n  }\n  async executeComponentQueries(diagnosticNode, fetchMoreRespHeaders) {\n    if (this.isSingleComponent) {\n      await this.drainSingleComponent(diagnosticNode, fetchMoreRespHeaders);\n      return;\n    }\n    try {\n      if (this.options.enableQueryControl) {\n        // track componentExecutionContexts with remaining results and call them in LIFO order\n        if (this.componentsExecutionContext.length > 0) {\n          const componentExecutionContext = this.componentsExecutionContext.pop();\n          if (componentExecutionContext.hasMoreResults()) {\n            const result = await componentExecutionContext.fetchMore(diagnosticNode);\n            const response = result.result;\n            mergeHeaders(fetchMoreRespHeaders, result.headers);\n            if (response) {\n              response.forEach(item => {\n                const hybridItem = HybridSearchQueryResult.create(item);\n                if (!this.uniqueItems.has(hybridItem.rid)) {\n                  this.uniqueItems.set(hybridItem.rid, hybridItem);\n                }\n              });\n            }\n            if (componentExecutionContext.hasMoreResults()) {\n              this.componentsExecutionContext.push(componentExecutionContext);\n            }\n          }\n        }\n        if (this.componentsExecutionContext.length === 0) {\n          this.processUniqueItems();\n        }\n      } else {\n        for (const componentExecutionContext of this.componentsExecutionContext) {\n          while (componentExecutionContext.hasMoreResults()) {\n            const result = await componentExecutionContext.fetchMore(diagnosticNode);\n            const response = result.result;\n            mergeHeaders(fetchMoreRespHeaders, result.headers);\n            if (response) {\n              response.forEach(item => {\n                const hybridItem = HybridSearchQueryResult.create(item);\n                if (!this.uniqueItems.has(hybridItem.rid)) {\n                  this.uniqueItems.set(hybridItem.rid, hybridItem);\n                }\n              });\n            }\n          }\n        }\n        this.processUniqueItems();\n      }\n    } catch (error) {\n      this.state = HybridQueryExecutionContextBaseStates.done;\n      throw error;\n    }\n  }\n  processUniqueItems() {\n    this.uniqueItems.forEach(item => this.hybridSearchResult.push(item));\n    if (this.hybridSearchResult.length === 0 || this.hybridSearchResult.length === 1) {\n      // return the result as no or one element is present\n      this.hybridSearchResult.forEach(item => this.buffer.push(item.data));\n      this.state = HybridQueryExecutionContextBaseStates.draining;\n      return;\n    }\n    // Initialize an array to hold ranks for each document\n    const sortedHybridSearchResult = this.sortHybridSearchResultByRRFScore(this.hybridSearchResult);\n    // store the result to buffer\n    // add only data from the sortedHybridSearchResult in the buffer\n    sortedHybridSearchResult.forEach(item => this.buffer.push(item.data));\n    this.applySkipAndTakeToBuffer();\n    this.state = HybridQueryExecutionContextBaseStates.draining;\n  }\n  applySkipAndTakeToBuffer() {\n    const {\n      skip,\n      take\n    } = this.partitionedQueryExecutionInfo.hybridSearchQueryInfo;\n    if (skip) {\n      this.buffer = skip >= this.buffer.length ? [] : this.buffer.slice(skip);\n    }\n    if (take) {\n      this.buffer = take <= 0 ? [] : this.buffer.slice(0, take);\n    }\n  }\n  async drain(fetchMoreRespHeaders) {\n    try {\n      if (this.buffer.length === 0) {\n        this.state = HybridQueryExecutionContextBaseStates.done;\n        return this.done(fetchMoreRespHeaders);\n      }\n      const result = this.buffer.slice(0, this.pageSize);\n      this.buffer = this.buffer.slice(this.pageSize);\n      if (this.buffer.length === 0) {\n        this.state = HybridQueryExecutionContextBaseStates.done;\n      }\n      return {\n        result: result,\n        headers: fetchMoreRespHeaders\n      };\n    } catch (error) {\n      this.state = HybridQueryExecutionContextBaseStates.done;\n      throw error;\n    }\n  }\n  async drainOne(nextItemRespHeaders) {\n    try {\n      if (this.buffer.length === 0) {\n        this.state = HybridQueryExecutionContextBaseStates.done;\n        return this.done(nextItemRespHeaders);\n      }\n      const result = this.buffer.shift();\n      if (this.buffer.length === 0) {\n        this.state = HybridQueryExecutionContextBaseStates.done;\n      }\n      return {\n        result: result,\n        headers: nextItemRespHeaders\n      };\n    } catch (error) {\n      this.state = HybridQueryExecutionContextBaseStates.done;\n      throw error;\n    }\n  }\n  done(fetchMoreRespHeaders) {\n    return {\n      result: undefined,\n      headers: fetchMoreRespHeaders\n    };\n  }\n  sortHybridSearchResultByRRFScore(hybridSearchResult) {\n    if (hybridSearchResult.length === 0) {\n      return [];\n    }\n    const ranksArray = hybridSearchResult.map(item => ({\n      rid: item.rid,\n      ranks: new Array(item.componentScores.length).fill(0)\n    }));\n    // Compute ranks for each component score\n    for (let i = 0; i < hybridSearchResult[0].componentScores.length; i++) {\n      // Sort based on the i-th component score\n      hybridSearchResult.sort((a, b) => b.componentScores[i] - a.componentScores[i]);\n      // Assign ranks\n      let rank = 1;\n      for (let j = 0; j < hybridSearchResult.length; j++) {\n        if (j > 0 && hybridSearchResult[j].componentScores[i] !== hybridSearchResult[j - 1].componentScores[i]) {\n          rank = j + 1;\n        }\n        const rankIndex = ranksArray.findIndex(rankItem => rankItem.rid === hybridSearchResult[j].rid);\n        ranksArray[rankIndex].ranks[i] = rank; // 1-based rank\n      }\n    }\n    // Function to compute RRF score\n    const computeRRFScore = (ranks, k) => {\n      return ranks.reduce((acc, rank) => acc + 1 / (k + rank), 0);\n    };\n    // Compute RRF scores and sort based on them\n    const rrfScores = ranksArray.map(item => ({\n      rid: item.rid,\n      rrfScore: computeRRFScore(item.ranks, this.RRF_CONSTANT)\n    }));\n    // Sort based on RRF scores\n    rrfScores.sort((a, b) => b.rrfScore - a.rrfScore);\n    // Map sorted RRF scores back to hybridSearchResult\n    const sortedHybridSearchResult = rrfScores.map(scoreItem => hybridSearchResult.find(item => item.rid === scoreItem.rid));\n    return sortedHybridSearchResult;\n  }\n  async drainSingleComponent(diagNode, fetchMoreRespHeaders) {\n    if (this.componentsExecutionContext && this.componentsExecutionContext.length !== 1) {\n      this.logger.error(\"drainSingleComponent called on multiple components\");\n      return;\n    }\n    try {\n      if (this.options.enableQueryControl) {\n        const componentExecutionContext = this.componentsExecutionContext[0];\n        if (componentExecutionContext.hasMoreResults()) {\n          const result = await componentExecutionContext.fetchMore(diagNode);\n          const response = result.result;\n          mergeHeaders(fetchMoreRespHeaders, result.headers);\n          if (response) {\n            response.forEach(item => {\n              this.hybridSearchResult.push(HybridSearchQueryResult.create(item));\n            });\n          }\n        }\n        if (!componentExecutionContext.hasMoreResults()) {\n          this.state = HybridQueryExecutionContextBaseStates.draining;\n          this.hybridSearchResult.forEach(item => this.buffer.push(item.data));\n          this.applySkipAndTakeToBuffer();\n          this.state = HybridQueryExecutionContextBaseStates.draining;\n        }\n        return;\n      } else {\n        const componentExecutionContext = this.componentsExecutionContext[0];\n        const hybridSearchResult = [];\n        // add check for enable query control\n        while (componentExecutionContext.hasMoreResults()) {\n          const result = await componentExecutionContext.fetchMore(diagNode);\n          const response = result.result;\n          mergeHeaders(fetchMoreRespHeaders, result.headers);\n          if (response) {\n            response.forEach(item => {\n              hybridSearchResult.push(HybridSearchQueryResult.create(item));\n            });\n          }\n        }\n        hybridSearchResult.forEach(item => this.buffer.push(item.data));\n        this.applySkipAndTakeToBuffer();\n        this.state = HybridQueryExecutionContextBaseStates.draining;\n      }\n    } catch (error) {\n      this.state = HybridQueryExecutionContextBaseStates.done;\n      throw error;\n    }\n  }\n  createComponentExecutionContexts() {\n    // rewrite queries based on global statistics\n    let queryInfos = this.partitionedQueryExecutionInfo.hybridSearchQueryInfo.componentQueryInfos;\n    if (this.partitionedQueryExecutionInfo.hybridSearchQueryInfo.requiresGlobalStatistics) {\n      queryInfos = this.processComponentQueries(this.partitionedQueryExecutionInfo.hybridSearchQueryInfo.componentQueryInfos, this.globalStatisticsAggregator.getResult());\n    }\n    // create component execution contexts\n    for (const componentQueryInfo of queryInfos) {\n      const componentPartitionExecutionInfo = {\n        partitionedQueryExecutionInfoVersion: 1,\n        queryInfo: componentQueryInfo,\n        queryRanges: this.partitionedQueryExecutionInfo.queryRanges\n      };\n      const executionContext = new PipelinedQueryExecutionContext(this.clientContext, this.collectionLink, componentQueryInfo.rewrittenQuery, this.options, componentPartitionExecutionInfo, this.correlatedActivityId, this.emitRawOrderByPayload);\n      this.componentsExecutionContext.push(executionContext);\n    }\n    this.isSingleComponent = this.componentsExecutionContext.length === 1;\n  }\n  processComponentQueries(componentQueryInfos, globalStats) {\n    return componentQueryInfos.map(queryInfo => {\n      if (!queryInfo.hasNonStreamingOrderBy) {\n        throw new Error(\"The component query must have a non-streaming order by clause.\");\n      }\n      return Object.assign(Object.assign({}, queryInfo), {\n        rewrittenQuery: this.replacePlaceholdersWorkaroud(queryInfo.rewrittenQuery, globalStats, componentQueryInfos.length),\n        orderByExpressions: queryInfo.orderByExpressions.map(expr => this.replacePlaceholdersWorkaroud(expr, globalStats, componentQueryInfos.length))\n      });\n    });\n  }\n  // This method is commented currently, but we will switch back to using this\n  // once the gateway has been redeployed with the fix for placeholder indexes\n  // private replacePlaceholders(query: string, globalStats: GlobalStatistics): string {\n  //   // Replace total document count\n  //   query = query.replace(\n  //     new RegExp(`{${this.TOTAL_DOCUMENT_COUNT_PLACEHOLDER}}`, \"g\"),\n  //     globalStats.documentCount.toString(),\n  //   );\n  //   // Replace total word counts and hit counts from fullTextStatistics\n  //   globalStats.fullTextStatistics.forEach((stats, index) => {\n  //     // Replace total word counts\n  //     query = query.replace(\n  //       new RegExp(`{${this.TOTAL_WORD_COUNT_PLACEHOLDER}-${index}}`, \"g\"),\n  //       stats.totalWordCount.toString(),\n  //     );\n  //     // Replace hit counts\n  //     query = query.replace(\n  //       new RegExp(`{${this.HIT_COUNTS_ARRAY_PLACEHOLDER}-${index}}`, \"g\"),\n  //       `[${stats.hitCounts.join(\",\")}]`,\n  //     );\n  //   });\n  //   return query;\n  // }\n  replacePlaceholdersWorkaroud(query, globalStats, componentCount) {\n    if (!globalStats || !globalStats.documentCount || !Array.isArray(globalStats.fullTextStatistics)) {\n      throw new Error(\"GlobalStats validation failed\");\n    }\n    // Replace total document count\n    query = query.replace(new RegExp(`{${this.TOTAL_DOCUMENT_COUNT_PLACEHOLDER}}`, \"g\"), globalStats.documentCount.toString());\n    let statisticsIndex = 0;\n    for (let i = 0; i < componentCount; i++) {\n      // Replace total word counts and hit counts from fullTextStatistics\n      const wordCountPlaceholder = `{${this.TOTAL_WORD_COUNT_PLACEHOLDER}-${i}}`;\n      const hitCountPlaceholder = `{${this.HIT_COUNTS_ARRAY_PLACEHOLDER}-${i}}`;\n      if (!query.includes(wordCountPlaceholder)) {\n        continue;\n      }\n      const stats = globalStats.fullTextStatistics[statisticsIndex];\n      // Replace total word counts\n      query = query.replace(new RegExp(wordCountPlaceholder, \"g\"), stats.totalWordCount.toString());\n      // Replace hit counts\n      query = query.replace(new RegExp(hitCountPlaceholder, \"g\"), `[${stats.hitCounts.join(\",\")}]`);\n      statisticsIndex++;\n    }\n    return query;\n  }\n}","map":{"version":3,"names":["createClientLogger","HybridSearchQueryResult","GlobalStatisticsAggregator","getInitialHeader","mergeHeaders","ParallelQueryExecutionContext","PipelinedQueryExecutionContext","HybridQueryExecutionContextBaseStates","HybridQueryExecutionContext","constructor","clientContext","collectionLink","options","partitionedQueryExecutionInfo","correlatedActivityId","allPartitionsRanges","componentsExecutionContext","emitRawOrderByPayload","buffer","DEFAULT_PAGE_SIZE","TOTAL_WORD_COUNT_PLACEHOLDER","HIT_COUNTS_ARRAY_PLACEHOLDER","TOTAL_DOCUMENT_COUNT_PLACEHOLDER","RRF_CONSTANT","logger","hybridSearchResult","uniqueItems","Map","isSingleComponent","state","uninitialized","pageSize","maxItemCount","undefined","hybridSearchQueryInfo","requiresGlobalStatistics","globalStaticsQueryOptions","globalStatisticsAggregator","globalStatisticsQuery","globalStatisticsQueryExecutionInfo","partitionedQueryExecutionInfoVersion","queryInfo","distinctType","hasSelectValue","groupByAliasToAggregateType","rewrittenQuery","hasNonStreamingOrderBy","queryRanges","globalStatisticsExecutionContext","createComponentExecutionContexts","initialized","nextItem","diagnosticNode","nextItemRespHeaders","length","fetchMoreInternal","draining","drainOne","done","hasMoreResults","fetchMore","fetchMoreRespHeaders","headers","initialize","result","executeComponentQueries","drain","Error","item","globalStatistics","aggregate","error","drainSingleComponent","enableQueryControl","componentExecutionContext","pop","response","forEach","hybridItem","create","has","rid","set","push","processUniqueItems","data","sortedHybridSearchResult","sortHybridSearchResultByRRFScore","applySkipAndTakeToBuffer","skip","take","slice","shift","ranksArray","map","ranks","Array","componentScores","fill","i","sort","a","b","rank","j","rankIndex","findIndex","rankItem","computeRRFScore","k","reduce","acc","rrfScores","rrfScore","scoreItem","find","diagNode","queryInfos","componentQueryInfos","processComponentQueries","getResult","componentQueryInfo","componentPartitionExecutionInfo","executionContext","globalStats","Object","assign","replacePlaceholdersWorkaroud","orderByExpressions","expr","query","componentCount","documentCount","isArray","fullTextStatistics","replace","RegExp","toString","statisticsIndex","wordCountPlaceholder","hitCountPlaceholder","includes","stats","totalWordCount","hitCounts","join"],"sources":["/Users/eimis/test-server/Azure Hackthons/azure-cloud-architecture-game /node_modules/@azure/cosmos/src/queryExecutionContext/hybridQueryExecutionContext.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { AzureLogger } from \"@azure/logger\";\nimport { createClientLogger } from \"@azure/logger\";\nimport type { ClientContext } from \"../ClientContext\";\nimport type { DiagnosticNodeInternal } from \"../diagnostics/DiagnosticNodeInternal\";\nimport type {\n  FeedOptions,\n  GlobalStatistics,\n  PartitionedQueryExecutionInfo,\n  QueryInfo,\n  QueryRange,\n  Response,\n} from \"../request\";\nimport { HybridSearchQueryResult } from \"../request/hybridSearchQueryResult\";\nimport { GlobalStatisticsAggregator } from \"./Aggregators/GlobalStatisticsAggregator\";\nimport type { CosmosHeaders } from \"./CosmosHeaders\";\nimport type { ExecutionContext } from \"./ExecutionContext\";\nimport { getInitialHeader, mergeHeaders } from \"./headerUtils\";\nimport { ParallelQueryExecutionContext } from \"./parallelQueryExecutionContext\";\nimport { PipelinedQueryExecutionContext } from \"./pipelinedQueryExecutionContext\";\n\n/** @hidden */\nexport enum HybridQueryExecutionContextBaseStates {\n  uninitialized = \"uninitialized\",\n  initialized = \"initialized\",\n  draining = \"draining\",\n  done = \"done\",\n}\nexport class HybridQueryExecutionContext implements ExecutionContext {\n  private globalStatisticsExecutionContext: ExecutionContext;\n  private componentsExecutionContext: ExecutionContext[] = [];\n  private pageSize: number;\n  private state: HybridQueryExecutionContextBaseStates;\n  private globalStatisticsAggregator: GlobalStatisticsAggregator;\n  private emitRawOrderByPayload: boolean = true;\n  private buffer: HybridSearchQueryResult[] = [];\n  private DEFAULT_PAGE_SIZE = 10;\n  private TOTAL_WORD_COUNT_PLACEHOLDER = \"documentdb-formattablehybridsearchquery-totalwordcount\";\n  private HIT_COUNTS_ARRAY_PLACEHOLDER = \"documentdb-formattablehybridsearchquery-hitcountsarray\";\n  private TOTAL_DOCUMENT_COUNT_PLACEHOLDER =\n    \"documentdb-formattablehybridsearchquery-totaldocumentcount\";\n  private RRF_CONSTANT = 60; // Constant for RRF score calculation\n  private logger: AzureLogger = createClientLogger(\"HybridQueryExecutionContext\");\n  private hybridSearchResult: HybridSearchQueryResult[] = [];\n  private uniqueItems = new Map<string, HybridSearchQueryResult>();\n  private isSingleComponent: boolean = false;\n\n  constructor(\n    private clientContext: ClientContext,\n    private collectionLink: string,\n    private options: FeedOptions,\n    private partitionedQueryExecutionInfo: PartitionedQueryExecutionInfo,\n    private correlatedActivityId: string,\n    private allPartitionsRanges: QueryRange[],\n  ) {\n    this.state = HybridQueryExecutionContextBaseStates.uninitialized;\n    this.pageSize = this.options.maxItemCount;\n    if (this.pageSize === undefined) {\n      this.pageSize = this.DEFAULT_PAGE_SIZE;\n    }\n    if (partitionedQueryExecutionInfo.hybridSearchQueryInfo.requiresGlobalStatistics) {\n      const globalStaticsQueryOptions: FeedOptions = { maxItemCount: this.pageSize };\n      this.globalStatisticsAggregator = new GlobalStatisticsAggregator();\n\n      const globalStatisticsQuery =\n        this.partitionedQueryExecutionInfo.hybridSearchQueryInfo.globalStatisticsQuery;\n      const globalStatisticsQueryExecutionInfo: PartitionedQueryExecutionInfo = {\n        partitionedQueryExecutionInfoVersion: 1,\n        queryInfo: {\n          distinctType: \"None\",\n          hasSelectValue: false,\n          groupByAliasToAggregateType: {},\n          rewrittenQuery: globalStatisticsQuery,\n          hasNonStreamingOrderBy: false,\n        },\n        queryRanges: this.allPartitionsRanges,\n      };\n\n      this.globalStatisticsExecutionContext = new ParallelQueryExecutionContext(\n        this.clientContext,\n        this.collectionLink,\n        globalStatisticsQuery,\n        globalStaticsQueryOptions,\n        globalStatisticsQueryExecutionInfo,\n        this.correlatedActivityId,\n      );\n    } else {\n      this.createComponentExecutionContexts();\n      this.state = HybridQueryExecutionContextBaseStates.initialized;\n    }\n  }\n  public async nextItem(diagnosticNode: DiagnosticNodeInternal): Promise<Response<any>> {\n    const nextItemRespHeaders = getInitialHeader();\n    while (\n      (this.state === HybridQueryExecutionContextBaseStates.uninitialized ||\n        this.state === HybridQueryExecutionContextBaseStates.initialized) &&\n      this.buffer.length === 0\n    ) {\n      await this.fetchMoreInternal(diagnosticNode, nextItemRespHeaders);\n    }\n\n    if (this.state === HybridQueryExecutionContextBaseStates.draining && this.buffer.length > 0) {\n      return this.drainOne(nextItemRespHeaders);\n    } else {\n      return this.done(nextItemRespHeaders);\n    }\n  }\n\n  public hasMoreResults(): boolean {\n    switch (this.state) {\n      case HybridQueryExecutionContextBaseStates.uninitialized:\n        return true;\n      case HybridQueryExecutionContextBaseStates.initialized:\n        return true;\n      case HybridQueryExecutionContextBaseStates.draining:\n        return this.buffer.length > 0;\n      case HybridQueryExecutionContextBaseStates.done:\n        return false;\n      default:\n        return false;\n    }\n  }\n\n  public async fetchMore(diagnosticNode?: DiagnosticNodeInternal): Promise<Response<any>> {\n    const fetchMoreRespHeaders = getInitialHeader();\n    return this.fetchMoreInternal(diagnosticNode, fetchMoreRespHeaders);\n  }\n\n  private async fetchMoreInternal(\n    diagnosticNode: DiagnosticNodeInternal,\n    headers: CosmosHeaders,\n  ): Promise<Response<any>> {\n    switch (this.state) {\n      case HybridQueryExecutionContextBaseStates.uninitialized:\n        await this.initialize(diagnosticNode, headers);\n        return {\n          result: [],\n          headers: headers,\n        };\n\n      case HybridQueryExecutionContextBaseStates.initialized:\n        await this.executeComponentQueries(diagnosticNode, headers);\n        return {\n          result: [],\n          headers: headers,\n        };\n      case HybridQueryExecutionContextBaseStates.draining:\n        return this.drain(headers);\n      case HybridQueryExecutionContextBaseStates.done:\n        return this.done(headers);\n      default:\n        throw new Error(`Invalid state: ${this.state}`);\n    }\n  }\n\n  private async initialize(\n    diagnosticNode: DiagnosticNodeInternal,\n    fetchMoreRespHeaders: CosmosHeaders,\n  ): Promise<void> {\n    try {\n      while (this.globalStatisticsExecutionContext.hasMoreResults()) {\n        const result = await this.globalStatisticsExecutionContext.fetchMore(diagnosticNode);\n        mergeHeaders(fetchMoreRespHeaders, result.headers);\n        if (result && result.result) {\n          for (const item of result.result) {\n            const globalStatistics: GlobalStatistics = item;\n            if (globalStatistics) {\n              // iterate over the components update placeholders from globalStatistics\n              this.globalStatisticsAggregator.aggregate(globalStatistics);\n            }\n          }\n        }\n      }\n    } catch (error) {\n      this.state = HybridQueryExecutionContextBaseStates.done;\n      throw error;\n    }\n\n    // create component execution contexts for each component query\n    this.createComponentExecutionContexts();\n    this.state = HybridQueryExecutionContextBaseStates.initialized;\n  }\n\n  private async executeComponentQueries(\n    diagnosticNode: DiagnosticNodeInternal,\n    fetchMoreRespHeaders: CosmosHeaders,\n  ): Promise<void> {\n    if (this.isSingleComponent) {\n      await this.drainSingleComponent(diagnosticNode, fetchMoreRespHeaders);\n      return;\n    }\n    try {\n      if (this.options.enableQueryControl) {\n        // track componentExecutionContexts with remaining results and call them in LIFO order\n        if (this.componentsExecutionContext.length > 0) {\n          const componentExecutionContext = this.componentsExecutionContext.pop();\n          if (componentExecutionContext.hasMoreResults()) {\n            const result = await componentExecutionContext.fetchMore(diagnosticNode);\n            const response = result.result;\n            mergeHeaders(fetchMoreRespHeaders, result.headers);\n            if (response) {\n              response.forEach((item: any) => {\n                const hybridItem = HybridSearchQueryResult.create(item);\n                if (!this.uniqueItems.has(hybridItem.rid)) {\n                  this.uniqueItems.set(hybridItem.rid, hybridItem);\n                }\n              });\n            }\n            if (componentExecutionContext.hasMoreResults()) {\n              this.componentsExecutionContext.push(componentExecutionContext);\n            }\n          }\n        }\n        if (this.componentsExecutionContext.length === 0) {\n          this.processUniqueItems();\n        }\n      } else {\n        for (const componentExecutionContext of this.componentsExecutionContext) {\n          while (componentExecutionContext.hasMoreResults()) {\n            const result = await componentExecutionContext.fetchMore(diagnosticNode);\n            const response = result.result;\n            mergeHeaders(fetchMoreRespHeaders, result.headers);\n            if (response) {\n              response.forEach((item: any) => {\n                const hybridItem = HybridSearchQueryResult.create(item);\n                if (!this.uniqueItems.has(hybridItem.rid)) {\n                  this.uniqueItems.set(hybridItem.rid, hybridItem);\n                }\n              });\n            }\n          }\n        }\n        this.processUniqueItems();\n      }\n    } catch (error) {\n      this.state = HybridQueryExecutionContextBaseStates.done;\n      throw error;\n    }\n  }\n\n  private processUniqueItems(): void {\n    this.uniqueItems.forEach((item) => this.hybridSearchResult.push(item));\n    if (this.hybridSearchResult.length === 0 || this.hybridSearchResult.length === 1) {\n      // return the result as no or one element is present\n      this.hybridSearchResult.forEach((item) => this.buffer.push(item.data));\n      this.state = HybridQueryExecutionContextBaseStates.draining;\n      return;\n    }\n\n    // Initialize an array to hold ranks for each document\n    const sortedHybridSearchResult = this.sortHybridSearchResultByRRFScore(this.hybridSearchResult);\n    // store the result to buffer\n    // add only data from the sortedHybridSearchResult in the buffer\n    sortedHybridSearchResult.forEach((item) => this.buffer.push(item.data));\n    this.applySkipAndTakeToBuffer();\n    this.state = HybridQueryExecutionContextBaseStates.draining;\n  }\n\n  private applySkipAndTakeToBuffer(): void {\n    const { skip, take } = this.partitionedQueryExecutionInfo.hybridSearchQueryInfo;\n    if (skip) {\n      this.buffer = skip >= this.buffer.length ? [] : this.buffer.slice(skip);\n    }\n    if (take) {\n      this.buffer = take <= 0 ? [] : this.buffer.slice(0, take);\n    }\n  }\n\n  private async drain(fetchMoreRespHeaders: CosmosHeaders): Promise<Response<any>> {\n    try {\n      if (this.buffer.length === 0) {\n        this.state = HybridQueryExecutionContextBaseStates.done;\n        return this.done(fetchMoreRespHeaders);\n      }\n      const result = this.buffer.slice(0, this.pageSize);\n      this.buffer = this.buffer.slice(this.pageSize);\n      if (this.buffer.length === 0) {\n        this.state = HybridQueryExecutionContextBaseStates.done;\n      }\n      return {\n        result: result,\n        headers: fetchMoreRespHeaders,\n      };\n    } catch (error) {\n      this.state = HybridQueryExecutionContextBaseStates.done;\n      throw error;\n    }\n  }\n\n  private async drainOne(nextItemRespHeaders: CosmosHeaders): Promise<Response<any>> {\n    try {\n      if (this.buffer.length === 0) {\n        this.state = HybridQueryExecutionContextBaseStates.done;\n        return this.done(nextItemRespHeaders);\n      }\n      const result = this.buffer.shift();\n      if (this.buffer.length === 0) {\n        this.state = HybridQueryExecutionContextBaseStates.done;\n      }\n      return {\n        result: result,\n        headers: nextItemRespHeaders,\n      };\n    } catch (error) {\n      this.state = HybridQueryExecutionContextBaseStates.done;\n      throw error;\n    }\n  }\n\n  private done(fetchMoreRespHeaders: CosmosHeaders): Response<any> {\n    return {\n      result: undefined,\n      headers: fetchMoreRespHeaders,\n    };\n  }\n\n  private sortHybridSearchResultByRRFScore(\n    hybridSearchResult: HybridSearchQueryResult[],\n  ): HybridSearchQueryResult[] {\n    if (hybridSearchResult.length === 0) {\n      return [];\n    }\n    const ranksArray: { rid: string; ranks: number[] }[] = hybridSearchResult.map((item) => ({\n      rid: item.rid,\n      ranks: new Array(item.componentScores.length).fill(0),\n    }));\n    // Compute ranks for each component score\n    for (let i = 0; i < hybridSearchResult[0].componentScores.length; i++) {\n      // Sort based on the i-th component score\n      hybridSearchResult.sort((a, b) => b.componentScores[i] - a.componentScores[i]);\n\n      // Assign ranks\n      let rank = 1;\n      for (let j = 0; j < hybridSearchResult.length; j++) {\n        if (\n          j > 0 &&\n          hybridSearchResult[j].componentScores[i] !== hybridSearchResult[j - 1].componentScores[i]\n        ) {\n          rank = j + 1;\n        }\n        const rankIndex = ranksArray.findIndex(\n          (rankItem) => rankItem.rid === hybridSearchResult[j].rid,\n        );\n        ranksArray[rankIndex].ranks[i] = rank; // 1-based rank\n      }\n    }\n\n    // Function to compute RRF score\n    const computeRRFScore = (ranks: number[], k: number): number => {\n      return ranks.reduce((acc, rank) => acc + 1 / (k + rank), 0);\n    };\n\n    // Compute RRF scores and sort based on them\n    const rrfScores = ranksArray.map((item) => ({\n      rid: item.rid,\n      rrfScore: computeRRFScore(item.ranks, this.RRF_CONSTANT),\n    }));\n\n    // Sort based on RRF scores\n    rrfScores.sort((a, b) => b.rrfScore - a.rrfScore);\n\n    // Map sorted RRF scores back to hybridSearchResult\n    const sortedHybridSearchResult = rrfScores.map((scoreItem) =>\n      hybridSearchResult.find((item) => item.rid === scoreItem.rid),\n    );\n    return sortedHybridSearchResult;\n  }\n\n  private async drainSingleComponent(\n    diagNode: DiagnosticNodeInternal,\n    fetchMoreRespHeaders: CosmosHeaders,\n  ): Promise<void> {\n    if (this.componentsExecutionContext && this.componentsExecutionContext.length !== 1) {\n      this.logger.error(\"drainSingleComponent called on multiple components\");\n      return;\n    }\n    try {\n      if (this.options.enableQueryControl) {\n        const componentExecutionContext = this.componentsExecutionContext[0];\n        if (componentExecutionContext.hasMoreResults()) {\n          const result = await componentExecutionContext.fetchMore(diagNode);\n          const response = result.result;\n          mergeHeaders(fetchMoreRespHeaders, result.headers);\n          if (response) {\n            response.forEach((item: any) => {\n              this.hybridSearchResult.push(HybridSearchQueryResult.create(item));\n            });\n          }\n        }\n        if (!componentExecutionContext.hasMoreResults()) {\n          this.state = HybridQueryExecutionContextBaseStates.draining;\n          this.hybridSearchResult.forEach((item) => this.buffer.push(item.data));\n          this.applySkipAndTakeToBuffer();\n          this.state = HybridQueryExecutionContextBaseStates.draining;\n        }\n        return;\n      } else {\n        const componentExecutionContext = this.componentsExecutionContext[0];\n        const hybridSearchResult: HybridSearchQueryResult[] = [];\n        // add check for enable query control\n        while (componentExecutionContext.hasMoreResults()) {\n          const result = await componentExecutionContext.fetchMore(diagNode);\n          const response = result.result;\n          mergeHeaders(fetchMoreRespHeaders, result.headers);\n          if (response) {\n            response.forEach((item: any) => {\n              hybridSearchResult.push(HybridSearchQueryResult.create(item));\n            });\n          }\n        }\n        hybridSearchResult.forEach((item) => this.buffer.push(item.data));\n        this.applySkipAndTakeToBuffer();\n        this.state = HybridQueryExecutionContextBaseStates.draining;\n      }\n    } catch (error) {\n      this.state = HybridQueryExecutionContextBaseStates.done;\n      throw error;\n    }\n  }\n\n  private createComponentExecutionContexts(): void {\n    // rewrite queries based on global statistics\n    let queryInfos: QueryInfo[] =\n      this.partitionedQueryExecutionInfo.hybridSearchQueryInfo.componentQueryInfos;\n    if (this.partitionedQueryExecutionInfo.hybridSearchQueryInfo.requiresGlobalStatistics) {\n      queryInfos = this.processComponentQueries(\n        this.partitionedQueryExecutionInfo.hybridSearchQueryInfo.componentQueryInfos,\n        this.globalStatisticsAggregator.getResult(),\n      );\n    }\n    // create component execution contexts\n    for (const componentQueryInfo of queryInfos) {\n      const componentPartitionExecutionInfo: PartitionedQueryExecutionInfo = {\n        partitionedQueryExecutionInfoVersion: 1,\n        queryInfo: componentQueryInfo,\n        queryRanges: this.partitionedQueryExecutionInfo.queryRanges,\n      };\n      const executionContext = new PipelinedQueryExecutionContext(\n        this.clientContext,\n        this.collectionLink,\n        componentQueryInfo.rewrittenQuery,\n        this.options,\n        componentPartitionExecutionInfo,\n        this.correlatedActivityId,\n        this.emitRawOrderByPayload,\n      );\n      this.componentsExecutionContext.push(executionContext);\n    }\n    this.isSingleComponent = this.componentsExecutionContext.length === 1;\n  }\n  private processComponentQueries(\n    componentQueryInfos: QueryInfo[],\n    globalStats: GlobalStatistics,\n  ): QueryInfo[] {\n    return componentQueryInfos.map((queryInfo) => {\n      if (!queryInfo.hasNonStreamingOrderBy) {\n        throw new Error(\"The component query must have a non-streaming order by clause.\");\n      }\n      return {\n        ...queryInfo,\n        rewrittenQuery: this.replacePlaceholdersWorkaroud(\n          queryInfo.rewrittenQuery,\n          globalStats,\n          componentQueryInfos.length,\n        ),\n        orderByExpressions: queryInfo.orderByExpressions.map((expr) =>\n          this.replacePlaceholdersWorkaroud(expr, globalStats, componentQueryInfos.length),\n        ),\n      };\n    });\n  }\n  // This method is commented currently, but we will switch back to using this\n  // once the gateway has been redeployed with the fix for placeholder indexes\n  // private replacePlaceholders(query: string, globalStats: GlobalStatistics): string {\n  //   // Replace total document count\n  //   query = query.replace(\n  //     new RegExp(`{${this.TOTAL_DOCUMENT_COUNT_PLACEHOLDER}}`, \"g\"),\n  //     globalStats.documentCount.toString(),\n  //   );\n\n  //   // Replace total word counts and hit counts from fullTextStatistics\n  //   globalStats.fullTextStatistics.forEach((stats, index) => {\n  //     // Replace total word counts\n  //     query = query.replace(\n  //       new RegExp(`{${this.TOTAL_WORD_COUNT_PLACEHOLDER}-${index}}`, \"g\"),\n  //       stats.totalWordCount.toString(),\n  //     );\n  //     // Replace hit counts\n  //     query = query.replace(\n  //       new RegExp(`{${this.HIT_COUNTS_ARRAY_PLACEHOLDER}-${index}}`, \"g\"),\n  //       `[${stats.hitCounts.join(\",\")}]`,\n  //     );\n  //   });\n\n  //   return query;\n  // }\n\n  private replacePlaceholdersWorkaroud(\n    query: string,\n    globalStats: GlobalStatistics,\n    componentCount: number,\n  ): string {\n    if (\n      !globalStats ||\n      !globalStats.documentCount ||\n      !Array.isArray(globalStats.fullTextStatistics)\n    ) {\n      throw new Error(\"GlobalStats validation failed\");\n    }\n    // Replace total document count\n    query = query.replace(\n      new RegExp(`{${this.TOTAL_DOCUMENT_COUNT_PLACEHOLDER}}`, \"g\"),\n      globalStats.documentCount.toString(),\n    );\n    let statisticsIndex: number = 0;\n    for (let i = 0; i < componentCount; i++) {\n      // Replace total word counts and hit counts from fullTextStatistics\n      const wordCountPlaceholder = `{${this.TOTAL_WORD_COUNT_PLACEHOLDER}-${i}}`;\n      const hitCountPlaceholder = `{${this.HIT_COUNTS_ARRAY_PLACEHOLDER}-${i}}`;\n      if (!query.includes(wordCountPlaceholder)) {\n        continue;\n      }\n      const stats = globalStats.fullTextStatistics[statisticsIndex];\n      // Replace total word counts\n      query = query.replace(new RegExp(wordCountPlaceholder, \"g\"), stats.totalWordCount.toString());\n      // Replace hit counts\n      query = query.replace(new RegExp(hitCountPlaceholder, \"g\"), `[${stats.hitCounts.join(\",\")}]`);\n      statisticsIndex++;\n    }\n    return query;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}