{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport PriorityQueue from \"priorityqueuejs\";\nimport semaphore from \"semaphore\";\nimport { createClientLogger } from \"@azure/logger\";\nimport { StatusCodes, SubStatusCodes } from \"../common/statusCodes\";\nimport { QueryRange } from \"../routing/QueryRange\";\nimport { SmartRoutingMapProvider } from \"../routing/smartRoutingMapProvider\";\nimport { DocumentProducer } from \"./documentProducer\";\nimport { getInitialHeader, mergeHeaders } from \"./headerUtils\";\nimport { DiagnosticNodeInternal, DiagnosticNodeType } from \"../diagnostics/DiagnosticNodeInternal\";\n/** @hidden */\nconst logger = createClientLogger(\"parallelQueryExecutionContextBase\");\n/** @hidden */\nexport var ParallelQueryExecutionContextBaseStates;\n(function (ParallelQueryExecutionContextBaseStates) {\n  ParallelQueryExecutionContextBaseStates[\"started\"] = \"started\";\n  ParallelQueryExecutionContextBaseStates[\"inProgress\"] = \"inProgress\";\n  ParallelQueryExecutionContextBaseStates[\"ended\"] = \"ended\";\n})(ParallelQueryExecutionContextBaseStates || (ParallelQueryExecutionContextBaseStates = {}));\n/** @hidden */\nexport class ParallelQueryExecutionContextBase {\n  /**\n   * Provides the ParallelQueryExecutionContextBase.\n   * This is the base class that ParallelQueryExecutionContext and OrderByQueryExecutionContext will derive from.\n   *\n   * When handling a parallelized query, it instantiates one instance of\n   * DocumentProcuder per target partition key range and aggregates the result of each.\n   *\n   * @param clientContext - The service endpoint to use to create the client.\n   * @param collectionLink - The Collection Link\n   * @param options - Represents the feed options.\n   * @param partitionedQueryExecutionInfo - PartitionedQueryExecutionInfo\n   * @hidden\n   */\n  constructor(clientContext, collectionLink, query, options, partitionedQueryExecutionInfo, correlatedActivityId) {\n    this.clientContext = clientContext;\n    this.collectionLink = collectionLink;\n    this.query = query;\n    this.options = options;\n    this.partitionedQueryExecutionInfo = partitionedQueryExecutionInfo;\n    this.correlatedActivityId = correlatedActivityId;\n    this.clientContext = clientContext;\n    this.collectionLink = collectionLink;\n    this.query = query;\n    this.options = options;\n    this.partitionedQueryExecutionInfo = partitionedQueryExecutionInfo;\n    this.correlatedActivityId = correlatedActivityId;\n    this.diagnosticNodeWrapper = {\n      consumed: false,\n      diagnosticNode: new DiagnosticNodeInternal(clientContext.diagnosticLevel, DiagnosticNodeType.PARALLEL_QUERY_NODE, null)\n    };\n    this.diagnosticNodeWrapper.diagnosticNode.addData({\n      stateful: true\n    });\n    this.err = undefined;\n    this.state = ParallelQueryExecutionContextBase.STATES.started;\n    this.routingProvider = new SmartRoutingMapProvider(this.clientContext);\n    this.sortOrders = this.partitionedQueryExecutionInfo.queryInfo.orderBy;\n    this.buffer = [];\n    this.requestContinuation = options ? options.continuationToken || options.continuation : null;\n    // response headers of undergoing operation\n    this.respHeaders = getInitialHeader();\n    // Make priority queue for documentProducers\n    this.unfilledDocumentProducersQueue = new PriorityQueue((a, b) => a.generation - b.generation);\n    // The comparator is supplied by the derived class\n    this.bufferedDocumentProducersQueue = new PriorityQueue((a, b) => this.documentProducerComparator(b, a));\n    // Creating the documentProducers\n    this.sem = semaphore(1);\n    const createDocumentProducersAndFillUpPriorityQueueFunc = async () => {\n      // ensure the lock is released after finishing up\n      try {\n        const targetPartitionRanges = await this._onTargetPartitionRanges();\n        const maxDegreeOfParallelism = options.maxDegreeOfParallelism === undefined || options.maxDegreeOfParallelism < 1 ? targetPartitionRanges.length : Math.min(options.maxDegreeOfParallelism, targetPartitionRanges.length);\n        logger.info(\"Query starting against \" + targetPartitionRanges.length + \" ranges with parallelism of \" + maxDegreeOfParallelism);\n        let filteredPartitionKeyRanges = [];\n        // The document producers generated from filteredPartitionKeyRanges\n        const targetPartitionQueryExecutionContextList = [];\n        if (this.requestContinuation) {\n          throw new Error(\"Continuation tokens are not yet supported for cross partition queries\");\n        } else {\n          filteredPartitionKeyRanges = targetPartitionRanges;\n        }\n        // Create one documentProducer for each partitionTargetRange\n        filteredPartitionKeyRanges.forEach(partitionTargetRange => {\n          // TODO: any partitionTargetRange\n          // no async callback\n          targetPartitionQueryExecutionContextList.push(this._createTargetPartitionQueryExecutionContext(partitionTargetRange, undefined));\n        });\n        // Fill up our priority queue with documentProducers\n        targetPartitionQueryExecutionContextList.forEach(documentProducer => {\n          // has async callback\n          try {\n            this.unfilledDocumentProducersQueue.enq(documentProducer);\n          } catch (e) {\n            this.err = e;\n          }\n        });\n        this.sem.leave();\n      } catch (err) {\n        this.err = err;\n        // release the lock\n        this.sem.leave();\n        return;\n      }\n    };\n    this.sem.take(createDocumentProducersAndFillUpPriorityQueueFunc);\n  }\n  _mergeWithActiveResponseHeaders(headers) {\n    mergeHeaders(this.respHeaders, headers);\n  }\n  _getAndResetActiveResponseHeaders() {\n    const ret = this.respHeaders;\n    this.respHeaders = getInitialHeader();\n    return ret;\n  }\n  getDiagnosticNode() {\n    return this.diagnosticNodeWrapper.diagnosticNode;\n  }\n  async _onTargetPartitionRanges() {\n    // invokes the callback when the target partition ranges are ready\n    const parsedRanges = this.partitionedQueryExecutionInfo.queryRanges;\n    const queryRanges = parsedRanges.map(item => QueryRange.parseFromDict(item));\n    return this.routingProvider.getOverlappingRanges(this.collectionLink, queryRanges, this.getDiagnosticNode());\n  }\n  /**\n   * Gets the replacement ranges for a partitionkeyrange that has been split\n   */\n  async _getReplacementPartitionKeyRanges(documentProducer, diagnosticNode) {\n    const partitionKeyRange = documentProducer.targetPartitionKeyRange;\n    // Download the new routing map\n    this.routingProvider = new SmartRoutingMapProvider(this.clientContext);\n    // Get the queryRange that relates to this partitionKeyRange\n    const queryRange = QueryRange.parsePartitionKeyRange(partitionKeyRange);\n    return this.routingProvider.getOverlappingRanges(this.collectionLink, [queryRange], diagnosticNode);\n  }\n  async _enqueueReplacementDocumentProducers(error, diagnosticNode, documentProducer) {\n    // Get the replacement ranges\n    const replacementPartitionKeyRanges = await this._getReplacementPartitionKeyRanges(documentProducer, diagnosticNode);\n    if (replacementPartitionKeyRanges.length === 0) {\n      throw error;\n    } else if (replacementPartitionKeyRanges.length === 1) {\n      // Partition is gone due to Merge\n      // Create the replacement documentProducer with populateEpkRangeHeaders Flag set to true to set startEpk and endEpk headers\n      const replacementDocumentProducer = this._createTargetPartitionQueryExecutionContext(replacementPartitionKeyRanges[0], documentProducer.continuationToken, documentProducer.startEpk, documentProducer.endEpk, true);\n      this.unfilledDocumentProducersQueue.enq(replacementDocumentProducer);\n    } else {\n      // Create the replacement documentProducers\n      const replacementDocumentProducers = [];\n      replacementPartitionKeyRanges.forEach(partitionKeyRange => {\n        const queryRange = QueryRange.parsePartitionKeyRange(partitionKeyRange);\n        // Create replacment document producers with the parent's continuationToken\n        const replacementDocumentProducer = this._createTargetPartitionQueryExecutionContext(partitionKeyRange, documentProducer.continuationToken, queryRange.min, queryRange.max, false);\n        replacementDocumentProducers.push(replacementDocumentProducer);\n      });\n      // add document producers to the queue\n      replacementDocumentProducers.forEach(replacementDocumentProducer => {\n        if (replacementDocumentProducer.hasMoreResults()) {\n          this.unfilledDocumentProducersQueue.enq(replacementDocumentProducer);\n        }\n      });\n    }\n  }\n  static _needPartitionKeyRangeCacheRefresh(error) {\n    // TODO: any error\n    return error.code === StatusCodes.Gone && \"substatus\" in error && error[\"substatus\"] === SubStatusCodes.PartitionKeyRangeGone;\n  }\n  /**\n   * Determine if there are still remaining resources to processs based on the value of the continuation\n   * token or the elements remaining on the current batch in the QueryIterator.\n   * @returns true if there is other elements to process in the ParallelQueryExecutionContextBase.\n   */\n  hasMoreResults() {\n    return !this.err && (this.buffer.length > 0 || this.state !== ParallelQueryExecutionContextBase.STATES.ended);\n  }\n  /**\n   * Creates target partition range Query Execution Context\n   */\n  _createTargetPartitionQueryExecutionContext(partitionKeyTargetRange, continuationToken, startEpk, endEpk, populateEpkRangeHeaders) {\n    let rewrittenQuery = this.partitionedQueryExecutionInfo.queryInfo.rewrittenQuery;\n    let sqlQuerySpec;\n    const query = this.query;\n    if (typeof query === \"string\") {\n      sqlQuerySpec = {\n        query\n      };\n    } else {\n      sqlQuerySpec = query;\n    }\n    const formatPlaceHolder = \"{documentdb-formattableorderbyquery-filter}\";\n    if (rewrittenQuery) {\n      sqlQuerySpec = JSON.parse(JSON.stringify(sqlQuerySpec));\n      // We hardcode the formattable filter to true for now\n      rewrittenQuery = rewrittenQuery.replace(formatPlaceHolder, \"true\");\n      sqlQuerySpec[\"query\"] = rewrittenQuery;\n    }\n    const options = Object.assign({}, this.options);\n    options.continuationToken = continuationToken;\n    return new DocumentProducer(this.clientContext, this.collectionLink, sqlQuerySpec, partitionKeyTargetRange, options, this.correlatedActivityId, startEpk, endEpk, populateEpkRangeHeaders);\n  }\n  async drainBufferedItems() {\n    return new Promise((resolve, reject) => {\n      this.sem.take(() => {\n        if (this.err) {\n          // if there is a prior error return error\n          this.sem.leave();\n          this.err.headers = this._getAndResetActiveResponseHeaders();\n          reject(this.err);\n          return;\n        }\n        // return undefined if there is no more results\n        if (this.buffer.length === 0) {\n          this.sem.leave();\n          return resolve({\n            result: this.state === ParallelQueryExecutionContextBase.STATES.ended ? undefined : [],\n            headers: this._getAndResetActiveResponseHeaders()\n          });\n        }\n        // draing the entire buffer object and return that in result of return object\n        const bufferedResults = this.buffer;\n        this.buffer = [];\n        // release the lock before returning\n        this.sem.leave();\n        // invoke the callback on the item\n        return resolve({\n          result: bufferedResults,\n          headers: this._getAndResetActiveResponseHeaders()\n        });\n      });\n    });\n  }\n  /**\n   * Buffers document producers based on the maximum degree of parallelism.\n   * Moves document producers from the unfilled queue to the buffered queue.\n   * @param diagnosticNode - The diagnostic node for logging and tracing.\n   * @returns A promise that resolves when buffering is complete.\n   */\n  async bufferDocumentProducers(diagnosticNode) {\n    return new Promise((resolve, reject) => {\n      this.sem.take(async () => {\n        if (this.err) {\n          this.sem.leave();\n          reject(this.err);\n          return;\n        }\n        this.updateStates(this.err);\n        if (this.state === ParallelQueryExecutionContextBase.STATES.ended) {\n          this.sem.leave();\n          resolve();\n          return;\n        }\n        if (this.unfilledDocumentProducersQueue.size() === 0) {\n          this.sem.leave();\n          resolve();\n          return;\n        }\n        try {\n          const maxDegreeOfParallelism = this.options.maxDegreeOfParallelism === undefined || this.options.maxDegreeOfParallelism < 1 ? this.unfilledDocumentProducersQueue.size() : Math.min(this.options.maxDegreeOfParallelism, this.unfilledDocumentProducersQueue.size());\n          const documentProducers = [];\n          while (documentProducers.length < maxDegreeOfParallelism && this.unfilledDocumentProducersQueue.size() > 0) {\n            let documentProducer;\n            try {\n              documentProducer = this.unfilledDocumentProducersQueue.deq();\n            } catch (e) {\n              this.err = e;\n              this.err.headers = this._getAndResetActiveResponseHeaders();\n              reject(this.err);\n              return;\n            }\n            documentProducers.push(documentProducer);\n          }\n          const bufferDocumentProducer = async documentProducer => {\n            try {\n              await documentProducer.bufferMore(diagnosticNode);\n              // if buffer of document producer is filled, add it to the buffered document producers queue\n              const nextItem = documentProducer.peakNextItem();\n              if (nextItem !== undefined) {\n                this.bufferedDocumentProducersQueue.enq(documentProducer);\n              } else if (documentProducer.hasMoreResults()) {\n                this.unfilledDocumentProducersQueue.enq(documentProducer);\n              }\n            } catch (err) {\n              if (ParallelQueryExecutionContextBase._needPartitionKeyRangeCacheRefresh(err)) {\n                // We want the document producer enqueued\n                // So that later parts of the code can repair the execution context\n                // refresh the partition key ranges and ctreate new document producers and add it to the queue\n                await this._enqueueReplacementDocumentProducers(err, diagnosticNode, documentProducer);\n                resolve();\n              } else {\n                this.err = err;\n                this.err.headers = this._getAndResetActiveResponseHeaders();\n                reject(err);\n              }\n            }\n          };\n          try {\n            await Promise.all(documentProducers.map(producer => bufferDocumentProducer(producer)));\n          } catch (err) {\n            this.err = err;\n            this.err.headers = this._getAndResetActiveResponseHeaders();\n            reject(err);\n            return;\n          }\n          resolve();\n        } catch (err) {\n          this.err = err;\n          this.err.headers = this._getAndResetActiveResponseHeaders();\n          reject(err);\n        } finally {\n          this.sem.leave();\n        }\n      });\n    });\n  }\n  /**\n   * Drains the buffer of filled document producers and appends their items to the main buffer.\n   * @param isOrderBy - Indicates if the query is an order by query.\n   * @returns A promise that resolves when the buffer is filled.\n   */\n  async fillBufferFromBufferQueue(isOrderBy = false) {\n    return new Promise((resolve, reject) => {\n      this.sem.take(async () => {\n        if (this.err) {\n          // if there is a prior error return error\n          this.sem.leave();\n          this.err.headers = this._getAndResetActiveResponseHeaders();\n          reject(this.err);\n          return;\n        }\n        if (this.state === ParallelQueryExecutionContextBase.STATES.ended || this.bufferedDocumentProducersQueue.size() === 0) {\n          this.sem.leave();\n          resolve();\n          return;\n        }\n        try {\n          if (isOrderBy) {\n            while (this.unfilledDocumentProducersQueue.isEmpty() && this.bufferedDocumentProducersQueue.size() > 0) {\n              const documentProducer = this.bufferedDocumentProducersQueue.deq();\n              const {\n                result,\n                headers\n              } = await documentProducer.fetchNextItem();\n              this._mergeWithActiveResponseHeaders(headers);\n              if (result) {\n                this.buffer.push(result);\n              }\n              if (documentProducer.peakNextItem() !== undefined) {\n                this.bufferedDocumentProducersQueue.enq(documentProducer);\n              } else if (documentProducer.hasMoreResults()) {\n                this.unfilledDocumentProducersQueue.enq(documentProducer);\n              } else {\n                // no more results in document producer\n              }\n            }\n          } else {\n            while (this.bufferedDocumentProducersQueue.size() > 0) {\n              const documentProducer = this.bufferedDocumentProducersQueue.deq();\n              const {\n                result,\n                headers\n              } = await documentProducer.fetchBufferedItems();\n              this._mergeWithActiveResponseHeaders(headers);\n              if (result) {\n                this.buffer.push(...result);\n              }\n              if (documentProducer.hasMoreResults()) {\n                this.unfilledDocumentProducersQueue.enq(documentProducer);\n              }\n            }\n          }\n          this.updateStates(this.err);\n        } catch (err) {\n          this.err = err;\n          this.err.headers = this._getAndResetActiveResponseHeaders();\n          reject(this.err);\n          return;\n        } finally {\n          // release the lock before returning\n          this.sem.leave();\n        }\n        resolve();\n        return;\n      });\n    });\n  }\n  updateStates(error) {\n    if (error) {\n      this.err = error;\n      this.state = ParallelQueryExecutionContextBase.STATES.ended;\n      return;\n    }\n    if (this.state === ParallelQueryExecutionContextBase.STATES.started) {\n      this.state = ParallelQueryExecutionContextBase.STATES.inProgress;\n    }\n    const hasNoActiveProducers = this.unfilledDocumentProducersQueue.size() === 0 && this.bufferedDocumentProducersQueue.size() === 0;\n    if (hasNoActiveProducers) {\n      this.state = ParallelQueryExecutionContextBase.STATES.ended;\n    }\n  }\n}\nParallelQueryExecutionContextBase.STATES = ParallelQueryExecutionContextBaseStates;","map":{"version":3,"names":["PriorityQueue","semaphore","createClientLogger","StatusCodes","SubStatusCodes","QueryRange","SmartRoutingMapProvider","DocumentProducer","getInitialHeader","mergeHeaders","DiagnosticNodeInternal","DiagnosticNodeType","logger","ParallelQueryExecutionContextBaseStates","ParallelQueryExecutionContextBase","constructor","clientContext","collectionLink","query","options","partitionedQueryExecutionInfo","correlatedActivityId","diagnosticNodeWrapper","consumed","diagnosticNode","diagnosticLevel","PARALLEL_QUERY_NODE","addData","stateful","err","undefined","state","STATES","started","routingProvider","sortOrders","queryInfo","orderBy","buffer","requestContinuation","continuationToken","continuation","respHeaders","unfilledDocumentProducersQueue","a","b","generation","bufferedDocumentProducersQueue","documentProducerComparator","sem","createDocumentProducersAndFillUpPriorityQueueFunc","targetPartitionRanges","_onTargetPartitionRanges","maxDegreeOfParallelism","length","Math","min","info","filteredPartitionKeyRanges","targetPartitionQueryExecutionContextList","Error","forEach","partitionTargetRange","push","_createTargetPartitionQueryExecutionContext","documentProducer","enq","e","leave","take","_mergeWithActiveResponseHeaders","headers","_getAndResetActiveResponseHeaders","ret","getDiagnosticNode","parsedRanges","queryRanges","map","item","parseFromDict","getOverlappingRanges","_getReplacementPartitionKeyRanges","partitionKeyRange","targetPartitionKeyRange","queryRange","parsePartitionKeyRange","_enqueueReplacementDocumentProducers","error","replacementPartitionKeyRanges","replacementDocumentProducer","startEpk","endEpk","replacementDocumentProducers","max","hasMoreResults","_needPartitionKeyRangeCacheRefresh","code","Gone","PartitionKeyRangeGone","ended","partitionKeyTargetRange","populateEpkRangeHeaders","rewrittenQuery","sqlQuerySpec","formatPlaceHolder","JSON","parse","stringify","replace","Object","assign","drainBufferedItems","Promise","resolve","reject","result","bufferedResults","bufferDocumentProducers","updateStates","size","documentProducers","deq","bufferDocumentProducer","bufferMore","nextItem","peakNextItem","all","producer","fillBufferFromBufferQueue","isOrderBy","isEmpty","fetchNextItem","fetchBufferedItems","inProgress","hasNoActiveProducers"],"sources":["/Users/eimis/test-server/Azure Hackthons/azure-cloud-architecture-game /node_modules/@azure/cosmos/src/queryExecutionContext/parallelQueryExecutionContextBase.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport PriorityQueue from \"priorityqueuejs\";\nimport semaphore from \"semaphore\";\nimport type { ClientContext } from \"../ClientContext\";\nimport type { AzureLogger } from \"@azure/logger\";\nimport { createClientLogger } from \"@azure/logger\";\nimport { StatusCodes, SubStatusCodes } from \"../common/statusCodes\";\nimport type { FeedOptions, Response } from \"../request\";\nimport type { PartitionedQueryExecutionInfo } from \"../request/ErrorResponse\";\nimport { QueryRange } from \"../routing/QueryRange\";\nimport { SmartRoutingMapProvider } from \"../routing/smartRoutingMapProvider\";\nimport type { CosmosHeaders } from \"./CosmosHeaders\";\nimport { DocumentProducer } from \"./documentProducer\";\nimport type { ExecutionContext } from \"./ExecutionContext\";\nimport { getInitialHeader, mergeHeaders } from \"./headerUtils\";\nimport type { SqlQuerySpec } from \"./SqlQuerySpec\";\nimport { DiagnosticNodeInternal, DiagnosticNodeType } from \"../diagnostics/DiagnosticNodeInternal\";\n\n/** @hidden */\nconst logger: AzureLogger = createClientLogger(\"parallelQueryExecutionContextBase\");\n\n/** @hidden */\nexport enum ParallelQueryExecutionContextBaseStates {\n  started = \"started\",\n  inProgress = \"inProgress\",\n  ended = \"ended\",\n}\n\n/** @hidden */\nexport abstract class ParallelQueryExecutionContextBase implements ExecutionContext {\n  private err: any;\n  private state: any;\n  private static STATES = ParallelQueryExecutionContextBaseStates;\n  private routingProvider: SmartRoutingMapProvider;\n  protected sortOrders: any;\n  private requestContinuation: any;\n  private respHeaders: CosmosHeaders;\n  private unfilledDocumentProducersQueue: PriorityQueue<DocumentProducer>;\n  private bufferedDocumentProducersQueue: PriorityQueue<DocumentProducer>;\n  // TODO: update type of buffer from any --> generic can be used here\n  private buffer: any[];\n  private sem: any;\n  private diagnosticNodeWrapper: {\n    consumed: boolean;\n    diagnosticNode: DiagnosticNodeInternal;\n  };\n  /**\n   * Provides the ParallelQueryExecutionContextBase.\n   * This is the base class that ParallelQueryExecutionContext and OrderByQueryExecutionContext will derive from.\n   *\n   * When handling a parallelized query, it instantiates one instance of\n   * DocumentProcuder per target partition key range and aggregates the result of each.\n   *\n   * @param clientContext - The service endpoint to use to create the client.\n   * @param collectionLink - The Collection Link\n   * @param options - Represents the feed options.\n   * @param partitionedQueryExecutionInfo - PartitionedQueryExecutionInfo\n   * @hidden\n   */\n  constructor(\n    private clientContext: ClientContext,\n    private collectionLink: string,\n    private query: string | SqlQuerySpec,\n    private options: FeedOptions,\n    private partitionedQueryExecutionInfo: PartitionedQueryExecutionInfo,\n    private correlatedActivityId: string,\n  ) {\n    this.clientContext = clientContext;\n    this.collectionLink = collectionLink;\n    this.query = query;\n    this.options = options;\n    this.partitionedQueryExecutionInfo = partitionedQueryExecutionInfo;\n    this.correlatedActivityId = correlatedActivityId;\n    this.diagnosticNodeWrapper = {\n      consumed: false,\n      diagnosticNode: new DiagnosticNodeInternal(\n        clientContext.diagnosticLevel,\n        DiagnosticNodeType.PARALLEL_QUERY_NODE,\n        null,\n      ),\n    };\n    this.diagnosticNodeWrapper.diagnosticNode.addData({ stateful: true });\n    this.err = undefined;\n    this.state = ParallelQueryExecutionContextBase.STATES.started;\n    this.routingProvider = new SmartRoutingMapProvider(this.clientContext);\n    this.sortOrders = this.partitionedQueryExecutionInfo.queryInfo.orderBy;\n    this.buffer = [];\n\n    this.requestContinuation = options ? options.continuationToken || options.continuation : null;\n    // response headers of undergoing operation\n    this.respHeaders = getInitialHeader();\n    // Make priority queue for documentProducers\n    this.unfilledDocumentProducersQueue = new PriorityQueue<DocumentProducer>(\n      (a: DocumentProducer, b: DocumentProducer) => a.generation - b.generation,\n    );\n    // The comparator is supplied by the derived class\n    this.bufferedDocumentProducersQueue = new PriorityQueue<DocumentProducer>(\n      (a: DocumentProducer, b: DocumentProducer) => this.documentProducerComparator(b, a),\n    );\n    // Creating the documentProducers\n    this.sem = semaphore(1);\n    const createDocumentProducersAndFillUpPriorityQueueFunc = async (): Promise<void> => {\n      // ensure the lock is released after finishing up\n      try {\n        const targetPartitionRanges = await this._onTargetPartitionRanges();\n\n        const maxDegreeOfParallelism =\n          options.maxDegreeOfParallelism === undefined || options.maxDegreeOfParallelism < 1\n            ? targetPartitionRanges.length\n            : Math.min(options.maxDegreeOfParallelism, targetPartitionRanges.length);\n\n        logger.info(\n          \"Query starting against \" +\n            targetPartitionRanges.length +\n            \" ranges with parallelism of \" +\n            maxDegreeOfParallelism,\n        );\n\n        let filteredPartitionKeyRanges = [];\n        // The document producers generated from filteredPartitionKeyRanges\n        const targetPartitionQueryExecutionContextList: DocumentProducer[] = [];\n\n        if (this.requestContinuation) {\n          throw new Error(\"Continuation tokens are not yet supported for cross partition queries\");\n        } else {\n          filteredPartitionKeyRanges = targetPartitionRanges;\n        }\n        // Create one documentProducer for each partitionTargetRange\n        filteredPartitionKeyRanges.forEach((partitionTargetRange: any) => {\n          // TODO: any partitionTargetRange\n          // no async callback\n          targetPartitionQueryExecutionContextList.push(\n            this._createTargetPartitionQueryExecutionContext(partitionTargetRange, undefined),\n          );\n        });\n\n        // Fill up our priority queue with documentProducers\n        targetPartitionQueryExecutionContextList.forEach((documentProducer): void => {\n          // has async callback\n          try {\n            this.unfilledDocumentProducersQueue.enq(documentProducer);\n          } catch (e: any) {\n            this.err = e;\n          }\n        });\n\n        this.sem.leave();\n      } catch (err: any) {\n        this.err = err;\n        // release the lock\n        this.sem.leave();\n        return;\n      }\n    };\n    this.sem.take(createDocumentProducersAndFillUpPriorityQueueFunc);\n  }\n\n  protected abstract documentProducerComparator(\n    dp1: DocumentProducer,\n    dp2: DocumentProducer,\n  ): number;\n\n  private _mergeWithActiveResponseHeaders(headers: CosmosHeaders): void {\n    mergeHeaders(this.respHeaders, headers);\n  }\n\n  private _getAndResetActiveResponseHeaders(): CosmosHeaders {\n    const ret = this.respHeaders;\n    this.respHeaders = getInitialHeader();\n    return ret;\n  }\n\n  private getDiagnosticNode(): DiagnosticNodeInternal {\n    return this.diagnosticNodeWrapper.diagnosticNode;\n  }\n\n  private async _onTargetPartitionRanges(): Promise<any[]> {\n    // invokes the callback when the target partition ranges are ready\n    const parsedRanges = this.partitionedQueryExecutionInfo.queryRanges;\n    const queryRanges = parsedRanges.map((item) => QueryRange.parseFromDict(item));\n    return this.routingProvider.getOverlappingRanges(\n      this.collectionLink,\n      queryRanges,\n      this.getDiagnosticNode(),\n    );\n  }\n\n  /**\n   * Gets the replacement ranges for a partitionkeyrange that has been split\n   */\n  private async _getReplacementPartitionKeyRanges(\n    documentProducer: DocumentProducer,\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<any[]> {\n    const partitionKeyRange = documentProducer.targetPartitionKeyRange;\n    // Download the new routing map\n    this.routingProvider = new SmartRoutingMapProvider(this.clientContext);\n    // Get the queryRange that relates to this partitionKeyRange\n    const queryRange = QueryRange.parsePartitionKeyRange(partitionKeyRange);\n    return this.routingProvider.getOverlappingRanges(\n      this.collectionLink,\n      [queryRange],\n      diagnosticNode,\n    );\n  }\n\n  private async _enqueueReplacementDocumentProducers(\n    error: any,\n    diagnosticNode: DiagnosticNodeInternal,\n    documentProducer: DocumentProducer,\n  ): Promise<void> {\n    // Get the replacement ranges\n    const replacementPartitionKeyRanges = await this._getReplacementPartitionKeyRanges(\n      documentProducer,\n      diagnosticNode,\n    );\n\n    if (replacementPartitionKeyRanges.length === 0) {\n      throw error;\n    } else if (replacementPartitionKeyRanges.length === 1) {\n      // Partition is gone due to Merge\n      // Create the replacement documentProducer with populateEpkRangeHeaders Flag set to true to set startEpk and endEpk headers\n      const replacementDocumentProducer = this._createTargetPartitionQueryExecutionContext(\n        replacementPartitionKeyRanges[0],\n        documentProducer.continuationToken,\n        documentProducer.startEpk,\n        documentProducer.endEpk,\n        true,\n      );\n\n      this.unfilledDocumentProducersQueue.enq(replacementDocumentProducer);\n    } else {\n      // Create the replacement documentProducers\n      const replacementDocumentProducers: DocumentProducer[] = [];\n      replacementPartitionKeyRanges.forEach((partitionKeyRange) => {\n        const queryRange = QueryRange.parsePartitionKeyRange(partitionKeyRange);\n        // Create replacment document producers with the parent's continuationToken\n        const replacementDocumentProducer = this._createTargetPartitionQueryExecutionContext(\n          partitionKeyRange,\n          documentProducer.continuationToken,\n          queryRange.min,\n          queryRange.max,\n          false,\n        );\n        replacementDocumentProducers.push(replacementDocumentProducer);\n      });\n\n      // add document producers to the queue\n      replacementDocumentProducers.forEach((replacementDocumentProducer) => {\n        if (replacementDocumentProducer.hasMoreResults()) {\n          this.unfilledDocumentProducersQueue.enq(replacementDocumentProducer);\n        }\n      });\n    }\n  }\n\n  private static _needPartitionKeyRangeCacheRefresh(error: any): boolean {\n    // TODO: any error\n    return (\n      error.code === StatusCodes.Gone &&\n      \"substatus\" in error &&\n      error[\"substatus\"] === SubStatusCodes.PartitionKeyRangeGone\n    );\n  }\n\n  /**\n   * Determine if there are still remaining resources to processs based on the value of the continuation\n   * token or the elements remaining on the current batch in the QueryIterator.\n   * @returns true if there is other elements to process in the ParallelQueryExecutionContextBase.\n   */\n  public hasMoreResults(): boolean {\n    return (\n      !this.err &&\n      (this.buffer.length > 0 || this.state !== ParallelQueryExecutionContextBase.STATES.ended)\n    );\n  }\n\n  /**\n   * Creates target partition range Query Execution Context\n   */\n  private _createTargetPartitionQueryExecutionContext(\n    partitionKeyTargetRange: any,\n    continuationToken?: any,\n    startEpk?: string,\n    endEpk?: string,\n    populateEpkRangeHeaders?: boolean,\n  ): DocumentProducer {\n    let rewrittenQuery = this.partitionedQueryExecutionInfo.queryInfo.rewrittenQuery;\n    let sqlQuerySpec: SqlQuerySpec;\n    const query = this.query;\n    if (typeof query === \"string\") {\n      sqlQuerySpec = { query };\n    } else {\n      sqlQuerySpec = query;\n    }\n\n    const formatPlaceHolder = \"{documentdb-formattableorderbyquery-filter}\";\n    if (rewrittenQuery) {\n      sqlQuerySpec = JSON.parse(JSON.stringify(sqlQuerySpec));\n      // We hardcode the formattable filter to true for now\n      rewrittenQuery = rewrittenQuery.replace(formatPlaceHolder, \"true\");\n      sqlQuerySpec[\"query\"] = rewrittenQuery;\n    }\n\n    const options = { ...this.options };\n    options.continuationToken = continuationToken;\n\n    return new DocumentProducer(\n      this.clientContext,\n      this.collectionLink,\n      sqlQuerySpec,\n      partitionKeyTargetRange,\n      options,\n      this.correlatedActivityId,\n      startEpk,\n      endEpk,\n      populateEpkRangeHeaders,\n    );\n  }\n  protected async drainBufferedItems(): Promise<Response<any>> {\n    return new Promise<Response<any>>((resolve, reject) => {\n      this.sem.take(() => {\n        if (this.err) {\n          // if there is a prior error return error\n          this.sem.leave();\n          this.err.headers = this._getAndResetActiveResponseHeaders();\n          reject(this.err);\n          return;\n        }\n\n        // return undefined if there is no more results\n        if (this.buffer.length === 0) {\n          this.sem.leave();\n          return resolve({\n            result: this.state === ParallelQueryExecutionContextBase.STATES.ended ? undefined : [],\n            headers: this._getAndResetActiveResponseHeaders(),\n          });\n        }\n        // draing the entire buffer object and return that in result of return object\n        const bufferedResults = this.buffer;\n        this.buffer = [];\n\n        // release the lock before returning\n        this.sem.leave();\n        // invoke the callback on the item\n        return resolve({\n          result: bufferedResults,\n          headers: this._getAndResetActiveResponseHeaders(),\n        });\n      });\n    });\n  }\n\n  /**\n   * Buffers document producers based on the maximum degree of parallelism.\n   * Moves document producers from the unfilled queue to the buffered queue.\n   * @param diagnosticNode - The diagnostic node for logging and tracing.\n   * @returns A promise that resolves when buffering is complete.\n   */\n  protected async bufferDocumentProducers(diagnosticNode?: DiagnosticNodeInternal): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      this.sem.take(async () => {\n        if (this.err) {\n          this.sem.leave();\n          reject(this.err);\n          return;\n        }\n        this.updateStates(this.err);\n\n        if (this.state === ParallelQueryExecutionContextBase.STATES.ended) {\n          this.sem.leave();\n          resolve();\n          return;\n        }\n\n        if (this.unfilledDocumentProducersQueue.size() === 0) {\n          this.sem.leave();\n          resolve();\n          return;\n        }\n\n        try {\n          const maxDegreeOfParallelism =\n            this.options.maxDegreeOfParallelism === undefined ||\n            this.options.maxDegreeOfParallelism < 1\n              ? this.unfilledDocumentProducersQueue.size()\n              : Math.min(\n                  this.options.maxDegreeOfParallelism,\n                  this.unfilledDocumentProducersQueue.size(),\n                );\n\n          const documentProducers: DocumentProducer[] = [];\n          while (\n            documentProducers.length < maxDegreeOfParallelism &&\n            this.unfilledDocumentProducersQueue.size() > 0\n          ) {\n            let documentProducer: DocumentProducer;\n            try {\n              documentProducer = this.unfilledDocumentProducersQueue.deq();\n            } catch (e: any) {\n              this.err = e;\n              this.err.headers = this._getAndResetActiveResponseHeaders();\n              reject(this.err);\n              return;\n            }\n            documentProducers.push(documentProducer);\n          }\n\n          const bufferDocumentProducer = async (\n            documentProducer: DocumentProducer,\n          ): Promise<void> => {\n            try {\n              await documentProducer.bufferMore(diagnosticNode);\n              // if buffer of document producer is filled, add it to the buffered document producers queue\n              const nextItem = documentProducer.peakNextItem();\n              if (nextItem !== undefined) {\n                this.bufferedDocumentProducersQueue.enq(documentProducer);\n              } else if (documentProducer.hasMoreResults()) {\n                this.unfilledDocumentProducersQueue.enq(documentProducer);\n              }\n            } catch (err) {\n              if (ParallelQueryExecutionContextBase._needPartitionKeyRangeCacheRefresh(err)) {\n                // We want the document producer enqueued\n                // So that later parts of the code can repair the execution context\n                // refresh the partition key ranges and ctreate new document producers and add it to the queue\n                await this._enqueueReplacementDocumentProducers(\n                  err,\n                  diagnosticNode,\n                  documentProducer,\n                );\n                resolve();\n              } else {\n                this.err = err;\n                this.err.headers = this._getAndResetActiveResponseHeaders();\n                reject(err);\n              }\n            }\n          };\n\n          try {\n            await Promise.all(\n              documentProducers.map((producer) => bufferDocumentProducer(producer)),\n            );\n          } catch (err) {\n            this.err = err;\n            this.err.headers = this._getAndResetActiveResponseHeaders();\n            reject(err);\n            return;\n          }\n          resolve();\n        } catch (err) {\n          this.err = err;\n          this.err.headers = this._getAndResetActiveResponseHeaders();\n          reject(err);\n        } finally {\n          this.sem.leave();\n        }\n      });\n    });\n  }\n  /**\n   * Drains the buffer of filled document producers and appends their items to the main buffer.\n   * @param isOrderBy - Indicates if the query is an order by query.\n   * @returns A promise that resolves when the buffer is filled.\n   */\n  protected async fillBufferFromBufferQueue(isOrderBy: boolean = false): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      this.sem.take(async () => {\n        if (this.err) {\n          // if there is a prior error return error\n          this.sem.leave();\n          this.err.headers = this._getAndResetActiveResponseHeaders();\n          reject(this.err);\n          return;\n        }\n\n        if (\n          this.state === ParallelQueryExecutionContextBase.STATES.ended ||\n          this.bufferedDocumentProducersQueue.size() === 0\n        ) {\n          this.sem.leave();\n          resolve();\n          return;\n        }\n\n        try {\n          if (isOrderBy) {\n            while (\n              this.unfilledDocumentProducersQueue.isEmpty() &&\n              this.bufferedDocumentProducersQueue.size() > 0\n            ) {\n              const documentProducer = this.bufferedDocumentProducersQueue.deq();\n              const { result, headers } = await documentProducer.fetchNextItem();\n              this._mergeWithActiveResponseHeaders(headers);\n              if (result) {\n                this.buffer.push(result);\n              }\n              if (documentProducer.peakNextItem() !== undefined) {\n                this.bufferedDocumentProducersQueue.enq(documentProducer);\n              } else if (documentProducer.hasMoreResults()) {\n                this.unfilledDocumentProducersQueue.enq(documentProducer);\n              } else {\n                // no more results in document producer\n              }\n            }\n          } else {\n            while (this.bufferedDocumentProducersQueue.size() > 0) {\n              const documentProducer = this.bufferedDocumentProducersQueue.deq();\n              const { result, headers } = await documentProducer.fetchBufferedItems();\n              this._mergeWithActiveResponseHeaders(headers);\n              if (result) {\n                this.buffer.push(...result);\n              }\n              if (documentProducer.hasMoreResults()) {\n                this.unfilledDocumentProducersQueue.enq(documentProducer);\n              }\n            }\n          }\n          this.updateStates(this.err);\n        } catch (err) {\n          this.err = err;\n          this.err.headers = this._getAndResetActiveResponseHeaders();\n          reject(this.err);\n          return;\n        } finally {\n          // release the lock before returning\n          this.sem.leave();\n        }\n        resolve();\n        return;\n      });\n    });\n  }\n\n  private updateStates(error: any): void {\n    if (error) {\n      this.err = error;\n      this.state = ParallelQueryExecutionContextBase.STATES.ended;\n      return;\n    }\n\n    if (this.state === ParallelQueryExecutionContextBase.STATES.started) {\n      this.state = ParallelQueryExecutionContextBase.STATES.inProgress;\n    }\n\n    const hasNoActiveProducers =\n      this.unfilledDocumentProducersQueue.size() === 0 &&\n      this.bufferedDocumentProducersQueue.size() === 0;\n\n    if (hasNoActiveProducers) {\n      this.state = ParallelQueryExecutionContextBase.STATES.ended;\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}