{"ast":null,"code":"import { ErrorResponse } from \"../../request\";\nimport { isPrimitivePartitionKeyValue } from \"../../utils/typeChecks\";\nimport { ChangeFeedStartFromBeginning } from \"./ChangeFeedStartFromBeginning\";\nimport { Constants } from \"../../common\";\nimport { ChangeFeedStartFromTime } from \"./ChangeFeedStartFromTime\";\nimport { QueryRange } from \"../../routing\";\nimport { FeedRangeInternal } from \"./FeedRange\";\nimport { hashV2PartitionKey } from \"../../utils/hashing/v2\";\nimport { ChangeFeedMode } from \"./ChangeFeedMode\";\n/**\n * @hidden\n * Validates the change feed options passed by the user\n */\nexport function validateChangeFeedIteratorOptions(options) {\n  if (!isChangeFeedIteratorOptions(options)) {\n    throw new ErrorResponse(\"Invalid Changefeed Iterator Options.\");\n  }\n  if ((options === null || options === void 0 ? void 0 : options.maxItemCount) && typeof (options === null || options === void 0 ? void 0 : options.maxItemCount) !== \"number\") {\n    throw new ErrorResponse(\"maxItemCount must be number\");\n  }\n  if ((options === null || options === void 0 ? void 0 : options.maxItemCount) !== undefined && (options === null || options === void 0 ? void 0 : options.maxItemCount) < 1) {\n    throw new ErrorResponse(\"maxItemCount must be a positive number\");\n  }\n}\nfunction isChangeFeedIteratorOptions(options) {\n  if (typeof options !== \"object\") {\n    return false;\n  }\n  if (Object.keys(options).length === 0 && JSON.stringify(options) === \"{}\") {\n    return true;\n  }\n  return options && !(isPrimitivePartitionKeyValue(options) || Array.isArray(options));\n}\n/**\n * @hidden\n * Checks if pkRange entirely covers the given overLapping range or there is only partial overlap.\n *\n * If no complete overlap, exact range which overlaps is retured which is used to set minEpk and maxEpk headers while quering change feed.\n */\nexport async function extractOverlappingRanges(epkRange, overLappingRange) {\n  if (overLappingRange.minInclusive >= epkRange.min && overLappingRange.maxExclusive <= epkRange.max) {\n    return [undefined, undefined];\n  } else if (overLappingRange.minInclusive <= epkRange.min && overLappingRange.maxExclusive >= epkRange.max) {\n    return [epkRange.min, epkRange.max];\n  }\n  // Right Side of overlapping range is covered\n  else if (overLappingRange.minInclusive <= epkRange.min && overLappingRange.maxExclusive <= epkRange.max && overLappingRange.maxExclusive >= epkRange.min) {\n    return [epkRange.min, overLappingRange.maxExclusive];\n  }\n  // Left Side of overlapping range is covered\n  else {\n    return [overLappingRange.minInclusive, epkRange.max];\n  }\n}\n/**\n * @hidden\n * Checks if the object is a valid EpkRange\n */\nexport function isEpkRange(obj) {\n  return obj instanceof FeedRangeInternal && typeof obj.minInclusive === \"string\" && typeof obj.maxExclusive === \"string\" && obj.minInclusive >= Constants.EffectivePartitionKeyConstants.MinimumInclusiveEffectivePartitionKey && obj.maxExclusive <= Constants.EffectivePartitionKeyConstants.MaximumExclusiveEffectivePartitionKey && obj.maxExclusive > obj.minInclusive;\n}\n/**\n * @hidden\n */\nexport function buildInternalChangeFeedOptions(options, continuationToken, startTime, startFromNow) {\n  const internalCfOptions = {};\n  internalCfOptions.maxItemCount = options === null || options === void 0 ? void 0 : options.maxItemCount;\n  internalCfOptions.sessionToken = options === null || options === void 0 ? void 0 : options.sessionToken;\n  internalCfOptions.continuationToken = continuationToken;\n  internalCfOptions.changeFeedMode = options === null || options === void 0 ? void 0 : options.changeFeedMode;\n  // Default option of changefeed is to start from now.\n  if (startFromNow) {\n    internalCfOptions.startFromNow = true;\n  } else {\n    internalCfOptions.startTime = startTime;\n  }\n  return internalCfOptions;\n}\n/**\n * @hidden\n */\nexport function fetchStartTime(changeFeedStartFrom) {\n  if (changeFeedStartFrom instanceof ChangeFeedStartFromBeginning) {\n    return undefined;\n  } else if (changeFeedStartFrom instanceof ChangeFeedStartFromTime) {\n    return changeFeedStartFrom.getStartTime();\n  }\n}\n/**\n * @hidden\n */\nexport function isNullOrEmpty(text) {\n  return text === null || text === undefined || text.trim() === \"\";\n}\n/**\n * @hidden\n */\nexport async function getEPKRangeForPrefixPartitionKey(internalPartitionKey) {\n  const minEPK = getEffectivePartitionKeyForMultiHashPartitioning(internalPartitionKey);\n  const maxEPK = minEPK + Constants.EffectivePartitionKeyConstants.MaximumExclusiveEffectivePartitionKey;\n  return new QueryRange(minEPK, maxEPK, true, false);\n}\n/**\n * @hidden\n */\nexport function getEffectivePartitionKeyForMultiHashPartitioning(partitionKeyInternal) {\n  const hashArray = partitionKeyInternal.map(item => hashV2PartitionKey([item]));\n  return hashArray.join(\"\");\n}\n/**\n * @hidden\n */\nexport async function decryptChangeFeedResponse(result, diagnosticNode, changeFeedMode, encryptionProcessor) {\n  let count = 0;\n  diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsDecryptOperation);\n  for (let item of result.result) {\n    if (changeFeedMode === ChangeFeedMode.AllVersionsAndDeletes) {\n      if (\"current\" in item && item.current !== null) {\n        const {\n          body,\n          propertiesDecryptedCount\n        } = await encryptionProcessor.decrypt(item.current);\n        item.current = body;\n        count += propertiesDecryptedCount;\n      }\n      if (\"previous\" in item && item.previous !== null) {\n        const {\n          body,\n          propertiesDecryptedCount\n        } = await encryptionProcessor.decrypt(item.previous);\n        item.previous = body;\n        count += propertiesDecryptedCount;\n      }\n    } else {\n      const {\n        body,\n        propertiesDecryptedCount\n      } = await encryptionProcessor.decrypt(item);\n      item = body;\n      count += propertiesDecryptedCount;\n    }\n  }\n  diagnosticNode.endEncryptionDiagnostics(Constants.Encryption.DiagnosticsDecryptOperation, count);\n}","map":{"version":3,"names":["ErrorResponse","isPrimitivePartitionKeyValue","ChangeFeedStartFromBeginning","Constants","ChangeFeedStartFromTime","QueryRange","FeedRangeInternal","hashV2PartitionKey","ChangeFeedMode","validateChangeFeedIteratorOptions","options","isChangeFeedIteratorOptions","maxItemCount","undefined","Object","keys","length","JSON","stringify","Array","isArray","extractOverlappingRanges","epkRange","overLappingRange","minInclusive","min","maxExclusive","max","isEpkRange","obj","EffectivePartitionKeyConstants","MinimumInclusiveEffectivePartitionKey","MaximumExclusiveEffectivePartitionKey","buildInternalChangeFeedOptions","continuationToken","startTime","startFromNow","internalCfOptions","sessionToken","changeFeedMode","fetchStartTime","changeFeedStartFrom","getStartTime","isNullOrEmpty","text","trim","getEPKRangeForPrefixPartitionKey","internalPartitionKey","minEPK","getEffectivePartitionKeyForMultiHashPartitioning","maxEPK","partitionKeyInternal","hashArray","map","item","join","decryptChangeFeedResponse","result","diagnosticNode","encryptionProcessor","count","beginEncryptionDiagnostics","Encryption","DiagnosticsDecryptOperation","AllVersionsAndDeletes","current","body","propertiesDecryptedCount","decrypt","previous","endEncryptionDiagnostics"],"sources":["/Users/eimis/test-server/Azure Hackthons/azure-cloud-architecture-game /node_modules/@azure/cosmos/src/client/ChangeFeed/changeFeedUtils.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { ChangeFeedIteratorOptions } from \"./ChangeFeedIteratorOptions\";\nimport { ErrorResponse } from \"../../request\";\nimport type { PartitionKeyRange } from \"../Container\";\nimport type { InternalChangeFeedIteratorOptions } from \"./InternalChangeFeedOptions\";\nimport { isPrimitivePartitionKeyValue } from \"../../utils/typeChecks\";\nimport type { ChangeFeedStartFrom } from \"./ChangeFeedStartFrom\";\nimport { ChangeFeedStartFromBeginning } from \"./ChangeFeedStartFromBeginning\";\nimport { Constants } from \"../../common\";\nimport { ChangeFeedStartFromTime } from \"./ChangeFeedStartFromTime\";\nimport { QueryRange } from \"../../routing\";\nimport { FeedRangeInternal } from \"./FeedRange\";\nimport { hashV2PartitionKey } from \"../../utils/hashing/v2\";\nimport { PartitionKeyInternal } from \"../../documents/PartitionKeyInternal\";\nimport { DiagnosticNodeInternal } from \"../../diagnostics/DiagnosticNodeInternal\";\nimport { EncryptionProcessor } from \"../../encryption\";\nimport { ChangeFeedMode } from \"./ChangeFeedMode\";\nimport { ChangeFeedIteratorResponse } from \"./ChangeFeedIteratorResponse\";\n\n/**\n * @hidden\n * Validates the change feed options passed by the user\n */\nexport function validateChangeFeedIteratorOptions(options: ChangeFeedIteratorOptions): void {\n  if (!isChangeFeedIteratorOptions(options)) {\n    throw new ErrorResponse(\"Invalid Changefeed Iterator Options.\");\n  }\n  if (options?.maxItemCount && typeof options?.maxItemCount !== \"number\") {\n    throw new ErrorResponse(\"maxItemCount must be number\");\n  }\n  if (options?.maxItemCount !== undefined && options?.maxItemCount < 1) {\n    throw new ErrorResponse(\"maxItemCount must be a positive number\");\n  }\n}\n\nfunction isChangeFeedIteratorOptions(options: unknown): options is ChangeFeedIteratorOptions {\n  if (typeof options !== \"object\") {\n    return false;\n  }\n  if (Object.keys(options).length === 0 && JSON.stringify(options) === \"{}\") {\n    return true;\n  }\n  return options && !(isPrimitivePartitionKeyValue(options) || Array.isArray(options));\n}\n\n/**\n * @hidden\n * Checks if pkRange entirely covers the given overLapping range or there is only partial overlap.\n *\n * If no complete overlap, exact range which overlaps is retured which is used to set minEpk and maxEpk headers while quering change feed.\n */\nexport async function extractOverlappingRanges(\n  epkRange: QueryRange,\n  overLappingRange: PartitionKeyRange,\n): Promise<[string, string]> {\n  if (\n    overLappingRange.minInclusive >= epkRange.min &&\n    overLappingRange.maxExclusive <= epkRange.max\n  ) {\n    return [undefined, undefined];\n  } else if (\n    overLappingRange.minInclusive <= epkRange.min &&\n    overLappingRange.maxExclusive >= epkRange.max\n  ) {\n    return [epkRange.min, epkRange.max];\n  }\n  // Right Side of overlapping range is covered\n  else if (\n    overLappingRange.minInclusive <= epkRange.min &&\n    overLappingRange.maxExclusive <= epkRange.max &&\n    overLappingRange.maxExclusive >= epkRange.min\n  ) {\n    return [epkRange.min, overLappingRange.maxExclusive];\n  }\n  // Left Side of overlapping range is covered\n  else {\n    return [overLappingRange.minInclusive, epkRange.max];\n  }\n}\n\n/**\n * @hidden\n * Checks if the object is a valid EpkRange\n */\nexport function isEpkRange(obj: unknown): boolean {\n  return (\n    obj instanceof FeedRangeInternal &&\n    typeof obj.minInclusive === \"string\" &&\n    typeof obj.maxExclusive === \"string\" &&\n    obj.minInclusive >=\n      Constants.EffectivePartitionKeyConstants.MinimumInclusiveEffectivePartitionKey &&\n    obj.maxExclusive <=\n      Constants.EffectivePartitionKeyConstants.MaximumExclusiveEffectivePartitionKey &&\n    obj.maxExclusive > obj.minInclusive\n  );\n}\n\n/**\n * @hidden\n */\nexport function buildInternalChangeFeedOptions(\n  options: ChangeFeedIteratorOptions,\n  continuationToken?: string,\n  startTime?: Date,\n  startFromNow?: boolean,\n): InternalChangeFeedIteratorOptions {\n  const internalCfOptions = {} as InternalChangeFeedIteratorOptions;\n  internalCfOptions.maxItemCount = options?.maxItemCount;\n  internalCfOptions.sessionToken = options?.sessionToken;\n  internalCfOptions.continuationToken = continuationToken;\n  internalCfOptions.changeFeedMode = options?.changeFeedMode;\n  // Default option of changefeed is to start from now.\n  if (startFromNow) {\n    internalCfOptions.startFromNow = true;\n  } else {\n    internalCfOptions.startTime = startTime;\n  }\n  return internalCfOptions;\n}\n/**\n * @hidden\n */\nexport function fetchStartTime(changeFeedStartFrom: ChangeFeedStartFrom): Date | undefined {\n  if (changeFeedStartFrom instanceof ChangeFeedStartFromBeginning) {\n    return undefined;\n  } else if (changeFeedStartFrom instanceof ChangeFeedStartFromTime) {\n    return changeFeedStartFrom.getStartTime();\n  }\n}\n\n/**\n * @hidden\n */\nexport function isNullOrEmpty(text: string | null | undefined): boolean {\n  return text === null || text === undefined || text.trim() === \"\";\n}\n\n/**\n * @hidden\n */\nexport async function getEPKRangeForPrefixPartitionKey(\n  internalPartitionKey: PartitionKeyInternal,\n): Promise<QueryRange> {\n  const minEPK = getEffectivePartitionKeyForMultiHashPartitioning(internalPartitionKey);\n  const maxEPK =\n    minEPK + Constants.EffectivePartitionKeyConstants.MaximumExclusiveEffectivePartitionKey;\n  return new QueryRange(minEPK, maxEPK, true, false);\n}\n\n/**\n * @hidden\n */\nexport function getEffectivePartitionKeyForMultiHashPartitioning(\n  partitionKeyInternal: PartitionKeyInternal,\n): string {\n  const hashArray = partitionKeyInternal.map((item) => hashV2PartitionKey([item]));\n  return hashArray.join(\"\");\n}\n\n/**\n * @hidden\n */\nexport async function decryptChangeFeedResponse(\n  result: ChangeFeedIteratorResponse<any>,\n  diagnosticNode: DiagnosticNodeInternal,\n  changeFeedMode: ChangeFeedMode,\n  encryptionProcessor: EncryptionProcessor,\n): Promise<void> {\n  let count = 0;\n  diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsDecryptOperation);\n  for (let item of result.result) {\n    if (changeFeedMode === ChangeFeedMode.AllVersionsAndDeletes) {\n      if (\"current\" in item && item.current !== null) {\n        const { body, propertiesDecryptedCount } = await encryptionProcessor.decrypt(item.current);\n        item.current = body;\n        count += propertiesDecryptedCount;\n      }\n      if (\"previous\" in item && item.previous !== null) {\n        const { body, propertiesDecryptedCount } = await encryptionProcessor.decrypt(item.previous);\n        item.previous = body;\n        count += propertiesDecryptedCount;\n      }\n    } else {\n      const { body, propertiesDecryptedCount } = await encryptionProcessor.decrypt(item);\n      item = body;\n      count += propertiesDecryptedCount;\n    }\n  }\n  diagnosticNode.endEncryptionDiagnostics(Constants.Encryption.DiagnosticsDecryptOperation, count);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}