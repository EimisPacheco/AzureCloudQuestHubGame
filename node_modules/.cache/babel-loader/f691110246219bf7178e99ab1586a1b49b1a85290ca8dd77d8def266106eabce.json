{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/**\n * Parses a Key Vault identifier into its components.\n *\n * @param collection - The collection of the Key Vault identifier.\n * @param identifier - The Key Vault identifier to be parsed.\n */\nexport function parseKeyVaultIdentifier(collection, identifier) {\n  if (typeof collection !== \"string\" || !(collection = collection.trim())) {\n    throw new Error(\"Invalid collection argument\");\n  }\n  if (typeof identifier !== \"string\" || !(identifier = identifier.trim())) {\n    throw new Error(\"Invalid identifier argument\");\n  }\n  let baseUri;\n  try {\n    baseUri = new URL(identifier);\n  } catch (e) {\n    throw new Error(`Invalid ${collection} identifier: ${identifier}. Not a valid URI`);\n  }\n  // Path is of the form '/collection/name[/version]'\n  const segments = (baseUri.pathname || \"\").split(\"/\");\n  if (segments.length !== 3 && segments.length !== 4) {\n    throw new Error(`Invalid ${collection} identifier: ${identifier}. Bad number of segments: ${segments.length}`);\n  }\n  if (collection !== segments[1]) {\n    throw new Error(`Invalid ${collection} identifier: ${identifier}. segment [1] should be \"${collection}\", found \"${segments[1]}\"`);\n  }\n  const vaultUrl = `${baseUri.protocol}//${baseUri.host}`;\n  const name = segments[2];\n  const version = segments.length === 4 ? segments[3] : undefined;\n  return {\n    vaultUrl,\n    name,\n    version\n  };\n}","map":{"version":3,"names":["parseKeyVaultIdentifier","collection","identifier","trim","Error","baseUri","URL","e","segments","pathname","split","length","vaultUrl","protocol","host","name","version","undefined"],"sources":["/Users/eimis/test-server/Azure Hackthons/azure-cloud-architecture-game /node_modules/@azure/keyvault-common/src/parseKeyVaultIdentifier.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n/**\n * The parsed components of a Key Vault entity identifier.\n */\nexport interface KeyVaultEntityIdentifier {\n  /**\n   * The vault URI.\n   */\n  vaultUrl: string;\n  /**\n   * The version of key/secret/certificate. May be undefined.\n   */\n  version?: string;\n  /**\n   * The name of key/secret/certificate.\n   */\n  name: string;\n}\n\n/**\n * Parses a Key Vault identifier into its components.\n *\n * @param collection - The collection of the Key Vault identifier.\n * @param identifier - The Key Vault identifier to be parsed.\n */\nexport function parseKeyVaultIdentifier(\n  collection: string,\n  identifier: string | undefined,\n): KeyVaultEntityIdentifier {\n  if (typeof collection !== \"string\" || !(collection = collection.trim())) {\n    throw new Error(\"Invalid collection argument\");\n  }\n\n  if (typeof identifier !== \"string\" || !(identifier = identifier.trim())) {\n    throw new Error(\"Invalid identifier argument\");\n  }\n\n  let baseUri;\n  try {\n    baseUri = new URL(identifier);\n  } catch (e: any) {\n    throw new Error(`Invalid ${collection} identifier: ${identifier}. Not a valid URI`);\n  }\n\n  // Path is of the form '/collection/name[/version]'\n  const segments = (baseUri.pathname || \"\").split(\"/\");\n  if (segments.length !== 3 && segments.length !== 4) {\n    throw new Error(\n      `Invalid ${collection} identifier: ${identifier}. Bad number of segments: ${segments.length}`,\n    );\n  }\n\n  if (collection !== segments[1]) {\n    throw new Error(\n      `Invalid ${collection} identifier: ${identifier}. segment [1] should be \"${collection}\", found \"${segments[1]}\"`,\n    );\n  }\n\n  const vaultUrl = `${baseUri.protocol}//${baseUri.host}`;\n  const name = segments[2];\n  const version = segments.length === 4 ? segments[3] : undefined;\n  return {\n    vaultUrl,\n    name,\n    version,\n  };\n}\n"],"mappings":"AAAA;AACA;AAoBA;;;;;;AAMA,OAAM,SAAUA,uBAAuBA,CACrCC,UAAkB,EAClBC,UAA8B;EAE9B,IAAI,OAAOD,UAAU,KAAK,QAAQ,IAAI,EAAEA,UAAU,GAAGA,UAAU,CAACE,IAAI,EAAE,CAAC,EAAE;IACvE,MAAM,IAAIC,KAAK,CAAC,6BAA6B,CAAC;EAChD;EAEA,IAAI,OAAOF,UAAU,KAAK,QAAQ,IAAI,EAAEA,UAAU,GAAGA,UAAU,CAACC,IAAI,EAAE,CAAC,EAAE;IACvE,MAAM,IAAIC,KAAK,CAAC,6BAA6B,CAAC;EAChD;EAEA,IAAIC,OAAO;EACX,IAAI;IACFA,OAAO,GAAG,IAAIC,GAAG,CAACJ,UAAU,CAAC;EAC/B,CAAC,CAAC,OAAOK,CAAM,EAAE;IACf,MAAM,IAAIH,KAAK,CAAC,WAAWH,UAAU,gBAAgBC,UAAU,mBAAmB,CAAC;EACrF;EAEA;EACA,MAAMM,QAAQ,GAAG,CAACH,OAAO,CAACI,QAAQ,IAAI,EAAE,EAAEC,KAAK,CAAC,GAAG,CAAC;EACpD,IAAIF,QAAQ,CAACG,MAAM,KAAK,CAAC,IAAIH,QAAQ,CAACG,MAAM,KAAK,CAAC,EAAE;IAClD,MAAM,IAAIP,KAAK,CACb,WAAWH,UAAU,gBAAgBC,UAAU,6BAA6BM,QAAQ,CAACG,MAAM,EAAE,CAC9F;EACH;EAEA,IAAIV,UAAU,KAAKO,QAAQ,CAAC,CAAC,CAAC,EAAE;IAC9B,MAAM,IAAIJ,KAAK,CACb,WAAWH,UAAU,gBAAgBC,UAAU,4BAA4BD,UAAU,aAAaO,QAAQ,CAAC,CAAC,CAAC,GAAG,CACjH;EACH;EAEA,MAAMI,QAAQ,GAAG,GAAGP,OAAO,CAACQ,QAAQ,KAAKR,OAAO,CAACS,IAAI,EAAE;EACvD,MAAMC,IAAI,GAAGP,QAAQ,CAAC,CAAC,CAAC;EACxB,MAAMQ,OAAO,GAAGR,QAAQ,CAACG,MAAM,KAAK,CAAC,GAAGH,QAAQ,CAAC,CAAC,CAAC,GAAGS,SAAS;EAC/D,OAAO;IACLL,QAAQ;IACRG,IAAI;IACJC;GACD;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}