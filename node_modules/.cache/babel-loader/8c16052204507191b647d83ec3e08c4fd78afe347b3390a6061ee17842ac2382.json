{"ast":null,"code":"import { Constants, getIdFromLink, getPathFromLink, ResourceType, StatusCodes, SubStatusCodes } from \"../common\";\nimport { DefaultQueryExecutionContext } from \"./defaultQueryExecutionContext\";\nimport { FetchResult, FetchResultType } from \"./FetchResult\";\nimport { getInitialHeader, mergeHeaders } from \"./headerUtils\";\n/** @hidden */\nexport class DocumentProducer {\n  /**\n   * Provides the Target Partition Range Query Execution Context.\n   * @param clientContext  - The service endpoint to use to create the client.\n   * @param collectionLink - Represents collection link\n   * @param query          - A SQL query.\n   * @param targetPartitionKeyRange - Query Target Partition key Range\n   * @hidden\n   */\n  constructor(clientContext, collectionLink, query, targetPartitionKeyRange, options, correlatedActivityId, startEpk, endEpk, populateEpkRangeHeaders = false) {\n    this.clientContext = clientContext;\n    this.generation = 0;\n    this.fetchFunction = async (diagnosticNode, options, correlatedActivityId) => {\n      const path = getPathFromLink(this.collectionLink, ResourceType.item);\n      diagnosticNode.addData({\n        partitionKeyRangeId: this.targetPartitionKeyRange.id\n      });\n      const id = getIdFromLink(this.collectionLink);\n      const startEpk = this.populateEpkRangeHeaders ? this.startEpk : undefined;\n      const endEpk = this.populateEpkRangeHeaders ? this.endEpk : undefined;\n      return this.clientContext.queryFeed({\n        path,\n        resourceType: ResourceType.item,\n        resourceId: id,\n        resultFn: result => result.Documents,\n        query: this.query,\n        options,\n        diagnosticNode,\n        partitionKeyRangeId: this.targetPartitionKeyRange[\"id\"],\n        correlatedActivityId: correlatedActivityId,\n        startEpk: startEpk,\n        endEpk: endEpk\n      });\n    };\n    // TODO: any options\n    this.collectionLink = collectionLink;\n    this.query = query;\n    this.targetPartitionKeyRange = targetPartitionKeyRange;\n    this.fetchResults = [];\n    this.allFetched = false;\n    this.err = undefined;\n    this.previousContinuationToken = undefined;\n    this.continuationToken = undefined;\n    this.respHeaders = getInitialHeader();\n    this.internalExecutionContext = new DefaultQueryExecutionContext(options, this.fetchFunction, correlatedActivityId);\n    this.startEpk = startEpk;\n    this.endEpk = endEpk;\n    this.populateEpkRangeHeaders = populateEpkRangeHeaders;\n  }\n  peekBufferedItems() {\n    const bufferedResults = [];\n    for (let i = 0, done = false; i < this.fetchResults.length && !done; i++) {\n      const fetchResult = this.fetchResults[i];\n      switch (fetchResult.fetchResultType) {\n        case FetchResultType.Done:\n          done = true;\n          break;\n        case FetchResultType.Exception:\n          done = true;\n          break;\n        case FetchResultType.Result:\n          bufferedResults.push(fetchResult.feedResponse);\n          break;\n      }\n    }\n    return bufferedResults;\n  }\n  hasMoreResults() {\n    return this.internalExecutionContext.hasMoreResults() || this.fetchResults.length !== 0;\n  }\n  gotSplit() {\n    if (this.fetchResults.length !== 0) {\n      const fetchResult = this.fetchResults[0];\n      if (fetchResult.fetchResultType === FetchResultType.Exception) {\n        if (DocumentProducer._needPartitionKeyRangeCacheRefresh(fetchResult.error)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  _getAndResetActiveResponseHeaders() {\n    const ret = this.respHeaders;\n    this.respHeaders = getInitialHeader();\n    return ret;\n  }\n  _updateStates(err, allFetched) {\n    if (err) {\n      this.err = err;\n      return;\n    }\n    if (allFetched) {\n      this.allFetched = true;\n    }\n    if (this.internalExecutionContext.continuationToken === this.continuationToken) {\n      // nothing changed\n      return;\n    }\n    this.previousContinuationToken = this.continuationToken;\n    this.continuationToken = this.internalExecutionContext.continuationToken;\n  }\n  static _needPartitionKeyRangeCacheRefresh(error) {\n    // TODO: error\n    return error.code === StatusCodes.Gone && \"substatus\" in error && error[\"substatus\"] === SubStatusCodes.PartitionKeyRangeGone;\n  }\n  /**\n   * Fetches and bufferes the next page of results in internal buffer\n   */\n  async bufferMore(diagnosticNode) {\n    if (this.err) {\n      throw this.err;\n    }\n    try {\n      const {\n        result: resources,\n        headers: headerResponse\n      } = await this.internalExecutionContext.fetchMore(diagnosticNode);\n      ++this.generation;\n      this._updateStates(undefined, resources === undefined);\n      if (resources !== undefined) {\n        // add fetched header to the 1st element in the buffer\n        let addHeaderToFetchResult = true;\n        resources.forEach(element => {\n          this.fetchResults.push(new FetchResult(element, undefined, addHeaderToFetchResult ? headerResponse : getInitialHeader()));\n          addHeaderToFetchResult = false;\n        });\n      }\n      // need to modify the header response so that the query metrics are per partition\n      if (headerResponse != null && Constants.HttpHeaders.QueryMetrics in headerResponse) {\n        // \"0\" is the default partition before one is actually assigned.\n        const queryMetrics = headerResponse[Constants.HttpHeaders.QueryMetrics][\"0\"];\n        // Wraping query metrics in a object where the keys are the partition key range.\n        headerResponse[Constants.HttpHeaders.QueryMetrics] = {};\n        headerResponse[Constants.HttpHeaders.QueryMetrics][this.targetPartitionKeyRange.id] = queryMetrics;\n      }\n      mergeHeaders(this.respHeaders, headerResponse);\n    } catch (err) {\n      if (DocumentProducer._needPartitionKeyRangeCacheRefresh(err)) {\n        // Split just happend\n        // Buffer the error so the execution context can still get the feedResponses in the itemBuffer\n        const bufferedError = new FetchResult(undefined, err);\n        this.fetchResults.push(bufferedError);\n        mergeHeaders(this.respHeaders, err.headers);\n      } else {\n        this._updateStates(err, err.resources === undefined);\n        throw err;\n      }\n    }\n  }\n  getTargetParitionKeyRange() {\n    return this.targetPartitionKeyRange;\n  }\n  /**\n   * Peak the next item in the buffer\n   */\n  peakNextItem() {\n    if (this.err) {\n      throw this.err;\n    }\n    if (this.allFetched || this.fetchResults.length === 0) {\n      return undefined;\n    }\n    const fetchResult = this.fetchResults[0];\n    switch (fetchResult.fetchResultType) {\n      case FetchResultType.Done:\n        return undefined;\n      case FetchResultType.Exception:\n        // do not throw this error\n        return undefined;\n      case FetchResultType.Result:\n        return fetchResult.feedResponse;\n    }\n  }\n  /**\n   * Returns the first item in the buffered results if any, or [] otherwise.\n   */\n  async fetchNextItem() {\n    if (this.err) {\n      this._updateStates(this.err, undefined);\n      throw this.err;\n    }\n    if (this.allFetched) {\n      return {\n        result: undefined,\n        headers: this._getAndResetActiveResponseHeaders()\n      };\n    }\n    try {\n      const {\n        result,\n        headers\n      } = this.current();\n      this._updateStates(undefined, result === undefined);\n      if (result === undefined || result.length === 0) {\n        return {\n          result: undefined,\n          headers\n        };\n      }\n      return {\n        result,\n        headers\n      }; //\n    } catch (err) {\n      this._updateStates(err, err.item === undefined);\n      throw err;\n    }\n  }\n  /**\n   * Fetches all the buffered results\n   */\n  async fetchBufferedItems() {\n    if (this.err) {\n      this._updateStates(this.err, undefined);\n      throw this.err;\n    }\n    if (this.allFetched) {\n      return {\n        result: undefined,\n        headers: this._getAndResetActiveResponseHeaders()\n      };\n    }\n    const resources = [];\n    const resHeaders = getInitialHeader();\n    try {\n      while (this.fetchResults.length > 0) {\n        const {\n          result,\n          headers\n        } = this.current();\n        this._updateStates(undefined, result === undefined);\n        mergeHeaders(resHeaders, headers);\n        if (result === undefined) {\n          return {\n            result: resources.length > 0 ? resources : undefined,\n            headers: resHeaders\n          };\n        } else {\n          resources.push(result);\n        }\n      }\n      return {\n        result: resources,\n        headers: resHeaders\n      };\n    } catch (err) {\n      this._updateStates(err, err.item === undefined);\n      throw err;\n    }\n  }\n  /**\n   * Retrieve the current element on the DocumentProducer.\n   */\n  current() {\n    // If something is buffered just give that\n    if (this.fetchResults.length > 0) {\n      const fetchResult = this.fetchResults.shift();\n      // Need to unwrap fetch results\n      switch (fetchResult.fetchResultType) {\n        case FetchResultType.Done:\n          return {\n            result: undefined,\n            headers: this._getAndResetActiveResponseHeaders()\n          };\n        case FetchResultType.Exception:\n          fetchResult.error.headers = this._getAndResetActiveResponseHeaders();\n          throw fetchResult.error;\n        case FetchResultType.Result:\n          return {\n            result: fetchResult.feedResponse,\n            headers: this._getAndResetActiveResponseHeaders()\n          };\n      }\n    }\n    // If there isn't anymore items left to fetch then let the user know.\n    if (this.allFetched) {\n      return {\n        result: undefined,\n        headers: this._getAndResetActiveResponseHeaders()\n      };\n    }\n    // If the internal buffer is empty, return empty result\n    return {\n      result: [],\n      headers: this._getAndResetActiveResponseHeaders()\n    };\n  }\n}","map":{"version":3,"names":["Constants","getIdFromLink","getPathFromLink","ResourceType","StatusCodes","SubStatusCodes","DefaultQueryExecutionContext","FetchResult","FetchResultType","getInitialHeader","mergeHeaders","DocumentProducer","constructor","clientContext","collectionLink","query","targetPartitionKeyRange","options","correlatedActivityId","startEpk","endEpk","populateEpkRangeHeaders","generation","fetchFunction","diagnosticNode","path","item","addData","partitionKeyRangeId","id","undefined","queryFeed","resourceType","resourceId","resultFn","result","Documents","fetchResults","allFetched","err","previousContinuationToken","continuationToken","respHeaders","internalExecutionContext","peekBufferedItems","bufferedResults","i","done","length","fetchResult","fetchResultType","Done","Exception","Result","push","feedResponse","hasMoreResults","gotSplit","_needPartitionKeyRangeCacheRefresh","error","_getAndResetActiveResponseHeaders","ret","_updateStates","code","Gone","PartitionKeyRangeGone","bufferMore","resources","headers","headerResponse","fetchMore","addHeaderToFetchResult","forEach","element","HttpHeaders","QueryMetrics","queryMetrics","bufferedError","getTargetParitionKeyRange","peakNextItem","fetchNextItem","current","fetchBufferedItems","resHeaders","shift"],"sources":["/Users/eimis/test-server/Azure Hackthons/azure-cloud-architecture-game /node_modules/@azure/cosmos/src/queryExecutionContext/documentProducer.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { PartitionKeyRange, Resource } from \"../client\";\nimport type { ClientContext } from \"../ClientContext\";\nimport {\n  Constants,\n  getIdFromLink,\n  getPathFromLink,\n  ResourceType,\n  StatusCodes,\n  SubStatusCodes,\n} from \"../common\";\nimport type { DiagnosticNodeInternal } from \"../diagnostics/DiagnosticNodeInternal\";\nimport type { FeedOptions } from \"../request\";\nimport type { Response } from \"../request\";\nimport { DefaultQueryExecutionContext } from \"./defaultQueryExecutionContext\";\nimport type { FetchFunctionCallback } from \"./defaultQueryExecutionContext\";\nimport { FetchResult, FetchResultType } from \"./FetchResult\";\nimport { getInitialHeader, mergeHeaders } from \"./headerUtils\";\nimport type { CosmosHeaders } from \"./headerUtils\";\nimport type { SqlQuerySpec } from \"./index\";\n\n/** @hidden */\nexport class DocumentProducer {\n  private collectionLink: string;\n  private query: string | SqlQuerySpec;\n  public targetPartitionKeyRange: PartitionKeyRange;\n  public fetchResults: FetchResult[];\n  public allFetched: boolean;\n  private err: Error;\n  public previousContinuationToken: string;\n  public continuationToken: string;\n  public generation: number = 0;\n  private respHeaders: CosmosHeaders;\n  private internalExecutionContext: DefaultQueryExecutionContext;\n  public startEpk: string;\n  public endEpk: string;\n  public populateEpkRangeHeaders: boolean;\n\n  /**\n   * Provides the Target Partition Range Query Execution Context.\n   * @param clientContext  - The service endpoint to use to create the client.\n   * @param collectionLink - Represents collection link\n   * @param query          - A SQL query.\n   * @param targetPartitionKeyRange - Query Target Partition key Range\n   * @hidden\n   */\n  constructor(\n    private clientContext: ClientContext,\n    collectionLink: string,\n    query: SqlQuerySpec,\n    targetPartitionKeyRange: PartitionKeyRange,\n    options: FeedOptions,\n    correlatedActivityId: string,\n    startEpk?: string,\n    endEpk?: string,\n    populateEpkRangeHeaders: boolean = false,\n  ) {\n    // TODO: any options\n    this.collectionLink = collectionLink;\n    this.query = query;\n    this.targetPartitionKeyRange = targetPartitionKeyRange;\n    this.fetchResults = [];\n\n    this.allFetched = false;\n    this.err = undefined;\n\n    this.previousContinuationToken = undefined;\n    this.continuationToken = undefined;\n    this.respHeaders = getInitialHeader();\n\n    this.internalExecutionContext = new DefaultQueryExecutionContext(\n      options,\n      this.fetchFunction,\n      correlatedActivityId,\n    );\n    this.startEpk = startEpk;\n    this.endEpk = endEpk;\n    this.populateEpkRangeHeaders = populateEpkRangeHeaders;\n  }\n  public peekBufferedItems(): any[] {\n    const bufferedResults = [];\n    for (let i = 0, done = false; i < this.fetchResults.length && !done; i++) {\n      const fetchResult = this.fetchResults[i];\n      switch (fetchResult.fetchResultType) {\n        case FetchResultType.Done:\n          done = true;\n          break;\n        case FetchResultType.Exception:\n          done = true;\n          break;\n        case FetchResultType.Result:\n          bufferedResults.push(fetchResult.feedResponse);\n          break;\n      }\n    }\n    return bufferedResults;\n  }\n\n  public fetchFunction: FetchFunctionCallback = async (\n    diagnosticNode: DiagnosticNodeInternal,\n    options: FeedOptions,\n    correlatedActivityId: string,\n  ): Promise<Response<Resource>> => {\n    const path = getPathFromLink(this.collectionLink, ResourceType.item);\n    diagnosticNode.addData({ partitionKeyRangeId: this.targetPartitionKeyRange.id });\n    const id = getIdFromLink(this.collectionLink);\n    const startEpk = this.populateEpkRangeHeaders ? this.startEpk : undefined;\n    const endEpk = this.populateEpkRangeHeaders ? this.endEpk : undefined;\n\n    return this.clientContext.queryFeed({\n      path,\n      resourceType: ResourceType.item,\n      resourceId: id,\n      resultFn: (result: any) => result.Documents,\n      query: this.query,\n      options,\n      diagnosticNode,\n      partitionKeyRangeId: this.targetPartitionKeyRange[\"id\"],\n      correlatedActivityId: correlatedActivityId,\n      startEpk: startEpk,\n      endEpk: endEpk,\n    });\n  };\n\n  public hasMoreResults(): boolean {\n    return this.internalExecutionContext.hasMoreResults() || this.fetchResults.length !== 0;\n  }\n\n  public gotSplit(): boolean {\n    if (this.fetchResults.length !== 0) {\n      const fetchResult = this.fetchResults[0];\n      if (fetchResult.fetchResultType === FetchResultType.Exception) {\n        if (DocumentProducer._needPartitionKeyRangeCacheRefresh(fetchResult.error)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  private _getAndResetActiveResponseHeaders(): CosmosHeaders {\n    const ret = this.respHeaders;\n    this.respHeaders = getInitialHeader();\n    return ret;\n  }\n\n  private _updateStates(err: any, allFetched: boolean): void {\n    if (err) {\n      this.err = err;\n      return;\n    }\n    if (allFetched) {\n      this.allFetched = true;\n    }\n    if (this.internalExecutionContext.continuationToken === this.continuationToken) {\n      // nothing changed\n      return;\n    }\n    this.previousContinuationToken = this.continuationToken;\n    this.continuationToken = this.internalExecutionContext.continuationToken;\n  }\n\n  private static _needPartitionKeyRangeCacheRefresh(error: any): boolean {\n    // TODO: error\n    return (\n      error.code === StatusCodes.Gone &&\n      \"substatus\" in error &&\n      error[\"substatus\"] === SubStatusCodes.PartitionKeyRangeGone\n    );\n  }\n\n  /**\n   * Fetches and bufferes the next page of results in internal buffer\n   */\n  public async bufferMore(diagnosticNode: DiagnosticNodeInternal): Promise<void> {\n    if (this.err) {\n      throw this.err;\n    }\n\n    try {\n      const { result: resources, headers: headerResponse } =\n        await this.internalExecutionContext.fetchMore(diagnosticNode);\n      ++this.generation;\n      this._updateStates(undefined, resources === undefined);\n      if (resources !== undefined) {\n        // add fetched header to the 1st element in the buffer\n        let addHeaderToFetchResult = true;\n        resources.forEach((element: any) => {\n          this.fetchResults.push(\n            new FetchResult(\n              element,\n              undefined,\n              addHeaderToFetchResult ? headerResponse : getInitialHeader(),\n            ),\n          );\n          addHeaderToFetchResult = false;\n        });\n      }\n\n      // need to modify the header response so that the query metrics are per partition\n      if (headerResponse != null && Constants.HttpHeaders.QueryMetrics in headerResponse) {\n        // \"0\" is the default partition before one is actually assigned.\n        const queryMetrics = headerResponse[Constants.HttpHeaders.QueryMetrics][\"0\"];\n\n        // Wraping query metrics in a object where the keys are the partition key range.\n        headerResponse[Constants.HttpHeaders.QueryMetrics] = {};\n        headerResponse[Constants.HttpHeaders.QueryMetrics][this.targetPartitionKeyRange.id] =\n          queryMetrics;\n      }\n      mergeHeaders(this.respHeaders, headerResponse);\n    } catch (err: any) {\n      if (DocumentProducer._needPartitionKeyRangeCacheRefresh(err)) {\n        // Split just happend\n        // Buffer the error so the execution context can still get the feedResponses in the itemBuffer\n        const bufferedError = new FetchResult(undefined, err);\n        this.fetchResults.push(bufferedError);\n        mergeHeaders(this.respHeaders, err.headers);\n      } else {\n        this._updateStates(err, err.resources === undefined);\n        throw err;\n      }\n    }\n  }\n\n  public getTargetParitionKeyRange(): PartitionKeyRange {\n    return this.targetPartitionKeyRange;\n  }\n  /**\n   * Peak the next item in the buffer\n   */\n  public peakNextItem(): any {\n    if (this.err) {\n      throw this.err;\n    }\n    if (this.allFetched || this.fetchResults.length === 0) {\n      return undefined;\n    }\n    const fetchResult = this.fetchResults[0];\n\n    switch (fetchResult.fetchResultType) {\n      case FetchResultType.Done:\n        return undefined;\n\n      case FetchResultType.Exception: // do not throw this error\n        return undefined;\n\n      case FetchResultType.Result:\n        return fetchResult.feedResponse;\n    }\n  }\n\n  /**\n   * Returns the first item in the buffered results if any, or [] otherwise.\n   */\n  public async fetchNextItem(): Promise<Response<any>> {\n    if (this.err) {\n      this._updateStates(this.err, undefined);\n      throw this.err;\n    }\n    if (this.allFetched) {\n      return { result: undefined, headers: this._getAndResetActiveResponseHeaders() };\n    }\n    try {\n      const { result, headers } = this.current();\n      this._updateStates(undefined, result === undefined);\n      if (result === undefined || result.length === 0) {\n        return { result: undefined, headers };\n      }\n      return { result, headers }; //\n    } catch (err: any) {\n      this._updateStates(err, err.item === undefined);\n      throw err;\n    }\n  }\n  /**\n   * Fetches all the buffered results\n   */\n  public async fetchBufferedItems(): Promise<Response<any[]>> {\n    if (this.err) {\n      this._updateStates(this.err, undefined);\n      throw this.err;\n    }\n    if (this.allFetched) {\n      return { result: undefined, headers: this._getAndResetActiveResponseHeaders() };\n    }\n    const resources: any[] = [];\n    const resHeaders: CosmosHeaders = getInitialHeader();\n    try {\n      while (this.fetchResults.length > 0) {\n        const { result, headers } = this.current();\n        this._updateStates(undefined, result === undefined);\n        mergeHeaders(resHeaders, headers);\n        if (result === undefined) {\n          return { result: resources.length > 0 ? resources : undefined, headers: resHeaders };\n        } else {\n          resources.push(result);\n        }\n      }\n      return { result: resources, headers: resHeaders };\n    } catch (err: any) {\n      this._updateStates(err, err.item === undefined);\n      throw err;\n    }\n  }\n\n  /**\n   * Retrieve the current element on the DocumentProducer.\n   */\n  private current(): Response<any> {\n    // If something is buffered just give that\n    if (this.fetchResults.length > 0) {\n      const fetchResult = this.fetchResults.shift();\n      // Need to unwrap fetch results\n      switch (fetchResult.fetchResultType) {\n        case FetchResultType.Done:\n          return {\n            result: undefined,\n            headers: this._getAndResetActiveResponseHeaders(),\n          };\n        case FetchResultType.Exception:\n          fetchResult.error.headers = this._getAndResetActiveResponseHeaders();\n          throw fetchResult.error;\n        case FetchResultType.Result:\n          return {\n            result: fetchResult.feedResponse,\n            headers: this._getAndResetActiveResponseHeaders(),\n          };\n      }\n    }\n\n    // If there isn't anymore items left to fetch then let the user know.\n    if (this.allFetched) {\n      return {\n        result: undefined,\n        headers: this._getAndResetActiveResponseHeaders(),\n      };\n    }\n\n    // If the internal buffer is empty, return empty result\n    return { result: [], headers: this._getAndResetActiveResponseHeaders() };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}