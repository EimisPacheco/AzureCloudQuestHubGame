{"ast":null,"code":"import { getInitialHeader } from \"../headerUtils\";\nimport { hashObject } from \"../../utils/hashObject\";\nimport { FixedSizePriorityQueue } from \"../../utils/fixedSizePriorityQueue\";\nimport { NonStreamingOrderByMap } from \"../../utils/nonStreamingOrderByMap\";\nimport { OrderByComparator } from \"../orderByComparator\";\n/**\n * @hidden\n * Represents an endpoint in handling an non-streaming order by distinct query.\n */\nexport class NonStreamingOrderByDistinctEndpointComponent {\n  constructor(executionContext, queryInfo, priorityQueueBufferSize, emitRawOrderByPayload = false) {\n    this.executionContext = executionContext;\n    this.queryInfo = queryInfo;\n    this.priorityQueueBufferSize = priorityQueueBufferSize;\n    this.emitRawOrderByPayload = emitRawOrderByPayload;\n    /**\n     * Flag to determine if all results are fetched from backend and results can be returned.\n     */\n    this.isCompleted = false;\n    this.sortOrders = this.queryInfo.orderBy;\n    const comparator = new OrderByComparator(this.sortOrders);\n    this.aggregateMap = new NonStreamingOrderByMap((a, b) => {\n      return comparator.compareItems(a, b);\n    });\n    this.nonStreamingOrderByPQ = new FixedSizePriorityQueue((a, b) => {\n      return comparator.compareItems(b, a);\n    }, this.priorityQueueBufferSize);\n  }\n  /**\n   * Build final sorted result array from which responses will be served.\n   */\n  async buildFinalResultArray() {\n    var _a;\n    // Fetch all distinct values from the map and store in priority queue.\n    const allValues = this.aggregateMap.getAllValuesAndReset();\n    for (const value of allValues) {\n      this.nonStreamingOrderByPQ.enqueue(value);\n    }\n    // Compute the final result array size based on offset and limit.\n    const offSet = this.queryInfo.offset ? this.queryInfo.offset : 0;\n    const queueSize = this.nonStreamingOrderByPQ.size();\n    const finalArraySize = queueSize - offSet;\n    if (finalArraySize <= 0) {\n      this.finalResultArray = [];\n    } else {\n      this.finalResultArray = new Array(finalArraySize);\n      // Only keep the final result array size number of items in the final result array and discard the rest.\n      for (let count = finalArraySize - 1; count >= 0; count--) {\n        if (this.emitRawOrderByPayload) {\n          this.finalResultArray[count] = this.nonStreamingOrderByPQ.dequeue();\n        } else {\n          this.finalResultArray[count] = (_a = this.nonStreamingOrderByPQ.dequeue()) === null || _a === void 0 ? void 0 : _a.payload;\n        }\n      }\n    }\n  }\n  hasMoreResults() {\n    if (this.priorityQueueBufferSize === 0) return false;\n    return this.executionContext.hasMoreResults();\n  }\n  async fetchMore(diagnosticNode) {\n    if (this.isCompleted) {\n      return {\n        result: undefined,\n        headers: getInitialHeader()\n      };\n    }\n    let resHeaders = getInitialHeader();\n    // if size is 0, just return undefined to signal to more results. Valid if query is TOP 0 or LIMIT 0\n    if (this.priorityQueueBufferSize <= 0) {\n      return {\n        result: undefined,\n        headers: resHeaders\n      };\n    }\n    // If there are more results in backend, keep filling map.\n    if (this.executionContext.hasMoreResults()) {\n      // Grab the next result\n      const response = await this.executionContext.fetchMore(diagnosticNode);\n      if (response === undefined || response.result === undefined) {\n        this.isCompleted = true;\n        if (this.aggregateMap.size() > 0) {\n          await this.buildFinalResultArray();\n          return {\n            result: this.finalResultArray,\n            headers: response.headers\n          };\n        }\n        return {\n          result: undefined,\n          headers: response.headers\n        };\n      }\n      resHeaders = response.headers;\n      for (const item of response.result) {\n        if (item) {\n          const key = await hashObject(item === null || item === void 0 ? void 0 : item.payload);\n          this.aggregateMap.set(key, item);\n        }\n      }\n      // return [] to signal that there are more results to fetch.\n      if (this.executionContext.hasMoreResults()) {\n        return {\n          result: [],\n          headers: resHeaders\n        };\n      }\n    }\n    // If all results are fetched from backend, prepare final results\n    if (!this.executionContext.hasMoreResults() && !this.isCompleted) {\n      this.isCompleted = true;\n      await this.buildFinalResultArray();\n      return {\n        result: this.finalResultArray,\n        headers: resHeaders\n      };\n    }\n    // Signal that there are no more results.\n    return {\n      result: undefined,\n      headers: resHeaders\n    };\n  }\n}","map":{"version":3,"names":["getInitialHeader","hashObject","FixedSizePriorityQueue","NonStreamingOrderByMap","OrderByComparator","NonStreamingOrderByDistinctEndpointComponent","constructor","executionContext","queryInfo","priorityQueueBufferSize","emitRawOrderByPayload","isCompleted","sortOrders","orderBy","comparator","aggregateMap","a","b","compareItems","nonStreamingOrderByPQ","buildFinalResultArray","allValues","getAllValuesAndReset","value","enqueue","offSet","offset","queueSize","size","finalArraySize","finalResultArray","Array","count","dequeue","_a","payload","hasMoreResults","fetchMore","diagnosticNode","result","undefined","headers","resHeaders","response","item","key","set"],"sources":["/Users/eimis/test-server/Azure Hackthons/azure-cloud-architecture-game /node_modules/@azure/cosmos/src/queryExecutionContext/EndpointComponent/NonStreamingOrderByDistinctEndpointComponent.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { QueryInfo, Response } from \"../../request\";\nimport type { ExecutionContext } from \"../ExecutionContext\";\nimport { getInitialHeader } from \"../headerUtils\";\nimport type { DiagnosticNodeInternal } from \"../../diagnostics/DiagnosticNodeInternal\";\nimport { hashObject } from \"../../utils/hashObject\";\nimport type { NonStreamingOrderByResult } from \"../nonStreamingOrderByResult\";\nimport { FixedSizePriorityQueue } from \"../../utils/fixedSizePriorityQueue\";\nimport { NonStreamingOrderByMap } from \"../../utils/nonStreamingOrderByMap\";\nimport { OrderByComparator } from \"../orderByComparator\";\n\n/**\n * @hidden\n * Represents an endpoint in handling an non-streaming order by distinct query.\n */\nexport class NonStreamingOrderByDistinctEndpointComponent implements ExecutionContext {\n  /**\n   * A Map that holds the distinct values of the items before storing in priority queue.\n   */\n  private aggregateMap: NonStreamingOrderByMap<NonStreamingOrderByResult>;\n  /**\n   * A priority queue to compute the final sorted results.\n   */\n  private nonStreamingOrderByPQ: FixedSizePriorityQueue<NonStreamingOrderByResult>;\n  /**\n   * Array to store the final sorted results.\n   */\n  private finalResultArray: NonStreamingOrderByResult[];\n\n  private sortOrders: string[];\n  /**\n   * Flag to determine if all results are fetched from backend and results can be returned.\n   */\n  private isCompleted: boolean = false;\n\n  constructor(\n    private executionContext: ExecutionContext,\n    private queryInfo: QueryInfo,\n    private priorityQueueBufferSize: number,\n    private emitRawOrderByPayload: boolean = false,\n  ) {\n    this.sortOrders = this.queryInfo.orderBy;\n    const comparator = new OrderByComparator(this.sortOrders);\n    this.aggregateMap = new NonStreamingOrderByMap<NonStreamingOrderByResult>(\n      (a: NonStreamingOrderByResult, b: NonStreamingOrderByResult) => {\n        return comparator.compareItems(a, b);\n      },\n    );\n    this.nonStreamingOrderByPQ = new FixedSizePriorityQueue<NonStreamingOrderByResult>(\n      (a: NonStreamingOrderByResult, b: NonStreamingOrderByResult) => {\n        return comparator.compareItems(b, a);\n      },\n      this.priorityQueueBufferSize,\n    );\n  }\n\n  /**\n   * Build final sorted result array from which responses will be served.\n   */\n  private async buildFinalResultArray(): Promise<void> {\n    // Fetch all distinct values from the map and store in priority queue.\n    const allValues = this.aggregateMap.getAllValuesAndReset();\n    for (const value of allValues) {\n      this.nonStreamingOrderByPQ.enqueue(value);\n    }\n\n    // Compute the final result array size based on offset and limit.\n    const offSet = this.queryInfo.offset ? this.queryInfo.offset : 0;\n    const queueSize = this.nonStreamingOrderByPQ.size();\n    const finalArraySize = queueSize - offSet;\n\n    if (finalArraySize <= 0) {\n      this.finalResultArray = [];\n    } else {\n      this.finalResultArray = new Array(finalArraySize);\n      // Only keep the final result array size number of items in the final result array and discard the rest.\n      for (let count = finalArraySize - 1; count >= 0; count--) {\n        if (this.emitRawOrderByPayload) {\n          this.finalResultArray[count] = this.nonStreamingOrderByPQ.dequeue();\n        } else {\n          this.finalResultArray[count] = this.nonStreamingOrderByPQ.dequeue()?.payload;\n        }\n      }\n    }\n  }\n\n  public hasMoreResults(): boolean {\n    if (this.priorityQueueBufferSize === 0) return false;\n    return this.executionContext.hasMoreResults();\n  }\n\n  public async fetchMore(diagnosticNode?: DiagnosticNodeInternal): Promise<Response<any>> {\n    if (this.isCompleted) {\n      return {\n        result: undefined,\n        headers: getInitialHeader(),\n      };\n    }\n    let resHeaders = getInitialHeader();\n    // if size is 0, just return undefined to signal to more results. Valid if query is TOP 0 or LIMIT 0\n    if (this.priorityQueueBufferSize <= 0) {\n      return {\n        result: undefined,\n        headers: resHeaders,\n      };\n    }\n\n    // If there are more results in backend, keep filling map.\n    if (this.executionContext.hasMoreResults()) {\n      // Grab the next result\n      const response = await this.executionContext.fetchMore(diagnosticNode);\n      if (response === undefined || response.result === undefined) {\n        this.isCompleted = true;\n        if (this.aggregateMap.size() > 0) {\n          await this.buildFinalResultArray();\n          return {\n            result: this.finalResultArray,\n            headers: response.headers,\n          };\n        }\n        return { result: undefined, headers: response.headers };\n      }\n      resHeaders = response.headers;\n      for (const item of response.result) {\n        if (item) {\n          const key = await hashObject(item?.payload);\n          this.aggregateMap.set(key, item);\n        }\n      }\n\n      // return [] to signal that there are more results to fetch.\n      if (this.executionContext.hasMoreResults()) {\n        return {\n          result: [],\n          headers: resHeaders,\n        };\n      }\n    }\n\n    // If all results are fetched from backend, prepare final results\n    if (!this.executionContext.hasMoreResults() && !this.isCompleted) {\n      this.isCompleted = true;\n      await this.buildFinalResultArray();\n      return {\n        result: this.finalResultArray,\n        headers: resHeaders,\n      };\n    }\n    // Signal that there are no more results.\n    return {\n      result: undefined,\n      headers: resHeaders,\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}