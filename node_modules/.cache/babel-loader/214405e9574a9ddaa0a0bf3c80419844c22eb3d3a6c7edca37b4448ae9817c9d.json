{"ast":null,"code":"\"use strict\";\n\nvar _objectWithoutProperties = require(\"/Users/eimis/test-server/react_projects/legendary-lines-game/node_modules/@babel/runtime/helpers/objectWithoutProperties.js\").default;\nvar _objectSpread = require(\"/Users/eimis/test-server/react_projects/legendary-lines-game/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _asyncIterator = require(\"/Users/eimis/test-server/react_projects/legendary-lines-game/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\nconst _excluded = [\"choices\"],\n  _excluded2 = [\"delta\", \"finish_reason\", \"index\", \"logprobs\"],\n  _excluded3 = [\"content\", \"refusal\"],\n  _excluded4 = [\"content\", \"refusal\", \"function_call\", \"role\", \"tool_calls\"],\n  _excluded5 = [\"index\", \"id\", \"type\", \"function\"],\n  _excluded6 = [\"id\", \"choices\", \"created\", \"model\", \"system_fingerprint\"],\n  _excluded7 = [\"message\", \"finish_reason\", \"index\", \"logprobs\"],\n  _excluded8 = [\"content\", \"function_call\", \"tool_calls\"],\n  _excluded9 = [\"function\", \"type\", \"id\"],\n  _excluded10 = [\"arguments\", \"name\"];\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _ChatCompletionStream_instances, _ChatCompletionStream_params, _ChatCompletionStream_choiceEventStates, _ChatCompletionStream_currentChatCompletionSnapshot, _ChatCompletionStream_beginRequest, _ChatCompletionStream_getChoiceEventState, _ChatCompletionStream_addChunk, _ChatCompletionStream_emitToolCallDoneEvent, _ChatCompletionStream_emitContentDoneEvents, _ChatCompletionStream_endRequest, _ChatCompletionStream_getAutoParseableResponseFormat, _ChatCompletionStream_accumulateChatCompletion;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChatCompletionStream = void 0;\nconst error_1 = require(\"../error.js\");\nconst AbstractChatCompletionRunner_1 = require(\"./AbstractChatCompletionRunner.js\");\nconst streaming_1 = require(\"../streaming.js\");\nconst parser_1 = require(\"../lib/parser.js\");\nconst parser_2 = require(\"../_vendor/partial-json-parser/parser.js\");\nclass ChatCompletionStream extends AbstractChatCompletionRunner_1.AbstractChatCompletionRunner {\n  constructor(params) {\n    super();\n    _ChatCompletionStream_instances.add(this);\n    _ChatCompletionStream_params.set(this, void 0);\n    _ChatCompletionStream_choiceEventStates.set(this, void 0);\n    _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);\n    __classPrivateFieldSet(this, _ChatCompletionStream_params, params, \"f\");\n    __classPrivateFieldSet(this, _ChatCompletionStream_choiceEventStates, [], \"f\");\n  }\n  get currentChatCompletionSnapshot() {\n    return __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n  }\n  /**\n   * Intended for use on the frontend, consuming a stream produced with\n   * `.toReadableStream()` on the backend.\n   *\n   * Note that messages sent to the model do not appear in `.on('message')`\n   * in this context.\n   */\n  static fromReadableStream(stream) {\n    const runner = new ChatCompletionStream(null);\n    runner._run(() => runner._fromReadableStream(stream));\n    return runner;\n  }\n  static createChatCompletion(client, params, options) {\n    const runner = new ChatCompletionStream(params);\n    runner._run(() => runner._runChatCompletion(client, _objectSpread(_objectSpread({}, params), {}, {\n      stream: true\n    }), _objectSpread(_objectSpread({}, options), {}, {\n      headers: _objectSpread(_objectSpread({}, options === null || options === void 0 ? void 0 : options.headers), {}, {\n        'X-Stainless-Helper-Method': 'stream'\n      })\n    })));\n    return runner;\n  }\n  async _createChatCompletion(client, params, options) {\n    var _stream$controller$si;\n    super._createChatCompletion;\n    const signal = options === null || options === void 0 ? void 0 : options.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_beginRequest).call(this);\n    const stream = await client.chat.completions.create(_objectSpread(_objectSpread({}, params), {}, {\n      stream: true\n    }), _objectSpread(_objectSpread({}, options), {}, {\n      signal: this.controller.signal\n    }));\n    this._connected();\n    var _iteratorAbruptCompletion = false;\n    var _didIteratorError = false;\n    var _iteratorError;\n    try {\n      for (var _iterator = _asyncIterator(stream), _step; _iteratorAbruptCompletion = !(_step = await _iterator.next()).done; _iteratorAbruptCompletion = false) {\n        const chunk = _step.value;\n        {\n          __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_addChunk).call(this, chunk);\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (_iteratorAbruptCompletion && _iterator.return != null) {\n          await _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n    if ((_stream$controller$si = stream.controller.signal) !== null && _stream$controller$si !== void 0 && _stream$controller$si.aborted) {\n      throw new error_1.APIUserAbortError();\n    }\n    return this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_endRequest).call(this));\n  }\n  async _fromReadableStream(readableStream, options) {\n    var _stream$controller$si2;\n    const signal = options === null || options === void 0 ? void 0 : options.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_beginRequest).call(this);\n    this._connected();\n    const stream = streaming_1.Stream.fromReadableStream(readableStream, this.controller);\n    let chatId;\n    var _iteratorAbruptCompletion2 = false;\n    var _didIteratorError2 = false;\n    var _iteratorError2;\n    try {\n      for (var _iterator2 = _asyncIterator(stream), _step2; _iteratorAbruptCompletion2 = !(_step2 = await _iterator2.next()).done; _iteratorAbruptCompletion2 = false) {\n        const chunk = _step2.value;\n        {\n          if (chatId && chatId !== chunk.id) {\n            // A new request has been made.\n            this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_endRequest).call(this));\n          }\n          __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_addChunk).call(this, chunk);\n          chatId = chunk.id;\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (_iteratorAbruptCompletion2 && _iterator2.return != null) {\n          await _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n    if ((_stream$controller$si2 = stream.controller.signal) !== null && _stream$controller$si2 !== void 0 && _stream$controller$si2.aborted) {\n      throw new error_1.APIUserAbortError();\n    }\n    return this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_endRequest).call(this));\n  }\n  [(_ChatCompletionStream_params = new WeakMap(), _ChatCompletionStream_choiceEventStates = new WeakMap(), _ChatCompletionStream_currentChatCompletionSnapshot = new WeakMap(), _ChatCompletionStream_instances = new WeakSet(), _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest() {\n    if (this.ended) return;\n    __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, undefined, \"f\");\n  }, _ChatCompletionStream_getChoiceEventState = function _ChatCompletionStream_getChoiceEventState(choice) {\n    let state = __classPrivateFieldGet(this, _ChatCompletionStream_choiceEventStates, \"f\")[choice.index];\n    if (state) {\n      return state;\n    }\n    state = {\n      content_done: false,\n      refusal_done: false,\n      logprobs_content_done: false,\n      logprobs_refusal_done: false,\n      done_tool_calls: new Set(),\n      current_tool_call_index: null\n    };\n    __classPrivateFieldGet(this, _ChatCompletionStream_choiceEventStates, \"f\")[choice.index] = state;\n    return state;\n  }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk(chunk) {\n    if (this.ended) return;\n    const completion = __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);\n    this._emit('chunk', chunk, completion);\n    for (const choice of chunk.choices) {\n      var _choiceSnapshot$messa, _choiceSnapshot$messa2, _choiceSnapshot$messa3, _choiceSnapshot$messa4, _choice$logprobs, _choiceSnapshot$messa5, _choice$logprobs3, _choiceSnapshot$messa6;\n      const choiceSnapshot = completion.choices[choice.index];\n      if (choice.delta.content != null && ((_choiceSnapshot$messa = choiceSnapshot.message) === null || _choiceSnapshot$messa === void 0 ? void 0 : _choiceSnapshot$messa.role) === 'assistant' && (_choiceSnapshot$messa2 = choiceSnapshot.message) !== null && _choiceSnapshot$messa2 !== void 0 && _choiceSnapshot$messa2.content) {\n        this._emit('content', choice.delta.content, choiceSnapshot.message.content);\n        this._emit('content.delta', {\n          delta: choice.delta.content,\n          snapshot: choiceSnapshot.message.content,\n          parsed: choiceSnapshot.message.parsed\n        });\n      }\n      if (choice.delta.refusal != null && ((_choiceSnapshot$messa3 = choiceSnapshot.message) === null || _choiceSnapshot$messa3 === void 0 ? void 0 : _choiceSnapshot$messa3.role) === 'assistant' && (_choiceSnapshot$messa4 = choiceSnapshot.message) !== null && _choiceSnapshot$messa4 !== void 0 && _choiceSnapshot$messa4.refusal) {\n        this._emit('refusal.delta', {\n          delta: choice.delta.refusal,\n          snapshot: choiceSnapshot.message.refusal\n        });\n      }\n      if (((_choice$logprobs = choice.logprobs) === null || _choice$logprobs === void 0 ? void 0 : _choice$logprobs.content) != null && ((_choiceSnapshot$messa5 = choiceSnapshot.message) === null || _choiceSnapshot$messa5 === void 0 ? void 0 : _choiceSnapshot$messa5.role) === 'assistant') {\n        var _choice$logprobs2, _choiceSnapshot$logpr, _choiceSnapshot$logpr2;\n        this._emit('logprobs.content.delta', {\n          content: (_choice$logprobs2 = choice.logprobs) === null || _choice$logprobs2 === void 0 ? void 0 : _choice$logprobs2.content,\n          snapshot: (_choiceSnapshot$logpr = (_choiceSnapshot$logpr2 = choiceSnapshot.logprobs) === null || _choiceSnapshot$logpr2 === void 0 ? void 0 : _choiceSnapshot$logpr2.content) !== null && _choiceSnapshot$logpr !== void 0 ? _choiceSnapshot$logpr : []\n        });\n      }\n      if (((_choice$logprobs3 = choice.logprobs) === null || _choice$logprobs3 === void 0 ? void 0 : _choice$logprobs3.refusal) != null && ((_choiceSnapshot$messa6 = choiceSnapshot.message) === null || _choiceSnapshot$messa6 === void 0 ? void 0 : _choiceSnapshot$messa6.role) === 'assistant') {\n        var _choice$logprobs4, _choiceSnapshot$logpr3, _choiceSnapshot$logpr4;\n        this._emit('logprobs.refusal.delta', {\n          refusal: (_choice$logprobs4 = choice.logprobs) === null || _choice$logprobs4 === void 0 ? void 0 : _choice$logprobs4.refusal,\n          snapshot: (_choiceSnapshot$logpr3 = (_choiceSnapshot$logpr4 = choiceSnapshot.logprobs) === null || _choiceSnapshot$logpr4 === void 0 ? void 0 : _choiceSnapshot$logpr4.refusal) !== null && _choiceSnapshot$logpr3 !== void 0 ? _choiceSnapshot$logpr3 : []\n        });\n      }\n      const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);\n      if (choiceSnapshot.finish_reason) {\n        __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);\n        if (state.current_tool_call_index != null) {\n          __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);\n        }\n      }\n      for (const toolCall of (_choice$delta$tool_ca = choice.delta.tool_calls) !== null && _choice$delta$tool_ca !== void 0 ? _choice$delta$tool_ca : []) {\n        var _choice$delta$tool_ca;\n        if (state.current_tool_call_index !== toolCall.index) {\n          __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);\n          // new tool call started, the previous one is done\n          if (state.current_tool_call_index != null) {\n            __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);\n          }\n        }\n        state.current_tool_call_index = toolCall.index;\n      }\n      for (const toolCallDelta of (_choice$delta$tool_ca2 = choice.delta.tool_calls) !== null && _choice$delta$tool_ca2 !== void 0 ? _choice$delta$tool_ca2 : []) {\n        var _choice$delta$tool_ca2, _choiceSnapshot$messa7;\n        const toolCallSnapshot = (_choiceSnapshot$messa7 = choiceSnapshot.message.tool_calls) === null || _choiceSnapshot$messa7 === void 0 ? void 0 : _choiceSnapshot$messa7[toolCallDelta.index];\n        if (!(toolCallSnapshot !== null && toolCallSnapshot !== void 0 && toolCallSnapshot.type)) {\n          continue;\n        }\n        if ((toolCallSnapshot === null || toolCallSnapshot === void 0 ? void 0 : toolCallSnapshot.type) === 'function') {\n          var _toolCallSnapshot$fun, _toolCallDelta$functi, _toolCallDelta$functi2;\n          this._emit('tool_calls.function.arguments.delta', {\n            name: (_toolCallSnapshot$fun = toolCallSnapshot.function) === null || _toolCallSnapshot$fun === void 0 ? void 0 : _toolCallSnapshot$fun.name,\n            index: toolCallDelta.index,\n            arguments: toolCallSnapshot.function.arguments,\n            parsed_arguments: toolCallSnapshot.function.parsed_arguments,\n            arguments_delta: (_toolCallDelta$functi = (_toolCallDelta$functi2 = toolCallDelta.function) === null || _toolCallDelta$functi2 === void 0 ? void 0 : _toolCallDelta$functi2.arguments) !== null && _toolCallDelta$functi !== void 0 ? _toolCallDelta$functi : ''\n          });\n        } else {\n          assertNever(toolCallSnapshot === null || toolCallSnapshot === void 0 ? void 0 : toolCallSnapshot.type);\n        }\n      }\n    }\n  }, _ChatCompletionStream_emitToolCallDoneEvent = function _ChatCompletionStream_emitToolCallDoneEvent(choiceSnapshot, toolCallIndex) {\n    var _choiceSnapshot$messa8;\n    const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);\n    if (state.done_tool_calls.has(toolCallIndex)) {\n      // we've already fired the done event\n      return;\n    }\n    const toolCallSnapshot = (_choiceSnapshot$messa8 = choiceSnapshot.message.tool_calls) === null || _choiceSnapshot$messa8 === void 0 ? void 0 : _choiceSnapshot$messa8[toolCallIndex];\n    if (!toolCallSnapshot) {\n      throw new Error('no tool call snapshot');\n    }\n    if (!toolCallSnapshot.type) {\n      throw new Error('tool call snapshot missing `type`');\n    }\n    if (toolCallSnapshot.type === 'function') {\n      var _classPrivateFieldGe;\n      const inputTool = (_classPrivateFieldGe = __classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\")) === null || _classPrivateFieldGe === void 0 || (_classPrivateFieldGe = _classPrivateFieldGe.tools) === null || _classPrivateFieldGe === void 0 ? void 0 : _classPrivateFieldGe.find(tool => tool.type === 'function' && tool.function.name === toolCallSnapshot.function.name);\n      this._emit('tool_calls.function.arguments.done', {\n        name: toolCallSnapshot.function.name,\n        index: toolCallIndex,\n        arguments: toolCallSnapshot.function.arguments,\n        parsed_arguments: (0, parser_1.isAutoParsableTool)(inputTool) ? inputTool.$parseRaw(toolCallSnapshot.function.arguments) : inputTool !== null && inputTool !== void 0 && inputTool.function.strict ? JSON.parse(toolCallSnapshot.function.arguments) : null\n      });\n    } else {\n      assertNever(toolCallSnapshot.type);\n    }\n  }, _ChatCompletionStream_emitContentDoneEvents = function _ChatCompletionStream_emitContentDoneEvents(choiceSnapshot) {\n    var _choiceSnapshot$logpr5, _choiceSnapshot$logpr6;\n    const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);\n    if (choiceSnapshot.message.content && !state.content_done) {\n      state.content_done = true;\n      const responseFormat = __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getAutoParseableResponseFormat).call(this);\n      this._emit('content.done', {\n        content: choiceSnapshot.message.content,\n        parsed: responseFormat ? responseFormat.$parseRaw(choiceSnapshot.message.content) : null\n      });\n    }\n    if (choiceSnapshot.message.refusal && !state.refusal_done) {\n      state.refusal_done = true;\n      this._emit('refusal.done', {\n        refusal: choiceSnapshot.message.refusal\n      });\n    }\n    if ((_choiceSnapshot$logpr5 = choiceSnapshot.logprobs) !== null && _choiceSnapshot$logpr5 !== void 0 && _choiceSnapshot$logpr5.content && !state.logprobs_content_done) {\n      state.logprobs_content_done = true;\n      this._emit('logprobs.content.done', {\n        content: choiceSnapshot.logprobs.content\n      });\n    }\n    if ((_choiceSnapshot$logpr6 = choiceSnapshot.logprobs) !== null && _choiceSnapshot$logpr6 !== void 0 && _choiceSnapshot$logpr6.refusal && !state.logprobs_refusal_done) {\n      state.logprobs_refusal_done = true;\n      this._emit('logprobs.refusal.done', {\n        refusal: choiceSnapshot.logprobs.refusal\n      });\n    }\n  }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest() {\n    if (this.ended) {\n      throw new error_1.OpenAIError(\"stream has ended, this shouldn't happen\");\n    }\n    const snapshot = __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n    if (!snapshot) {\n      throw new error_1.OpenAIError(\"request ended without sending any chunks\");\n    }\n    __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, undefined, \"f\");\n    __classPrivateFieldSet(this, _ChatCompletionStream_choiceEventStates, [], \"f\");\n    return finalizeChatCompletion(snapshot, __classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\"));\n  }, _ChatCompletionStream_getAutoParseableResponseFormat = function _ChatCompletionStream_getAutoParseableResponseFormat() {\n    var _classPrivateFieldGe2;\n    const responseFormat = (_classPrivateFieldGe2 = __classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\")) === null || _classPrivateFieldGe2 === void 0 ? void 0 : _classPrivateFieldGe2.response_format;\n    if ((0, parser_1.isAutoParsableResponseFormat)(responseFormat)) {\n      return responseFormat;\n    }\n    return null;\n  }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion(chunk) {\n    var _a, _b, _c, _d;\n    let snapshot = __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n    const {\n        choices\n      } = chunk,\n      rest = _objectWithoutProperties(chunk, _excluded);\n    if (!snapshot) {\n      snapshot = __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, _objectSpread(_objectSpread({}, rest), {}, {\n        choices: []\n      }), \"f\");\n    } else {\n      Object.assign(snapshot, rest);\n    }\n    for (const _ref of chunk.choices) {\n      const {\n          delta,\n          finish_reason,\n          index,\n          logprobs = null\n        } = _ref,\n        other = _objectWithoutProperties(_ref, _excluded2);\n      let choice = snapshot.choices[index];\n      if (!choice) {\n        choice = snapshot.choices[index] = _objectSpread({\n          finish_reason,\n          index,\n          message: {},\n          logprobs\n        }, other);\n      }\n      if (logprobs) {\n        if (!choice.logprobs) {\n          choice.logprobs = Object.assign({}, logprobs);\n        } else {\n          const {\n              content,\n              refusal\n            } = logprobs,\n            rest = _objectWithoutProperties(logprobs, _excluded3);\n          assertIsEmpty(rest);\n          Object.assign(choice.logprobs, rest);\n          if (content) {\n            var _a$content;\n            (_a$content = (_a = choice.logprobs).content) !== null && _a$content !== void 0 ? _a$content : _a.content = [];\n            choice.logprobs.content.push(...content);\n          }\n          if (refusal) {\n            var _b$refusal;\n            (_b$refusal = (_b = choice.logprobs).refusal) !== null && _b$refusal !== void 0 ? _b$refusal : _b.refusal = [];\n            choice.logprobs.refusal.push(...refusal);\n          }\n        }\n      }\n      if (finish_reason) {\n        choice.finish_reason = finish_reason;\n        if (__classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\") && (0, parser_1.hasAutoParseableInput)(__classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\"))) {\n          if (finish_reason === 'length') {\n            throw new error_1.LengthFinishReasonError();\n          }\n          if (finish_reason === 'content_filter') {\n            throw new error_1.ContentFilterFinishReasonError();\n          }\n        }\n      }\n      Object.assign(choice, other);\n      if (!delta) continue; // Shouldn't happen; just in case.\n      const {\n          content,\n          refusal,\n          function_call,\n          role,\n          tool_calls\n        } = delta,\n        rest = _objectWithoutProperties(delta, _excluded4);\n      assertIsEmpty(rest);\n      Object.assign(choice.message, rest);\n      if (refusal) {\n        choice.message.refusal = (choice.message.refusal || '') + refusal;\n      }\n      if (role) choice.message.role = role;\n      if (function_call) {\n        if (!choice.message.function_call) {\n          choice.message.function_call = function_call;\n        } else {\n          if (function_call.name) choice.message.function_call.name = function_call.name;\n          if (function_call.arguments) {\n            var _c$arguments;\n            (_c$arguments = (_c = choice.message.function_call).arguments) !== null && _c$arguments !== void 0 ? _c$arguments : _c.arguments = '';\n            choice.message.function_call.arguments += function_call.arguments;\n          }\n        }\n      }\n      if (content) {\n        choice.message.content = (choice.message.content || '') + content;\n        if (!choice.message.refusal && __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_getAutoParseableResponseFormat).call(this)) {\n          choice.message.parsed = (0, parser_2.partialParse)(choice.message.content);\n        }\n      }\n      if (tool_calls) {\n        if (!choice.message.tool_calls) choice.message.tool_calls = [];\n        for (const _ref2 of tool_calls) {\n          var _d$index, _tool_call$function, _fn$name;\n          const {\n              index,\n              id,\n              type,\n              function: fn\n            } = _ref2,\n            rest = _objectWithoutProperties(_ref2, _excluded5);\n          const tool_call = (_d$index = (_d = choice.message.tool_calls)[index]) !== null && _d$index !== void 0 ? _d$index : _d[index] = {};\n          Object.assign(tool_call, rest);\n          if (id) tool_call.id = id;\n          if (type) tool_call.type = type;\n          if (fn) (_tool_call$function = tool_call.function) !== null && _tool_call$function !== void 0 ? _tool_call$function : tool_call.function = {\n            name: (_fn$name = fn.name) !== null && _fn$name !== void 0 ? _fn$name : '',\n            arguments: ''\n          };\n          if (fn !== null && fn !== void 0 && fn.name) tool_call.function.name = fn.name;\n          if (fn !== null && fn !== void 0 && fn.arguments) {\n            tool_call.function.arguments += fn.arguments;\n            if ((0, parser_1.shouldParseToolCall)(__classPrivateFieldGet(this, _ChatCompletionStream_params, \"f\"), tool_call)) {\n              tool_call.function.parsed_arguments = (0, parser_2.partialParse)(tool_call.function.arguments);\n            }\n          }\n        }\n      }\n    }\n    return snapshot;\n  }, Symbol.asyncIterator)]() {\n    const pushQueue = [];\n    const readQueue = [];\n    let done = false;\n    this.on('chunk', chunk => {\n      const reader = readQueue.shift();\n      if (reader) {\n        reader.resolve(chunk);\n      } else {\n        pushQueue.push(chunk);\n      }\n    });\n    this.on('end', () => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.resolve(undefined);\n      }\n      readQueue.length = 0;\n    });\n    this.on('abort', err => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n    this.on('error', err => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n    return {\n      next: async () => {\n        if (!pushQueue.length) {\n          if (done) {\n            return {\n              value: undefined,\n              done: true\n            };\n          }\n          return new Promise((resolve, reject) => readQueue.push({\n            resolve,\n            reject\n          })).then(chunk => chunk ? {\n            value: chunk,\n            done: false\n          } : {\n            value: undefined,\n            done: true\n          });\n        }\n        const chunk = pushQueue.shift();\n        return {\n          value: chunk,\n          done: false\n        };\n      },\n      return: async () => {\n        this.abort();\n        return {\n          value: undefined,\n          done: true\n        };\n      }\n    };\n  }\n  toReadableStream() {\n    const stream = new streaming_1.Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n    return stream.toReadableStream();\n  }\n}\nexports.ChatCompletionStream = ChatCompletionStream;\nfunction finalizeChatCompletion(snapshot, params) {\n  const {\n      id,\n      choices,\n      created,\n      model,\n      system_fingerprint\n    } = snapshot,\n    rest = _objectWithoutProperties(snapshot, _excluded6);\n  const completion = _objectSpread(_objectSpread({}, rest), {}, {\n    id,\n    choices: choices.map(_ref3 => {\n      var _message$refusal3;\n      let {\n          message,\n          finish_reason,\n          index,\n          logprobs\n        } = _ref3,\n        choiceRest = _objectWithoutProperties(_ref3, _excluded7);\n      if (!finish_reason) {\n        throw new error_1.OpenAIError(\"missing finish_reason for choice \".concat(index));\n      }\n      const {\n          content = null,\n          function_call,\n          tool_calls\n        } = message,\n        messageRest = _objectWithoutProperties(message, _excluded8);\n      const role = message.role; // this is what we expect; in theory it could be different which would make our types a slight lie but would be fine.\n      if (!role) {\n        throw new error_1.OpenAIError(\"missing role for choice \".concat(index));\n      }\n      if (function_call) {\n        var _message$refusal;\n        const {\n          arguments: args,\n          name\n        } = function_call;\n        if (args == null) {\n          throw new error_1.OpenAIError(\"missing function_call.arguments for choice \".concat(index));\n        }\n        if (!name) {\n          throw new error_1.OpenAIError(\"missing function_call.name for choice \".concat(index));\n        }\n        return _objectSpread(_objectSpread({}, choiceRest), {}, {\n          message: {\n            content,\n            function_call: {\n              arguments: args,\n              name\n            },\n            role,\n            refusal: (_message$refusal = message.refusal) !== null && _message$refusal !== void 0 ? _message$refusal : null\n          },\n          finish_reason,\n          index,\n          logprobs\n        });\n      }\n      if (tool_calls) {\n        var _message$refusal2;\n        return _objectSpread(_objectSpread({}, choiceRest), {}, {\n          index,\n          finish_reason,\n          logprobs,\n          message: _objectSpread(_objectSpread({}, messageRest), {}, {\n            role,\n            content,\n            refusal: (_message$refusal2 = message.refusal) !== null && _message$refusal2 !== void 0 ? _message$refusal2 : null,\n            tool_calls: tool_calls.map((tool_call, i) => {\n              const {\n                  function: fn,\n                  type,\n                  id\n                } = tool_call,\n                toolRest = _objectWithoutProperties(tool_call, _excluded9);\n              const _ref4 = fn || {},\n                {\n                  arguments: args,\n                  name\n                } = _ref4,\n                fnRest = _objectWithoutProperties(_ref4, _excluded10);\n              if (id == null) {\n                throw new error_1.OpenAIError(\"missing choices[\".concat(index, \"].tool_calls[\").concat(i, \"].id\\n\").concat(str(snapshot)));\n              }\n              if (type == null) {\n                throw new error_1.OpenAIError(\"missing choices[\".concat(index, \"].tool_calls[\").concat(i, \"].type\\n\").concat(str(snapshot)));\n              }\n              if (name == null) {\n                throw new error_1.OpenAIError(\"missing choices[\".concat(index, \"].tool_calls[\").concat(i, \"].function.name\\n\").concat(str(snapshot)));\n              }\n              if (args == null) {\n                throw new error_1.OpenAIError(\"missing choices[\".concat(index, \"].tool_calls[\").concat(i, \"].function.arguments\\n\").concat(str(snapshot)));\n              }\n              return _objectSpread(_objectSpread({}, toolRest), {}, {\n                id,\n                type,\n                function: _objectSpread(_objectSpread({}, fnRest), {}, {\n                  name,\n                  arguments: args\n                })\n              });\n            })\n          })\n        });\n      }\n      return _objectSpread(_objectSpread({}, choiceRest), {}, {\n        message: _objectSpread(_objectSpread({}, messageRest), {}, {\n          content,\n          role,\n          refusal: (_message$refusal3 = message.refusal) !== null && _message$refusal3 !== void 0 ? _message$refusal3 : null\n        }),\n        finish_reason,\n        index,\n        logprobs\n      });\n    }),\n    created,\n    model,\n    object: 'chat.completion'\n  }, system_fingerprint ? {\n    system_fingerprint\n  } : {});\n  return (0, parser_1.maybeParseChatCompletion)(completion, params);\n}\nfunction str(x) {\n  return JSON.stringify(x);\n}\n/**\n * Ensures the given argument is an empty object, useful for\n * asserting that all known properties on an object have been\n * destructured.\n */\nfunction assertIsEmpty(obj) {\n  return;\n}\nfunction assertNever(_x) {}","map":{"version":3,"names":["error_1","require","AbstractChatCompletionRunner_1","streaming_1","parser_1","parser_2","ChatCompletionStream","AbstractChatCompletionRunner","constructor","params","_ChatCompletionStream_params","set","_ChatCompletionStream_choiceEventStates","_ChatCompletionStream_currentChatCompletionSnapshot","__classPrivateFieldSet","currentChatCompletionSnapshot","__classPrivateFieldGet","fromReadableStream","stream","runner","_run","_fromReadableStream","createChatCompletion","client","options","_runChatCompletion","_objectSpread","headers","_createChatCompletion","_stream$controller$si","signal","aborted","controller","abort","addEventListener","_ChatCompletionStream_instances","_ChatCompletionStream_beginRequest","call","chat","completions","create","_connected","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_asyncIterator","_step","next","done","chunk","value","_ChatCompletionStream_addChunk","err","return","APIUserAbortError","_addChatCompletion","_ChatCompletionStream_endRequest","readableStream","_stream$controller$si2","Stream","chatId","_iteratorAbruptCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","id","WeakMap","WeakSet","ended","undefined","_ChatCompletionStream_getChoiceEventState","choice","state","index","content_done","refusal_done","logprobs_content_done","logprobs_refusal_done","done_tool_calls","Set","current_tool_call_index","completion","_ChatCompletionStream_accumulateChatCompletion","_emit","choices","_choiceSnapshot$messa","_choiceSnapshot$messa2","_choiceSnapshot$messa3","_choiceSnapshot$messa4","_choice$logprobs","_choiceSnapshot$messa5","_choice$logprobs3","_choiceSnapshot$messa6","choiceSnapshot","delta","content","message","role","snapshot","parsed","refusal","logprobs","_choice$logprobs2","_choiceSnapshot$logpr","_choiceSnapshot$logpr2","_choice$logprobs4","_choiceSnapshot$logpr3","_choiceSnapshot$logpr4","finish_reason","_ChatCompletionStream_emitContentDoneEvents","_ChatCompletionStream_emitToolCallDoneEvent","toolCall","_choice$delta$tool_ca","tool_calls","toolCallDelta","_choice$delta$tool_ca2","_choiceSnapshot$messa7","toolCallSnapshot","type","_toolCallSnapshot$fun","_toolCallDelta$functi","_toolCallDelta$functi2","name","function","arguments","parsed_arguments","arguments_delta","assertNever","toolCallIndex","_choiceSnapshot$messa8","has","Error","_classPrivateFieldGe","inputTool","tools","find","tool","isAutoParsableTool","$parseRaw","strict","JSON","parse","_choiceSnapshot$logpr5","_choiceSnapshot$logpr6","responseFormat","_ChatCompletionStream_getAutoParseableResponseFormat","OpenAIError","finalizeChatCompletion","_classPrivateFieldGe2","response_format","isAutoParsableResponseFormat","rest","_objectWithoutProperties","_excluded","Object","assign","_ref","other","_excluded2","_excluded3","assertIsEmpty","_a$content","_a","push","_b$refusal","_b","hasAutoParseableInput","LengthFinishReasonError","ContentFilterFinishReasonError","function_call","_excluded4","_c$arguments","_c","partialParse","_ref2","_d$index","_tool_call$function","_fn$name","fn","_excluded5","tool_call","_d","shouldParseToolCall","Symbol","asyncIterator","pushQueue","readQueue","on","reader","shift","resolve","length","reject","Promise","then","toReadableStream","bind","exports","created","model","system_fingerprint","_excluded6","map","_ref3","_message$refusal3","choiceRest","_excluded7","concat","messageRest","_excluded8","_message$refusal","args","_message$refusal2","i","toolRest","_excluded9","_ref4","fnRest","_excluded10","str","object","maybeParseChatCompletion","x","stringify","obj","_x"],"sources":["/Users/eimis/test-server/react_projects/legendary-lines-game/node_modules/openai/src/lib/ChatCompletionStream.ts"],"sourcesContent":["import * as Core from '../core';\nimport {\n  OpenAIError,\n  APIUserAbortError,\n  LengthFinishReasonError,\n  ContentFilterFinishReasonError,\n} from '../error';\nimport {\n  ChatCompletionTokenLogprob,\n  type ChatCompletion,\n  type ChatCompletionChunk,\n  type ChatCompletionCreateParams,\n  type ChatCompletionCreateParamsStreaming,\n  type ChatCompletionCreateParamsBase,\n} from '../resources/chat/completions';\nimport {\n  AbstractChatCompletionRunner,\n  type AbstractChatCompletionRunnerEvents,\n} from './AbstractChatCompletionRunner';\nimport { type ReadableStream } from '../_shims/index';\nimport { Stream } from '../streaming';\nimport OpenAI from '../index';\nimport { ParsedChatCompletion } from '../resources/beta/chat/completions';\nimport {\n  AutoParseableResponseFormat,\n  hasAutoParseableInput,\n  isAutoParsableResponseFormat,\n  isAutoParsableTool,\n  maybeParseChatCompletion,\n  shouldParseToolCall,\n} from '../lib/parser';\nimport { partialParse } from '../_vendor/partial-json-parser/parser';\n\nexport interface ContentDeltaEvent {\n  delta: string;\n  snapshot: string;\n  parsed: unknown | null;\n}\n\nexport interface ContentDoneEvent<ParsedT = null> {\n  content: string;\n  parsed: ParsedT | null;\n}\n\nexport interface RefusalDeltaEvent {\n  delta: string;\n  snapshot: string;\n}\n\nexport interface RefusalDoneEvent {\n  refusal: string;\n}\n\nexport interface FunctionToolCallArgumentsDeltaEvent {\n  name: string;\n\n  index: number;\n\n  arguments: string;\n\n  parsed_arguments: unknown;\n\n  arguments_delta: string;\n}\n\nexport interface FunctionToolCallArgumentsDoneEvent {\n  name: string;\n\n  index: number;\n\n  arguments: string;\n\n  parsed_arguments: unknown;\n}\n\nexport interface LogProbsContentDeltaEvent {\n  content: Array<ChatCompletionTokenLogprob>;\n  snapshot: Array<ChatCompletionTokenLogprob>;\n}\n\nexport interface LogProbsContentDoneEvent {\n  content: Array<ChatCompletionTokenLogprob>;\n}\n\nexport interface LogProbsRefusalDeltaEvent {\n  refusal: Array<ChatCompletionTokenLogprob>;\n  snapshot: Array<ChatCompletionTokenLogprob>;\n}\n\nexport interface LogProbsRefusalDoneEvent {\n  refusal: Array<ChatCompletionTokenLogprob>;\n}\n\nexport interface ChatCompletionStreamEvents<ParsedT = null> extends AbstractChatCompletionRunnerEvents {\n  content: (contentDelta: string, contentSnapshot: string) => void;\n  chunk: (chunk: ChatCompletionChunk, snapshot: ChatCompletionSnapshot) => void;\n\n  'content.delta': (props: ContentDeltaEvent) => void;\n  'content.done': (props: ContentDoneEvent<ParsedT>) => void;\n\n  'refusal.delta': (props: RefusalDeltaEvent) => void;\n  'refusal.done': (props: RefusalDoneEvent) => void;\n\n  'tool_calls.function.arguments.delta': (props: FunctionToolCallArgumentsDeltaEvent) => void;\n  'tool_calls.function.arguments.done': (props: FunctionToolCallArgumentsDoneEvent) => void;\n\n  'logprobs.content.delta': (props: LogProbsContentDeltaEvent) => void;\n  'logprobs.content.done': (props: LogProbsContentDoneEvent) => void;\n\n  'logprobs.refusal.delta': (props: LogProbsRefusalDeltaEvent) => void;\n  'logprobs.refusal.done': (props: LogProbsRefusalDoneEvent) => void;\n}\n\nexport type ChatCompletionStreamParams = Omit<ChatCompletionCreateParamsBase, 'stream'> & {\n  stream?: true;\n};\n\ninterface ChoiceEventState {\n  content_done: boolean;\n  refusal_done: boolean;\n  logprobs_content_done: boolean;\n  logprobs_refusal_done: boolean;\n  current_tool_call_index: number | null;\n  done_tool_calls: Set<number>;\n}\n\nexport class ChatCompletionStream<ParsedT = null>\n  extends AbstractChatCompletionRunner<ChatCompletionStreamEvents<ParsedT>, ParsedT>\n  implements AsyncIterable<ChatCompletionChunk>\n{\n  #params: ChatCompletionCreateParams | null;\n  #choiceEventStates: ChoiceEventState[];\n  #currentChatCompletionSnapshot: ChatCompletionSnapshot | undefined;\n\n  constructor(params: ChatCompletionCreateParams | null) {\n    super();\n    this.#params = params;\n    this.#choiceEventStates = [];\n  }\n\n  get currentChatCompletionSnapshot(): ChatCompletionSnapshot | undefined {\n    return this.#currentChatCompletionSnapshot;\n  }\n\n  /**\n   * Intended for use on the frontend, consuming a stream produced with\n   * `.toReadableStream()` on the backend.\n   *\n   * Note that messages sent to the model do not appear in `.on('message')`\n   * in this context.\n   */\n  static fromReadableStream(stream: ReadableStream): ChatCompletionStream<null> {\n    const runner = new ChatCompletionStream(null);\n    runner._run(() => runner._fromReadableStream(stream));\n    return runner;\n  }\n\n  static createChatCompletion<ParsedT>(\n    client: OpenAI,\n    params: ChatCompletionStreamParams,\n    options?: Core.RequestOptions,\n  ): ChatCompletionStream<ParsedT> {\n    const runner = new ChatCompletionStream<ParsedT>(params as ChatCompletionCreateParamsStreaming);\n    runner._run(() =>\n      runner._runChatCompletion(\n        client,\n        { ...params, stream: true },\n        { ...options, headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' } },\n      ),\n    );\n    return runner;\n  }\n\n  #beginRequest() {\n    if (this.ended) return;\n    this.#currentChatCompletionSnapshot = undefined;\n  }\n\n  #getChoiceEventState(choice: ChatCompletionSnapshot.Choice): ChoiceEventState {\n    let state = this.#choiceEventStates[choice.index];\n    if (state) {\n      return state;\n    }\n\n    state = {\n      content_done: false,\n      refusal_done: false,\n      logprobs_content_done: false,\n      logprobs_refusal_done: false,\n      done_tool_calls: new Set(),\n      current_tool_call_index: null,\n    };\n    this.#choiceEventStates[choice.index] = state;\n    return state;\n  }\n\n  #addChunk(this: ChatCompletionStream<ParsedT>, chunk: ChatCompletionChunk) {\n    if (this.ended) return;\n\n    const completion = this.#accumulateChatCompletion(chunk);\n    this._emit('chunk', chunk, completion);\n\n    for (const choice of chunk.choices) {\n      const choiceSnapshot = completion.choices[choice.index]!;\n\n      if (\n        choice.delta.content != null &&\n        choiceSnapshot.message?.role === 'assistant' &&\n        choiceSnapshot.message?.content\n      ) {\n        this._emit('content', choice.delta.content, choiceSnapshot.message.content);\n        this._emit('content.delta', {\n          delta: choice.delta.content,\n          snapshot: choiceSnapshot.message.content,\n          parsed: choiceSnapshot.message.parsed,\n        });\n      }\n\n      if (\n        choice.delta.refusal != null &&\n        choiceSnapshot.message?.role === 'assistant' &&\n        choiceSnapshot.message?.refusal\n      ) {\n        this._emit('refusal.delta', {\n          delta: choice.delta.refusal,\n          snapshot: choiceSnapshot.message.refusal,\n        });\n      }\n\n      if (choice.logprobs?.content != null && choiceSnapshot.message?.role === 'assistant') {\n        this._emit('logprobs.content.delta', {\n          content: choice.logprobs?.content,\n          snapshot: choiceSnapshot.logprobs?.content ?? [],\n        });\n      }\n\n      if (choice.logprobs?.refusal != null && choiceSnapshot.message?.role === 'assistant') {\n        this._emit('logprobs.refusal.delta', {\n          refusal: choice.logprobs?.refusal,\n          snapshot: choiceSnapshot.logprobs?.refusal ?? [],\n        });\n      }\n\n      const state = this.#getChoiceEventState(choiceSnapshot);\n\n      if (choiceSnapshot.finish_reason) {\n        this.#emitContentDoneEvents(choiceSnapshot);\n\n        if (state.current_tool_call_index != null) {\n          this.#emitToolCallDoneEvent(choiceSnapshot, state.current_tool_call_index);\n        }\n      }\n\n      for (const toolCall of choice.delta.tool_calls ?? []) {\n        if (state.current_tool_call_index !== toolCall.index) {\n          this.#emitContentDoneEvents(choiceSnapshot);\n\n          // new tool call started, the previous one is done\n          if (state.current_tool_call_index != null) {\n            this.#emitToolCallDoneEvent(choiceSnapshot, state.current_tool_call_index);\n          }\n        }\n\n        state.current_tool_call_index = toolCall.index;\n      }\n\n      for (const toolCallDelta of choice.delta.tool_calls ?? []) {\n        const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallDelta.index];\n        if (!toolCallSnapshot?.type) {\n          continue;\n        }\n\n        if (toolCallSnapshot?.type === 'function') {\n          this._emit('tool_calls.function.arguments.delta', {\n            name: toolCallSnapshot.function?.name,\n            index: toolCallDelta.index,\n            arguments: toolCallSnapshot.function.arguments,\n            parsed_arguments: toolCallSnapshot.function.parsed_arguments,\n            arguments_delta: toolCallDelta.function?.arguments ?? '',\n          });\n        } else {\n          assertNever(toolCallSnapshot?.type);\n        }\n      }\n    }\n  }\n\n  #emitToolCallDoneEvent(choiceSnapshot: ChatCompletionSnapshot.Choice, toolCallIndex: number) {\n    const state = this.#getChoiceEventState(choiceSnapshot);\n    if (state.done_tool_calls.has(toolCallIndex)) {\n      // we've already fired the done event\n      return;\n    }\n\n    const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallIndex];\n    if (!toolCallSnapshot) {\n      throw new Error('no tool call snapshot');\n    }\n    if (!toolCallSnapshot.type) {\n      throw new Error('tool call snapshot missing `type`');\n    }\n\n    if (toolCallSnapshot.type === 'function') {\n      const inputTool = this.#params?.tools?.find(\n        (tool) => tool.type === 'function' && tool.function.name === toolCallSnapshot.function.name,\n      );\n\n      this._emit('tool_calls.function.arguments.done', {\n        name: toolCallSnapshot.function.name,\n        index: toolCallIndex,\n        arguments: toolCallSnapshot.function.arguments,\n        parsed_arguments:\n          isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCallSnapshot.function.arguments)\n          : inputTool?.function.strict ? JSON.parse(toolCallSnapshot.function.arguments)\n          : null,\n      });\n    } else {\n      assertNever(toolCallSnapshot.type);\n    }\n  }\n\n  #emitContentDoneEvents(choiceSnapshot: ChatCompletionSnapshot.Choice) {\n    const state = this.#getChoiceEventState(choiceSnapshot);\n\n    if (choiceSnapshot.message.content && !state.content_done) {\n      state.content_done = true;\n\n      const responseFormat = this.#getAutoParseableResponseFormat();\n\n      this._emit('content.done', {\n        content: choiceSnapshot.message.content,\n        parsed: responseFormat ? responseFormat.$parseRaw(choiceSnapshot.message.content) : (null as any),\n      });\n    }\n\n    if (choiceSnapshot.message.refusal && !state.refusal_done) {\n      state.refusal_done = true;\n\n      this._emit('refusal.done', { refusal: choiceSnapshot.message.refusal });\n    }\n\n    if (choiceSnapshot.logprobs?.content && !state.logprobs_content_done) {\n      state.logprobs_content_done = true;\n\n      this._emit('logprobs.content.done', { content: choiceSnapshot.logprobs.content });\n    }\n\n    if (choiceSnapshot.logprobs?.refusal && !state.logprobs_refusal_done) {\n      state.logprobs_refusal_done = true;\n\n      this._emit('logprobs.refusal.done', { refusal: choiceSnapshot.logprobs.refusal });\n    }\n  }\n\n  #endRequest(): ParsedChatCompletion<ParsedT> {\n    if (this.ended) {\n      throw new OpenAIError(`stream has ended, this shouldn't happen`);\n    }\n    const snapshot = this.#currentChatCompletionSnapshot;\n    if (!snapshot) {\n      throw new OpenAIError(`request ended without sending any chunks`);\n    }\n    this.#currentChatCompletionSnapshot = undefined;\n    this.#choiceEventStates = [];\n    return finalizeChatCompletion(snapshot, this.#params);\n  }\n\n  protected override async _createChatCompletion(\n    client: OpenAI,\n    params: ChatCompletionCreateParams,\n    options?: Core.RequestOptions,\n  ): Promise<ParsedChatCompletion<ParsedT>> {\n    super._createChatCompletion;\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    this.#beginRequest();\n\n    const stream = await client.chat.completions.create(\n      { ...params, stream: true },\n      { ...options, signal: this.controller.signal },\n    );\n    this._connected();\n    for await (const chunk of stream) {\n      this.#addChunk(chunk);\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n    return this._addChatCompletion(this.#endRequest());\n  }\n\n  protected async _fromReadableStream(\n    readableStream: ReadableStream,\n    options?: Core.RequestOptions,\n  ): Promise<ChatCompletion> {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    this.#beginRequest();\n    this._connected();\n    const stream = Stream.fromReadableStream<ChatCompletionChunk>(readableStream, this.controller);\n    let chatId;\n    for await (const chunk of stream) {\n      if (chatId && chatId !== chunk.id) {\n        // A new request has been made.\n        this._addChatCompletion(this.#endRequest());\n      }\n\n      this.#addChunk(chunk);\n      chatId = chunk.id;\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n    return this._addChatCompletion(this.#endRequest());\n  }\n\n  #getAutoParseableResponseFormat(): AutoParseableResponseFormat<ParsedT> | null {\n    const responseFormat = this.#params?.response_format;\n    if (isAutoParsableResponseFormat<ParsedT>(responseFormat)) {\n      return responseFormat;\n    }\n\n    return null;\n  }\n\n  #accumulateChatCompletion(chunk: ChatCompletionChunk): ChatCompletionSnapshot {\n    let snapshot = this.#currentChatCompletionSnapshot;\n    const { choices, ...rest } = chunk;\n    if (!snapshot) {\n      snapshot = this.#currentChatCompletionSnapshot = {\n        ...rest,\n        choices: [],\n      };\n    } else {\n      Object.assign(snapshot, rest);\n    }\n\n    for (const { delta, finish_reason, index, logprobs = null, ...other } of chunk.choices) {\n      let choice = snapshot.choices[index];\n      if (!choice) {\n        choice = snapshot.choices[index] = { finish_reason, index, message: {}, logprobs, ...other };\n      }\n\n      if (logprobs) {\n        if (!choice.logprobs) {\n          choice.logprobs = Object.assign({}, logprobs);\n        } else {\n          const { content, refusal, ...rest } = logprobs;\n          assertIsEmpty(rest);\n          Object.assign(choice.logprobs, rest);\n\n          if (content) {\n            choice.logprobs.content ??= [];\n            choice.logprobs.content.push(...content);\n          }\n\n          if (refusal) {\n            choice.logprobs.refusal ??= [];\n            choice.logprobs.refusal.push(...refusal);\n          }\n        }\n      }\n\n      if (finish_reason) {\n        choice.finish_reason = finish_reason;\n\n        if (this.#params && hasAutoParseableInput(this.#params)) {\n          if (finish_reason === 'length') {\n            throw new LengthFinishReasonError();\n          }\n\n          if (finish_reason === 'content_filter') {\n            throw new ContentFilterFinishReasonError();\n          }\n        }\n      }\n\n      Object.assign(choice, other);\n\n      if (!delta) continue; // Shouldn't happen; just in case.\n\n      const { content, refusal, function_call, role, tool_calls, ...rest } = delta;\n      assertIsEmpty(rest);\n      Object.assign(choice.message, rest);\n\n      if (refusal) {\n        choice.message.refusal = (choice.message.refusal || '') + refusal;\n      }\n\n      if (role) choice.message.role = role;\n      if (function_call) {\n        if (!choice.message.function_call) {\n          choice.message.function_call = function_call;\n        } else {\n          if (function_call.name) choice.message.function_call.name = function_call.name;\n          if (function_call.arguments) {\n            choice.message.function_call.arguments ??= '';\n            choice.message.function_call.arguments += function_call.arguments;\n          }\n        }\n      }\n      if (content) {\n        choice.message.content = (choice.message.content || '') + content;\n\n        if (!choice.message.refusal && this.#getAutoParseableResponseFormat()) {\n          choice.message.parsed = partialParse(choice.message.content);\n        }\n      }\n\n      if (tool_calls) {\n        if (!choice.message.tool_calls) choice.message.tool_calls = [];\n\n        for (const { index, id, type, function: fn, ...rest } of tool_calls) {\n          const tool_call = (choice.message.tool_calls[index] ??=\n            {} as ChatCompletionSnapshot.Choice.Message.ToolCall);\n          Object.assign(tool_call, rest);\n          if (id) tool_call.id = id;\n          if (type) tool_call.type = type;\n          if (fn) tool_call.function ??= { name: fn.name ?? '', arguments: '' };\n          if (fn?.name) tool_call.function!.name = fn.name;\n          if (fn?.arguments) {\n            tool_call.function!.arguments += fn.arguments;\n\n            if (shouldParseToolCall(this.#params, tool_call)) {\n              tool_call.function!.parsed_arguments = partialParse(tool_call.function!.arguments);\n            }\n          }\n        }\n      }\n    }\n    return snapshot;\n  }\n\n  [Symbol.asyncIterator](this: ChatCompletionStream<ParsedT>): AsyncIterator<ChatCompletionChunk> {\n    const pushQueue: ChatCompletionChunk[] = [];\n    const readQueue: {\n      resolve: (chunk: ChatCompletionChunk | undefined) => void;\n      reject: (err: unknown) => void;\n    }[] = [];\n    let done = false;\n\n    this.on('chunk', (chunk) => {\n      const reader = readQueue.shift();\n      if (reader) {\n        reader.resolve(chunk);\n      } else {\n        pushQueue.push(chunk);\n      }\n    });\n\n    this.on('end', () => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.resolve(undefined);\n      }\n      readQueue.length = 0;\n    });\n\n    this.on('abort', (err) => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n\n    this.on('error', (err) => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n\n    return {\n      next: async (): Promise<IteratorResult<ChatCompletionChunk>> => {\n        if (!pushQueue.length) {\n          if (done) {\n            return { value: undefined, done: true };\n          }\n          return new Promise<ChatCompletionChunk | undefined>((resolve, reject) =>\n            readQueue.push({ resolve, reject }),\n          ).then((chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }));\n        }\n        const chunk = pushQueue.shift()!;\n        return { value: chunk, done: false };\n      },\n      return: async () => {\n        this.abort();\n        return { value: undefined, done: true };\n      },\n    };\n  }\n\n  toReadableStream(): ReadableStream {\n    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n    return stream.toReadableStream();\n  }\n}\n\nfunction finalizeChatCompletion<ParsedT>(\n  snapshot: ChatCompletionSnapshot,\n  params: ChatCompletionCreateParams | null,\n): ParsedChatCompletion<ParsedT> {\n  const { id, choices, created, model, system_fingerprint, ...rest } = snapshot;\n  const completion: ChatCompletion = {\n    ...rest,\n    id,\n    choices: choices.map(\n      ({ message, finish_reason, index, logprobs, ...choiceRest }): ChatCompletion.Choice => {\n        if (!finish_reason) {\n          throw new OpenAIError(`missing finish_reason for choice ${index}`);\n        }\n\n        const { content = null, function_call, tool_calls, ...messageRest } = message;\n        const role = message.role as 'assistant'; // this is what we expect; in theory it could be different which would make our types a slight lie but would be fine.\n        if (!role) {\n          throw new OpenAIError(`missing role for choice ${index}`);\n        }\n\n        if (function_call) {\n          const { arguments: args, name } = function_call;\n          if (args == null) {\n            throw new OpenAIError(`missing function_call.arguments for choice ${index}`);\n          }\n\n          if (!name) {\n            throw new OpenAIError(`missing function_call.name for choice ${index}`);\n          }\n\n          return {\n            ...choiceRest,\n            message: {\n              content,\n              function_call: { arguments: args, name },\n              role,\n              refusal: message.refusal ?? null,\n            },\n            finish_reason,\n            index,\n            logprobs,\n          };\n        }\n\n        if (tool_calls) {\n          return {\n            ...choiceRest,\n            index,\n            finish_reason,\n            logprobs,\n            message: {\n              ...messageRest,\n              role,\n              content,\n              refusal: message.refusal ?? null,\n              tool_calls: tool_calls.map((tool_call, i) => {\n                const { function: fn, type, id, ...toolRest } = tool_call;\n                const { arguments: args, name, ...fnRest } = fn || {};\n                if (id == null) {\n                  throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].id\\n${str(snapshot)}`);\n                }\n                if (type == null) {\n                  throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].type\\n${str(snapshot)}`);\n                }\n                if (name == null) {\n                  throw new OpenAIError(\n                    `missing choices[${index}].tool_calls[${i}].function.name\\n${str(snapshot)}`,\n                  );\n                }\n                if (args == null) {\n                  throw new OpenAIError(\n                    `missing choices[${index}].tool_calls[${i}].function.arguments\\n${str(snapshot)}`,\n                  );\n                }\n\n                return { ...toolRest, id, type, function: { ...fnRest, name, arguments: args } };\n              }),\n            },\n          };\n        }\n        return {\n          ...choiceRest,\n          message: { ...messageRest, content, role, refusal: message.refusal ?? null },\n          finish_reason,\n          index,\n          logprobs,\n        };\n      },\n    ),\n    created,\n    model,\n    object: 'chat.completion',\n    ...(system_fingerprint ? { system_fingerprint } : {}),\n  };\n\n  return maybeParseChatCompletion(completion, params);\n}\n\nfunction str(x: unknown) {\n  return JSON.stringify(x);\n}\n\n/**\n * Represents a streamed chunk of a chat completion response returned by model,\n * based on the provided input.\n */\nexport interface ChatCompletionSnapshot {\n  /**\n   * A unique identifier for the chat completion.\n   */\n  id: string;\n\n  /**\n   * A list of chat completion choices. Can be more than one if `n` is greater\n   * than 1.\n   */\n  choices: Array<ChatCompletionSnapshot.Choice>;\n\n  /**\n   * The Unix timestamp (in seconds) of when the chat completion was created.\n   */\n  created: number;\n\n  /**\n   * The model to generate the completion.\n   */\n  model: string;\n\n  // Note we do not include an \"object\" type on the snapshot,\n  // because the object is not a valid \"chat.completion\" until finalized.\n  // object: 'chat.completion';\n\n  /**\n   * This fingerprint represents the backend configuration that the model runs with.\n   *\n   * Can be used in conjunction with the `seed` request parameter to understand when\n   * backend changes have been made that might impact determinism.\n   */\n  system_fingerprint?: string;\n}\n\nexport namespace ChatCompletionSnapshot {\n  export interface Choice {\n    /**\n     * A chat completion delta generated by streamed model responses.\n     */\n    message: Choice.Message;\n\n    /**\n     * The reason the model stopped generating tokens. This will be `stop` if the model\n     * hit a natural stop point or a provided stop sequence, `length` if the maximum\n     * number of tokens specified in the request was reached, `content_filter` if\n     * content was omitted due to a flag from our content filters, or `function_call`\n     * if the model called a function.\n     */\n    finish_reason: ChatCompletion.Choice['finish_reason'] | null;\n\n    /**\n     * Log probability information for the choice.\n     */\n    logprobs: ChatCompletion.Choice.Logprobs | null;\n\n    /**\n     * The index of the choice in the list of choices.\n     */\n    index: number;\n  }\n\n  export namespace Choice {\n    /**\n     * A chat completion delta generated by streamed model responses.\n     */\n    export interface Message {\n      /**\n       * The contents of the chunk message.\n       */\n      content?: string | null;\n\n      refusal?: string | null;\n\n      parsed?: unknown | null;\n\n      /**\n       * The name and arguments of a function that should be called, as generated by the\n       * model.\n       */\n      function_call?: Message.FunctionCall;\n\n      tool_calls?: Array<Message.ToolCall>;\n\n      /**\n       * The role of the author of this message.\n       */\n      role?: 'system' | 'user' | 'assistant' | 'function' | 'tool';\n    }\n\n    export namespace Message {\n      export interface ToolCall {\n        /**\n         * The ID of the tool call.\n         */\n        id: string;\n\n        function: ToolCall.Function;\n\n        /**\n         * The type of the tool.\n         */\n        type: 'function';\n      }\n\n      export namespace ToolCall {\n        export interface Function {\n          /**\n           * The arguments to call the function with, as generated by the model in JSON\n           * format. Note that the model does not always generate valid JSON, and may\n           * hallucinate parameters not defined by your function schema. Validate the\n           * arguments in your code before calling your function.\n           */\n          arguments: string;\n\n          parsed_arguments?: unknown;\n\n          /**\n           * The name of the function to call.\n           */\n          name: string;\n        }\n      }\n\n      /**\n       * The name and arguments of a function that should be called, as generated by the\n       * model.\n       */\n      export interface FunctionCall {\n        /**\n         * The arguments to call the function with, as generated by the model in JSON\n         * format. Note that the model does not always generate valid JSON, and may\n         * hallucinate parameters not defined by your function schema. Validate the\n         * arguments in your code before calling your function.\n         */\n        arguments?: string;\n\n        /**\n         * The name of the function to call.\n         */\n        name?: string;\n      }\n    }\n  }\n}\n\ntype AssertIsEmpty<T extends {}> = keyof T extends never ? T : never;\n\n/**\n * Ensures the given argument is an empty object, useful for\n * asserting that all known properties on an object have been\n * destructured.\n */\nfunction assertIsEmpty<T extends {}>(obj: AssertIsEmpty<T>): asserts obj is AssertIsEmpty<T> {\n  return;\n}\n\nfunction assertNever(_x: never) {}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}