{"ast":null,"code":"import { OrderByComparator } from \"../orderByComparator\";\nimport { FixedSizePriorityQueue } from \"../../utils/fixedSizePriorityQueue\";\nimport { getInitialHeader } from \"../headerUtils\";\n/**\n * @hidden\n * Represents an endpoint in handling an non-streaming order by query.\n */\nexport class NonStreamingOrderByEndpointComponent {\n  /**\n   * Represents an endpoint in handling an non-streaming order by query. For each processed orderby\n   * result it returns 'payload' item of the result\n   *\n   * @param executionContext - Underlying Execution Context\n   * @hidden\n   */\n  constructor(executionContext, sortOrders, priorityQueueBufferSize, offset = 0, emitRawOrderByPayload = false) {\n    this.executionContext = executionContext;\n    this.sortOrders = sortOrders;\n    this.priorityQueueBufferSize = priorityQueueBufferSize;\n    this.offset = offset;\n    this.emitRawOrderByPayload = emitRawOrderByPayload;\n    /**\n     * Flag to determine if all results are fetched from backend and results can be returned from priority queue.\n     */\n    this.isCompleted = false;\n    const comparator = new OrderByComparator(this.sortOrders);\n    this.nonStreamingOrderByPQ = new FixedSizePriorityQueue((a, b) => {\n      return comparator.compareItems(b, a);\n    }, this.priorityQueueBufferSize);\n  }\n  /**\n   * Determine if there are still remaining resources to processs.\n   * @returns true if there is other elements to process in the NonStreamingOrderByEndpointComponent.\n   */\n  hasMoreResults() {\n    return this.priorityQueueBufferSize > 0 && this.executionContext.hasMoreResults();\n  }\n  /**\n   * Fetches the next batch of the result from the target container.\n   * @param diagnosticNode - The diagnostic information for the request.\n   */\n  async fetchMore(diagnosticNode) {\n    if (this.isCompleted) {\n      return {\n        result: undefined,\n        headers: getInitialHeader()\n      };\n    }\n    let resHeaders = getInitialHeader();\n    // if size is 0, just return undefined to signal to more results. Valid if query is TOP 0 or LIMIT 0\n    if (this.priorityQueueBufferSize <= 0) {\n      return {\n        result: undefined,\n        headers: resHeaders\n      };\n    }\n    // If there are more results in backend, keep filling pq.\n    if (this.executionContext.hasMoreResults()) {\n      const response = await this.executionContext.fetchMore(diagnosticNode);\n      resHeaders = response.headers;\n      if (response === undefined || response.result === undefined) {\n        this.isCompleted = true;\n        if (!this.nonStreamingOrderByPQ.isEmpty()) {\n          return this.buildFinalResultArray(resHeaders);\n        }\n        return {\n          result: undefined,\n          headers: resHeaders\n        };\n      }\n      for (const item of response.result) {\n        if (item !== undefined) {\n          this.nonStreamingOrderByPQ.enqueue(item);\n        }\n      }\n    }\n    // If the backend has more results to fetch, return [] to signal that there are more results to fetch.\n    if (this.executionContext.hasMoreResults()) {\n      return {\n        result: [],\n        headers: resHeaders\n      };\n    }\n    // If all results are fetched from backend, prepare final results\n    if (!this.executionContext.hasMoreResults() && !this.isCompleted) {\n      this.isCompleted = true;\n      return this.buildFinalResultArray(resHeaders);\n    }\n    // If pq is empty, return undefined to signal that there are no more results.\n    return {\n      result: undefined,\n      headers: resHeaders\n    };\n  }\n  async buildFinalResultArray(resHeaders) {\n    var _a;\n    // Set isCompleted to true.\n    this.isCompleted = true;\n    // Reverse the priority queue to get the results in the correct order\n    this.nonStreamingOrderByPQ = this.nonStreamingOrderByPQ.reverse();\n    // For offset limit case we set the size of priority queue to offset + limit\n    // and we drain offset number of items from the priority queue\n    while (this.offset < this.priorityQueueBufferSize && this.offset > 0 && !this.nonStreamingOrderByPQ.isEmpty()) {\n      this.nonStreamingOrderByPQ.dequeue();\n      this.offset--;\n    }\n    // If pq is not empty, return the result from pq.\n    if (!this.nonStreamingOrderByPQ.isEmpty()) {\n      const buffer = [];\n      if (this.emitRawOrderByPayload) {\n        while (!this.nonStreamingOrderByPQ.isEmpty()) {\n          buffer.push(this.nonStreamingOrderByPQ.dequeue());\n        }\n      } else {\n        while (!this.nonStreamingOrderByPQ.isEmpty()) {\n          buffer.push((_a = this.nonStreamingOrderByPQ.dequeue()) === null || _a === void 0 ? void 0 : _a.payload);\n        }\n      }\n      return {\n        result: buffer,\n        headers: resHeaders\n      };\n    }\n  }\n}","map":{"version":3,"names":["OrderByComparator","FixedSizePriorityQueue","getInitialHeader","NonStreamingOrderByEndpointComponent","constructor","executionContext","sortOrders","priorityQueueBufferSize","offset","emitRawOrderByPayload","isCompleted","comparator","nonStreamingOrderByPQ","a","b","compareItems","hasMoreResults","fetchMore","diagnosticNode","result","undefined","headers","resHeaders","response","isEmpty","buildFinalResultArray","item","enqueue","reverse","dequeue","buffer","push","_a","payload"],"sources":["/Users/eimis/test-server/Azure Hackthons/azure-cloud-architecture-game /node_modules/@azure/cosmos/src/queryExecutionContext/EndpointComponent/NonStreamingOrderByEndpointComponent.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { DiagnosticNodeInternal } from \"../../diagnostics/DiagnosticNodeInternal\";\nimport type { Response } from \"../../request\";\nimport type { ExecutionContext } from \"../ExecutionContext\";\nimport { OrderByComparator } from \"../orderByComparator\";\nimport type { NonStreamingOrderByResult } from \"../nonStreamingOrderByResult\";\nimport { FixedSizePriorityQueue } from \"../../utils/fixedSizePriorityQueue\";\nimport type { CosmosHeaders } from \"../headerUtils\";\nimport { getInitialHeader } from \"../headerUtils\";\n\n/**\n * @hidden\n * Represents an endpoint in handling an non-streaming order by query.\n */\nexport class NonStreamingOrderByEndpointComponent implements ExecutionContext {\n  /**\n   * A priority queue to store the final sorted results.\n   */\n  private nonStreamingOrderByPQ: FixedSizePriorityQueue<NonStreamingOrderByResult>;\n  /**\n   * Flag to determine if all results are fetched from backend and results can be returned from priority queue.\n   */\n  private isCompleted: boolean = false;\n  /**\n   * Represents an endpoint in handling an non-streaming order by query. For each processed orderby\n   * result it returns 'payload' item of the result\n   *\n   * @param executionContext - Underlying Execution Context\n   * @hidden\n   */\n  constructor(\n    private executionContext: ExecutionContext,\n    private sortOrders: any[],\n    private priorityQueueBufferSize: number,\n    private offset: number = 0,\n    private emitRawOrderByPayload: boolean = false,\n  ) {\n    const comparator = new OrderByComparator(this.sortOrders);\n    this.nonStreamingOrderByPQ = new FixedSizePriorityQueue<NonStreamingOrderByResult>(\n      (a: NonStreamingOrderByResult, b: NonStreamingOrderByResult) => {\n        return comparator.compareItems(b, a);\n      },\n      this.priorityQueueBufferSize,\n    );\n  }\n\n  /**\n   * Determine if there are still remaining resources to processs.\n   * @returns true if there is other elements to process in the NonStreamingOrderByEndpointComponent.\n   */\n  public hasMoreResults(): boolean {\n    return this.priorityQueueBufferSize > 0 && this.executionContext.hasMoreResults();\n  }\n\n  /**\n   * Fetches the next batch of the result from the target container.\n   * @param diagnosticNode - The diagnostic information for the request.\n   */\n  public async fetchMore(diagnosticNode?: DiagnosticNodeInternal): Promise<Response<any>> {\n    if (this.isCompleted) {\n      return {\n        result: undefined,\n        headers: getInitialHeader(),\n      };\n    }\n    let resHeaders = getInitialHeader();\n    // if size is 0, just return undefined to signal to more results. Valid if query is TOP 0 or LIMIT 0\n    if (this.priorityQueueBufferSize <= 0) {\n      return {\n        result: undefined,\n        headers: resHeaders,\n      };\n    }\n    // If there are more results in backend, keep filling pq.\n    if (this.executionContext.hasMoreResults()) {\n      const response = await this.executionContext.fetchMore(diagnosticNode);\n      resHeaders = response.headers;\n      if (response === undefined || response.result === undefined) {\n        this.isCompleted = true;\n        if (!this.nonStreamingOrderByPQ.isEmpty()) {\n          return this.buildFinalResultArray(resHeaders);\n        }\n        return { result: undefined, headers: resHeaders };\n      }\n\n      for (const item of response.result) {\n        if (item !== undefined) {\n          this.nonStreamingOrderByPQ.enqueue(item);\n        }\n      }\n    }\n\n    // If the backend has more results to fetch, return [] to signal that there are more results to fetch.\n    if (this.executionContext.hasMoreResults()) {\n      return {\n        result: [],\n        headers: resHeaders,\n      };\n    }\n\n    // If all results are fetched from backend, prepare final results\n    if (!this.executionContext.hasMoreResults() && !this.isCompleted) {\n      this.isCompleted = true;\n      return this.buildFinalResultArray(resHeaders);\n    }\n\n    // If pq is empty, return undefined to signal that there are no more results.\n    return {\n      result: undefined,\n      headers: resHeaders,\n    };\n  }\n\n  private async buildFinalResultArray(resHeaders: CosmosHeaders): Promise<Response<any>> {\n    // Set isCompleted to true.\n    this.isCompleted = true;\n    // Reverse the priority queue to get the results in the correct order\n    this.nonStreamingOrderByPQ = this.nonStreamingOrderByPQ.reverse();\n    // For offset limit case we set the size of priority queue to offset + limit\n    // and we drain offset number of items from the priority queue\n    while (\n      this.offset < this.priorityQueueBufferSize &&\n      this.offset > 0 &&\n      !this.nonStreamingOrderByPQ.isEmpty()\n    ) {\n      this.nonStreamingOrderByPQ.dequeue();\n      this.offset--;\n    }\n\n    // If pq is not empty, return the result from pq.\n    if (!this.nonStreamingOrderByPQ.isEmpty()) {\n      const buffer: any[] = [];\n      if (this.emitRawOrderByPayload) {\n        while (!this.nonStreamingOrderByPQ.isEmpty()) {\n          buffer.push(this.nonStreamingOrderByPQ.dequeue());\n        }\n      } else {\n        while (!this.nonStreamingOrderByPQ.isEmpty()) {\n          buffer.push(this.nonStreamingOrderByPQ.dequeue()?.payload);\n        }\n      }\n      return {\n        result: buffer,\n        headers: resHeaders,\n      };\n    }\n  }\n}\n"],"mappings":"AAKA,SAASA,iBAAiB,QAAQ,sBAAsB;AAExD,SAASC,sBAAsB,QAAQ,oCAAoC;AAE3E,SAASC,gBAAgB,QAAQ,gBAAgB;AAEjD;;;;AAIA,OAAM,MAAOC,oCAAoC;EAS/C;;;;;;;EAOAC,YACUC,gBAAkC,EAClCC,UAAiB,EACjBC,uBAA+B,EAC/BC,MAAA,GAAiB,CAAC,EAClBC,qBAAA,GAAiC,KAAK;IAJtC,KAAAJ,gBAAgB,GAAhBA,gBAAgB;IAChB,KAAAC,UAAU,GAAVA,UAAU;IACV,KAAAC,uBAAuB,GAAvBA,uBAAuB;IACvB,KAAAC,MAAM,GAANA,MAAM;IACN,KAAAC,qBAAqB,GAArBA,qBAAqB;IAhB/B;;;IAGQ,KAAAC,WAAW,GAAY,KAAK;IAelC,MAAMC,UAAU,GAAG,IAAIX,iBAAiB,CAAC,IAAI,CAACM,UAAU,CAAC;IACzD,IAAI,CAACM,qBAAqB,GAAG,IAAIX,sBAAsB,CACrD,CAACY,CAA4B,EAAEC,CAA4B,KAAI;MAC7D,OAAOH,UAAU,CAACI,YAAY,CAACD,CAAC,EAAED,CAAC,CAAC;IACtC,CAAC,EACD,IAAI,CAACN,uBAAuB,CAC7B;EACH;EAEA;;;;EAIOS,cAAcA,CAAA;IACnB,OAAO,IAAI,CAACT,uBAAuB,GAAG,CAAC,IAAI,IAAI,CAACF,gBAAgB,CAACW,cAAc,EAAE;EACnF;EAEA;;;;EAIO,MAAMC,SAASA,CAACC,cAAuC;IAC5D,IAAI,IAAI,CAACR,WAAW,EAAE;MACpB,OAAO;QACLS,MAAM,EAAEC,SAAS;QACjBC,OAAO,EAAEnB,gBAAgB;OAC1B;IACH;IACA,IAAIoB,UAAU,GAAGpB,gBAAgB,EAAE;IACnC;IACA,IAAI,IAAI,CAACK,uBAAuB,IAAI,CAAC,EAAE;MACrC,OAAO;QACLY,MAAM,EAAEC,SAAS;QACjBC,OAAO,EAAEC;OACV;IACH;IACA;IACA,IAAI,IAAI,CAACjB,gBAAgB,CAACW,cAAc,EAAE,EAAE;MAC1C,MAAMO,QAAQ,GAAG,MAAM,IAAI,CAAClB,gBAAgB,CAACY,SAAS,CAACC,cAAc,CAAC;MACtEI,UAAU,GAAGC,QAAQ,CAACF,OAAO;MAC7B,IAAIE,QAAQ,KAAKH,SAAS,IAAIG,QAAQ,CAACJ,MAAM,KAAKC,SAAS,EAAE;QAC3D,IAAI,CAACV,WAAW,GAAG,IAAI;QACvB,IAAI,CAAC,IAAI,CAACE,qBAAqB,CAACY,OAAO,EAAE,EAAE;UACzC,OAAO,IAAI,CAACC,qBAAqB,CAACH,UAAU,CAAC;QAC/C;QACA,OAAO;UAAEH,MAAM,EAAEC,SAAS;UAAEC,OAAO,EAAEC;QAAU,CAAE;MACnD;MAEA,KAAK,MAAMI,IAAI,IAAIH,QAAQ,CAACJ,MAAM,EAAE;QAClC,IAAIO,IAAI,KAAKN,SAAS,EAAE;UACtB,IAAI,CAACR,qBAAqB,CAACe,OAAO,CAACD,IAAI,CAAC;QAC1C;MACF;IACF;IAEA;IACA,IAAI,IAAI,CAACrB,gBAAgB,CAACW,cAAc,EAAE,EAAE;MAC1C,OAAO;QACLG,MAAM,EAAE,EAAE;QACVE,OAAO,EAAEC;OACV;IACH;IAEA;IACA,IAAI,CAAC,IAAI,CAACjB,gBAAgB,CAACW,cAAc,EAAE,IAAI,CAAC,IAAI,CAACN,WAAW,EAAE;MAChE,IAAI,CAACA,WAAW,GAAG,IAAI;MACvB,OAAO,IAAI,CAACe,qBAAqB,CAACH,UAAU,CAAC;IAC/C;IAEA;IACA,OAAO;MACLH,MAAM,EAAEC,SAAS;MACjBC,OAAO,EAAEC;KACV;EACH;EAEQ,MAAMG,qBAAqBA,CAACH,UAAyB;;IAC3D;IACA,IAAI,CAACZ,WAAW,GAAG,IAAI;IACvB;IACA,IAAI,CAACE,qBAAqB,GAAG,IAAI,CAACA,qBAAqB,CAACgB,OAAO,EAAE;IACjE;IACA;IACA,OACE,IAAI,CAACpB,MAAM,GAAG,IAAI,CAACD,uBAAuB,IAC1C,IAAI,CAACC,MAAM,GAAG,CAAC,IACf,CAAC,IAAI,CAACI,qBAAqB,CAACY,OAAO,EAAE,EACrC;MACA,IAAI,CAACZ,qBAAqB,CAACiB,OAAO,EAAE;MACpC,IAAI,CAACrB,MAAM,EAAE;IACf;IAEA;IACA,IAAI,CAAC,IAAI,CAACI,qBAAqB,CAACY,OAAO,EAAE,EAAE;MACzC,MAAMM,MAAM,GAAU,EAAE;MACxB,IAAI,IAAI,CAACrB,qBAAqB,EAAE;QAC9B,OAAO,CAAC,IAAI,CAACG,qBAAqB,CAACY,OAAO,EAAE,EAAE;UAC5CM,MAAM,CAACC,IAAI,CAAC,IAAI,CAACnB,qBAAqB,CAACiB,OAAO,EAAE,CAAC;QACnD;MACF,CAAC,MAAM;QACL,OAAO,CAAC,IAAI,CAACjB,qBAAqB,CAACY,OAAO,EAAE,EAAE;UAC5CM,MAAM,CAACC,IAAI,CAAC,CAAAC,EAAA,OAAI,CAACpB,qBAAqB,CAACiB,OAAO,EAAE,cAAAG,EAAA,uBAAAA,EAAA,CAAEC,OAAO,CAAC;QAC5D;MACF;MACA,OAAO;QACLd,MAAM,EAAEW,MAAM;QACdT,OAAO,EAAEC;OACV;IACH;EACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}