{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { parseWWWAuthenticateHeader } from \"./parseWWWAuthenticate.js\";\nimport { createTokenCycler } from \"./tokenCycler.js\";\nimport { logger } from \"./logger.js\";\nfunction verifyChallengeResource(scope, request) {\n  let scopeAsUrl;\n  try {\n    scopeAsUrl = new URL(scope);\n  } catch (e) {\n    throw new Error(`The challenge contains invalid scope '${scope}'`);\n  }\n  const requestUrl = new URL(request.url);\n  if (!requestUrl.hostname.endsWith(`.${scopeAsUrl.hostname}`)) {\n    throw new Error(`The challenge resource '${scopeAsUrl.hostname}' does not match the requested domain. Set disableChallengeResourceVerification to true in your client options to disable. See https://aka.ms/azsdk/blog/vault-uri for more information.`);\n  }\n}\n/**\n * Name of the Key Vault authentication policy.\n */\nexport const keyVaultAuthenticationPolicyName = \"keyVaultAuthenticationPolicy\";\n/**\n * A custom implementation of the bearer-token authentication policy that handles Key Vault and CAE challenges.\n *\n * Key Vault supports other authentication schemes, but we ensure challenge authentication\n * is used by first sending a copy of the request, without authorization or content.\n *\n * when the challenge is received, it will be authenticated and used to send the original\n * request with authorization.\n *\n * Following the first request of a client, follow-up requests will get the cached token\n * if possible.\n *\n */\nexport function keyVaultAuthenticationPolicy(credential, options = {}) {\n  const {\n    disableChallengeResourceVerification\n  } = options;\n  let challengeState = {\n    status: \"none\"\n  };\n  const getAccessToken = createTokenCycler(credential);\n  function requestToOptions(request) {\n    return {\n      abortSignal: request.abortSignal,\n      requestOptions: {\n        timeout: request.timeout > 0 ? request.timeout : undefined\n      },\n      tracingOptions: request.tracingOptions\n    };\n  }\n  async function authorizeRequest(request) {\n    const requestOptions = requestToOptions(request);\n    switch (challengeState.status) {\n      case \"none\":\n        challengeState = {\n          status: \"started\",\n          originalBody: request.body\n        };\n        request.body = null;\n        break;\n      case \"started\":\n        break;\n      // Retry, we should not overwrite the original body\n      case \"complete\":\n        {\n          const token = await getAccessToken(challengeState.scopes, Object.assign(Object.assign({}, requestOptions), {\n            enableCae: true,\n            tenantId: challengeState.tenantId\n          }));\n          if (token) {\n            request.headers.set(\"authorization\", `Bearer ${token.token}`);\n          }\n          break;\n        }\n    }\n  }\n  async function handleChallenge(request, response, next) {\n    // If status is not 401, this is a no-op\n    if (response.status !== 401) {\n      return response;\n    }\n    if (request.body === null && challengeState.status === \"started\") {\n      // Reset the original body before doing anything else.\n      // Note: If successful status will be \"complete\", otherwise \"none\" will\n      // restart the process.\n      request.body = challengeState.originalBody;\n    }\n    const getTokenOptions = requestToOptions(request);\n    const challenge = response.headers.get(\"WWW-Authenticate\");\n    if (!challenge) {\n      logger.warning(\"keyVaultAuthentication policy encountered a 401 response without a corresponding WWW-Authenticate header. This is unexpected. Not handling the 401 response.\");\n      return response;\n    }\n    const parsedChallenge = parseWWWAuthenticateHeader(challenge);\n    const scope = parsedChallenge.resource ? parsedChallenge.resource + \"/.default\" : parsedChallenge.scope;\n    if (!scope) {\n      // Cannot handle this kind of challenge here (if scope is not present, may be a CAE challenge)\n      return response;\n    }\n    if (!disableChallengeResourceVerification) {\n      verifyChallengeResource(scope, request);\n    }\n    const accessToken = await getAccessToken([scope], Object.assign(Object.assign({}, getTokenOptions), {\n      enableCae: true,\n      tenantId: parsedChallenge.tenantId\n    }));\n    if (!accessToken) {\n      // No access token provided, treat as no-op\n      return response;\n    }\n    request.headers.set(\"Authorization\", `Bearer ${accessToken.token}`);\n    challengeState = {\n      status: \"complete\",\n      scopes: [scope],\n      tenantId: parsedChallenge.tenantId\n    };\n    // We have a token now, so try send the request again\n    return next(request);\n  }\n  async function handleCaeChallenge(request, response, next) {\n    // Cannot handle CAE challenge if a regular challenge has not been completed first\n    if (challengeState.status !== \"complete\") {\n      return response;\n    }\n    // If status is not 401, this is a no-op\n    if (response.status !== 401) {\n      return response;\n    }\n    const getTokenOptions = requestToOptions(request);\n    const challenge = response.headers.get(\"WWW-Authenticate\");\n    if (!challenge) {\n      return response;\n    }\n    const {\n      claims: base64EncodedClaims,\n      error\n    } = parseWWWAuthenticateHeader(challenge);\n    if (error !== \"insufficient_claims\" || base64EncodedClaims === undefined) {\n      return response;\n    }\n    const claims = atob(base64EncodedClaims);\n    const accessToken = await getAccessToken(challengeState.scopes, Object.assign(Object.assign({}, getTokenOptions), {\n      enableCae: true,\n      tenantId: challengeState.tenantId,\n      claims\n    }));\n    request.headers.set(\"Authorization\", `Bearer ${accessToken.token}`);\n    return next(request);\n  }\n  async function sendRequest(request, next) {\n    // Add token if possible\n    await authorizeRequest(request);\n    // Try send request (first attempt)\n    let response = await next(request);\n    // Handle standard challenge if present\n    response = await handleChallenge(request, response, next);\n    // Handle CAE challenge if present\n    response = await handleCaeChallenge(request, response, next);\n    return response;\n  }\n  return {\n    name: keyVaultAuthenticationPolicyName,\n    sendRequest\n  };\n}","map":{"version":3,"names":["parseWWWAuthenticateHeader","createTokenCycler","logger","verifyChallengeResource","scope","request","scopeAsUrl","URL","e","Error","requestUrl","url","hostname","endsWith","keyVaultAuthenticationPolicyName","keyVaultAuthenticationPolicy","credential","options","disableChallengeResourceVerification","challengeState","status","getAccessToken","requestToOptions","abortSignal","requestOptions","timeout","undefined","tracingOptions","authorizeRequest","originalBody","body","token","scopes","Object","assign","enableCae","tenantId","headers","set","handleChallenge","response","next","getTokenOptions","challenge","get","warning","parsedChallenge","resource","accessToken","handleCaeChallenge","claims","base64EncodedClaims","error","atob","sendRequest","name"],"sources":["/Users/eimis/test-server/Azure Hackthons/azure-cloud-architecture-game /node_modules/@azure/keyvault-common/src/keyVaultAuthenticationPolicy.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport {\n  PipelinePolicy,\n  PipelineRequest,\n  PipelineResponse,\n  RequestBodyType,\n  SendRequest,\n} from \"@azure/core-rest-pipeline\";\nimport { WWWAuthenticate, parseWWWAuthenticateHeader } from \"./parseWWWAuthenticate.js\";\n\nimport { GetTokenOptions, TokenCredential } from \"@azure/core-auth\";\nimport { createTokenCycler } from \"./tokenCycler.js\";\nimport { logger } from \"./logger.js\";\n\n/**\n * @internal\n * Holds the state of Challenge Auth.\n * When making the first request we force Key Vault to begin a challenge\n * by clearing out the request body and storing it locally.\n *\n * Later on, the authorizeRequestOnChallenge callback will process the\n * challenge and, if ready to resend the original request, reset the body\n * so that it may be sent again.\n *\n * Once a client has succeeded once, we can start skipping CAE.\n */\ntype ChallengeState =\n  | {\n      status: \"none\";\n    }\n  | {\n      status: \"started\";\n      originalBody?: RequestBodyType;\n    }\n  | {\n      status: \"complete\";\n      scopes: string[];\n      tenantId?: string;\n    };\n\n/**\n * Additional options for the challenge based authentication policy.\n */\nexport interface KeyVaultAuthenticationPolicyOptions {\n  /**\n   * Whether to disable verification that the challenge resource matches the Key Vault or Managed HSM domain.\n   *\n   * Defaults to false.\n   */\n  disableChallengeResourceVerification?: boolean;\n}\n\nfunction verifyChallengeResource(scope: string, request: PipelineRequest): void {\n  let scopeAsUrl: URL;\n  try {\n    scopeAsUrl = new URL(scope);\n  } catch (e) {\n    throw new Error(`The challenge contains invalid scope '${scope}'`);\n  }\n\n  const requestUrl = new URL(request.url);\n\n  if (!requestUrl.hostname.endsWith(`.${scopeAsUrl.hostname}`)) {\n    throw new Error(\n      `The challenge resource '${scopeAsUrl.hostname}' does not match the requested domain. Set disableChallengeResourceVerification to true in your client options to disable. See https://aka.ms/azsdk/blog/vault-uri for more information.`,\n    );\n  }\n}\n\n/**\n * Name of the Key Vault authentication policy.\n */\nexport const keyVaultAuthenticationPolicyName = \"keyVaultAuthenticationPolicy\";\n\n/**\n * A custom implementation of the bearer-token authentication policy that handles Key Vault and CAE challenges.\n *\n * Key Vault supports other authentication schemes, but we ensure challenge authentication\n * is used by first sending a copy of the request, without authorization or content.\n *\n * when the challenge is received, it will be authenticated and used to send the original\n * request with authorization.\n *\n * Following the first request of a client, follow-up requests will get the cached token\n * if possible.\n *\n */\nexport function keyVaultAuthenticationPolicy(\n  credential: TokenCredential,\n  options: KeyVaultAuthenticationPolicyOptions = {},\n): PipelinePolicy {\n  const { disableChallengeResourceVerification } = options;\n  let challengeState: ChallengeState = { status: \"none\" };\n  const getAccessToken = createTokenCycler(credential);\n\n  function requestToOptions(request: PipelineRequest): GetTokenOptions {\n    return {\n      abortSignal: request.abortSignal,\n      requestOptions: {\n        timeout: request.timeout > 0 ? request.timeout : undefined,\n      },\n      tracingOptions: request.tracingOptions,\n    };\n  }\n\n  async function authorizeRequest(request: PipelineRequest): Promise<void> {\n    const requestOptions: GetTokenOptions = requestToOptions(request);\n\n    switch (challengeState.status) {\n      case \"none\":\n        challengeState = {\n          status: \"started\",\n          originalBody: request.body,\n        };\n        request.body = null;\n        break;\n      case \"started\":\n        break; // Retry, we should not overwrite the original body\n      case \"complete\": {\n        const token = await getAccessToken(challengeState.scopes, {\n          ...requestOptions,\n          enableCae: true,\n          tenantId: challengeState.tenantId,\n        });\n        if (token) {\n          request.headers.set(\"authorization\", `Bearer ${token.token}`);\n        }\n        break;\n      }\n    }\n  }\n\n  async function handleChallenge(\n    request: PipelineRequest,\n    response: PipelineResponse,\n    next: SendRequest,\n  ): Promise<PipelineResponse> {\n    // If status is not 401, this is a no-op\n    if (response.status !== 401) {\n      return response;\n    }\n\n    if (request.body === null && challengeState.status === \"started\") {\n      // Reset the original body before doing anything else.\n      // Note: If successful status will be \"complete\", otherwise \"none\" will\n      // restart the process.\n      request.body = challengeState.originalBody;\n    }\n\n    const getTokenOptions = requestToOptions(request);\n\n    const challenge = response.headers.get(\"WWW-Authenticate\");\n    if (!challenge) {\n      logger.warning(\n        \"keyVaultAuthentication policy encountered a 401 response without a corresponding WWW-Authenticate header. This is unexpected. Not handling the 401 response.\",\n      );\n      return response;\n    }\n    const parsedChallenge: WWWAuthenticate = parseWWWAuthenticateHeader(challenge);\n\n    const scope = parsedChallenge.resource\n      ? parsedChallenge.resource + \"/.default\"\n      : parsedChallenge.scope;\n\n    if (!scope) {\n      // Cannot handle this kind of challenge here (if scope is not present, may be a CAE challenge)\n      return response;\n    }\n\n    if (!disableChallengeResourceVerification) {\n      verifyChallengeResource(scope, request);\n    }\n\n    const accessToken = await getAccessToken([scope], {\n      ...getTokenOptions,\n      enableCae: true,\n      tenantId: parsedChallenge.tenantId,\n    });\n\n    if (!accessToken) {\n      // No access token provided, treat as no-op\n      return response;\n    }\n\n    request.headers.set(\"Authorization\", `Bearer ${accessToken.token}`);\n\n    challengeState = {\n      status: \"complete\",\n      scopes: [scope],\n      tenantId: parsedChallenge.tenantId,\n    };\n\n    // We have a token now, so try send the request again\n    return next(request);\n  }\n\n  async function handleCaeChallenge(\n    request: PipelineRequest,\n    response: PipelineResponse,\n    next: SendRequest,\n  ): Promise<PipelineResponse> {\n    // Cannot handle CAE challenge if a regular challenge has not been completed first\n    if (challengeState.status !== \"complete\") {\n      return response;\n    }\n\n    // If status is not 401, this is a no-op\n    if (response.status !== 401) {\n      return response;\n    }\n\n    const getTokenOptions = requestToOptions(request);\n\n    const challenge = response.headers.get(\"WWW-Authenticate\");\n    if (!challenge) {\n      return response;\n    }\n    const { claims: base64EncodedClaims, error }: WWWAuthenticate =\n      parseWWWAuthenticateHeader(challenge);\n\n    if (error !== \"insufficient_claims\" || base64EncodedClaims === undefined) {\n      return response;\n    }\n\n    const claims = atob(base64EncodedClaims);\n\n    const accessToken = await getAccessToken(challengeState.scopes, {\n      ...getTokenOptions,\n      enableCae: true,\n      tenantId: challengeState.tenantId,\n      claims,\n    });\n\n    request.headers.set(\"Authorization\", `Bearer ${accessToken.token}`);\n\n    return next(request);\n  }\n\n  async function sendRequest(\n    request: PipelineRequest,\n    next: SendRequest,\n  ): Promise<PipelineResponse> {\n    // Add token if possible\n    await authorizeRequest(request);\n\n    // Try send request (first attempt)\n    let response = await next(request);\n\n    // Handle standard challenge if present\n    response = await handleChallenge(request, response, next);\n\n    // Handle CAE challenge if present\n    response = await handleCaeChallenge(request, response, next);\n\n    return response;\n  }\n\n  return {\n    name: keyVaultAuthenticationPolicyName,\n    sendRequest,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}