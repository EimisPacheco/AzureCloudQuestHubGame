{"ast":null,"code":"/**\n * Utility functions for the Azure Icons Memory Game\n */\n\nimport { SERVICE_MAPPINGS } from '../services/IconResolver';\nimport { soundManager } from '../services/SoundManager';\n\n// Get a random selection of unique Azure services from SERVICE_MAPPINGS\nexport const getRandomAzureServices = (count = 12) => {\n  // Get all service names (keys) from SERVICE_MAPPINGS\n  const serviceNames = Object.keys(SERVICE_MAPPINGS);\n\n  // Shuffle the array of service names\n  const shuffled = [...serviceNames].sort(() => 0.5 - Math.random());\n\n  // Take only the number of services we need\n  return shuffled.slice(0, count);\n};\n\n// Create a deck of cards with pairs of Azure services\nexport const createCardDeck = services => {\n  // Create pairs of each service\n  const pairs = services.flatMap(service => [{\n    id: `${service}-1`,\n    service,\n    path: SERVICE_MAPPINGS[service]\n  }, {\n    id: `${service}-2`,\n    service,\n    path: SERVICE_MAPPINGS[service]\n  }]);\n\n  // Shuffle the deck\n  return pairs.sort(() => 0.5 - Math.random());\n};\n\n// Initialize a new game state\nexport const initializeGameState = (pairCount = 12) => {\n  // Get random Azure services\n  const selectedServices = getRandomAzureServices(pairCount);\n\n  // Create and shuffle the card deck\n  const deck = createCardDeck(selectedServices);\n\n  // Create the initial game state\n  return {\n    cards: deck.map((card, index) => ({\n      ...card,\n      index,\n      isFlipped: false,\n      isMatched: false\n    })),\n    flippedCards: [],\n    matchedPairs: [],\n    isLocked: false,\n    gameOver: false,\n    timeLeft: 120 // 2 minutes in seconds\n  };\n};\n\n// Format time as MM:SS\nexport const formatTime = seconds => {\n  const minutes = Math.floor(seconds / 60);\n  const secs = seconds % 60;\n  return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n};\n\n// Check if the game is over (all pairs found)\nexport const isGameComplete = (matchedPairs, totalPairs) => {\n  return matchedPairs.length === totalPairs;\n};\n\n// Get the full icon URL for a service\nexport const getServiceIconUrl = servicePath => {\n  const S3_BUCKET_URL = process.env.REACT_APP_AZURE_BUCKET_URL || '';\n  const ICONS_BASE_PATH = process.env.REACT_APP_ICONS_BASE_PATH || '';\n  return `${S3_BUCKET_URL}${ICONS_BASE_PATH}${servicePath}`;\n};\n\n// Play sound for correct match\nexport const playCorrectMatchSound = () => {\n  try {\n    soundManager.play('correct');\n  } catch (error) {\n    console.log('Could not play correct sound:', error);\n  }\n};\n\n// Play sound for incorrect match\nexport const playIncorrectMatchSound = () => {\n  try {\n    soundManager.play('incorrect');\n  } catch (error) {\n    console.log('Could not play incorrect sound:', error);\n  }\n};\n\n// Play sound for game completion\nexport const playGameCompleteSound = () => {\n  try {\n    soundManager.play('complete');\n  } catch (error) {\n    console.log('Could not play complete sound:', error);\n  }\n};\n\n// Play sound for card flip\nexport const playCardFlipSound = () => {\n  try {\n    soundManager.play('flip');\n  } catch (error) {\n    console.log('Could not play flip sound:', error);\n  }\n};","map":{"version":3,"names":["SERVICE_MAPPINGS","soundManager","getRandomAzureServices","count","serviceNames","Object","keys","shuffled","sort","Math","random","slice","createCardDeck","services","pairs","flatMap","service","id","path","initializeGameState","pairCount","selectedServices","deck","cards","map","card","index","isFlipped","isMatched","flippedCards","matchedPairs","isLocked","gameOver","timeLeft","formatTime","seconds","minutes","floor","secs","toString","padStart","isGameComplete","totalPairs","length","getServiceIconUrl","servicePath","S3_BUCKET_URL","process","env","REACT_APP_AZURE_BUCKET_URL","ICONS_BASE_PATH","REACT_APP_ICONS_BASE_PATH","playCorrectMatchSound","play","error","console","log","playIncorrectMatchSound","playGameCompleteSound","playCardFlipSound"],"sources":["/Users/eimis/test-server/Azure Hackthons/azure-cloud-architecture-game /src/utils/memoryGameUtils.js"],"sourcesContent":["/**\n * Utility functions for the Azure Icons Memory Game\n */\n\nimport { SERVICE_MAPPINGS } from '../services/IconResolver';\nimport { soundManager } from '../services/SoundManager';\n\n// Get a random selection of unique Azure services from SERVICE_MAPPINGS\nexport const getRandomAzureServices = (count = 12) => {\n  // Get all service names (keys) from SERVICE_MAPPINGS\n  const serviceNames = Object.keys(SERVICE_MAPPINGS);\n  \n  // Shuffle the array of service names\n  const shuffled = [...serviceNames].sort(() => 0.5 - Math.random());\n  \n  // Take only the number of services we need\n  return shuffled.slice(0, count);\n};\n\n// Create a deck of cards with pairs of Azure services\nexport const createCardDeck = (services) => {\n  // Create pairs of each service\n  const pairs = services.flatMap(service => [\n    { id: `${service}-1`, service, path: SERVICE_MAPPINGS[service] },\n    { id: `${service}-2`, service, path: SERVICE_MAPPINGS[service] }\n  ]);\n  \n  // Shuffle the deck\n  return pairs.sort(() => 0.5 - Math.random());\n};\n\n// Initialize a new game state\nexport const initializeGameState = (pairCount = 12) => {\n  // Get random Azure services\n  const selectedServices = getRandomAzureServices(pairCount);\n  \n  // Create and shuffle the card deck\n  const deck = createCardDeck(selectedServices);\n  \n  // Create the initial game state\n  return {\n    cards: deck.map((card, index) => ({\n      ...card,\n      index,\n      isFlipped: false,\n      isMatched: false\n    })),\n    flippedCards: [],\n    matchedPairs: [],\n    isLocked: false,\n    gameOver: false,\n    timeLeft: 120 // 2 minutes in seconds\n  };\n};\n\n// Format time as MM:SS\nexport const formatTime = (seconds) => {\n  const minutes = Math.floor(seconds / 60);\n  const secs = seconds % 60;\n  return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n};\n\n// Check if the game is over (all pairs found)\nexport const isGameComplete = (matchedPairs, totalPairs) => {\n  return matchedPairs.length === totalPairs;\n};\n\n// Get the full icon URL for a service\nexport const getServiceIconUrl = (servicePath) => {\n  const S3_BUCKET_URL = process.env.REACT_APP_AZURE_BUCKET_URL || '';\n  const ICONS_BASE_PATH = process.env.REACT_APP_ICONS_BASE_PATH || '';\n  \n  return `${S3_BUCKET_URL}${ICONS_BASE_PATH}${servicePath}`;\n};\n\n// Play sound for correct match\nexport const playCorrectMatchSound = () => {\n  try {\n    soundManager.play('correct');\n  } catch (error) {\n    console.log('Could not play correct sound:', error);\n  }\n};\n\n// Play sound for incorrect match\nexport const playIncorrectMatchSound = () => {\n  try {\n    soundManager.play('incorrect');\n  } catch (error) {\n    console.log('Could not play incorrect sound:', error);\n  }\n};\n\n// Play sound for game completion\nexport const playGameCompleteSound = () => {\n  try {\n    soundManager.play('complete');\n  } catch (error) {\n    console.log('Could not play complete sound:', error);\n  }\n};\n\n// Play sound for card flip\nexport const playCardFlipSound = () => {\n  try {\n    soundManager.play('flip');\n  } catch (error) {\n    console.log('Could not play flip sound:', error);\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}